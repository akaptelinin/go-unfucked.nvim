==============================================================================
/opt/homebrew/share/lua/5.4/busted/block.lua
==============================================================================
******0 local getfenv = require 'busted.compatibility'.getfenv
******0 local unpack = require 'busted.compatibility'.unpack
******0 local shuffle = require 'busted.utils'.shuffle

        local function sort(elements)
******0   table.sort(elements, function(t1, t2)
******0     if t1.name and t2.name then
******0       return t1.name < t2.name
            end
******0     return t2.name ~= nil
          end)
******0   return elements
        end

        return function(busted)
      6   local block = {}
      6   local root = busted.context.get()

      6   function block.reject(descriptor, element)
  55329     element.env[descriptor] = function(...)
******0       error("'" .. descriptor .. "' not supported inside current context block", 2)
            end
          end

      6   function block.rejectAll(element)
   3345     local env = getfenv(element.run)
   3345     block.reject('randomize', element)
  60210     for descriptor, _ in pairs(busted.executors) do
  56865       if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then
  51984         block.reject(descriptor, element)
              end
            end
          end

          local function exec(descriptor, element)
   2254     if not element.env then element.env = {} end
   2254     block.rejectAll(element)
   2254     local ret = { busted.safe(descriptor, element.run, element) }
   2254     return unpack(ret)
          end

      6   function block.execAllOnce(descriptor, current, err)
   4783     local parent = busted.context.parent(current)

   4783     if parent then
   3692       local success = block.execAllOnce(descriptor, parent)
   3692       if not success then
******0         return success
              end
            end

   4783     if not current[descriptor] then
    166       current[descriptor] = {}
            end
   4783     local list = current[descriptor]
   4783     if list.success ~= nil then
   4617       return list.success
            end

    166     local success = true
    166     for _, v in ipairs(list) do
******0       if not exec(descriptor, v):success() then
******0         if err then err(descriptor) end
******0         success = false
              end
            end

    166     list.success = success

    166     return success
          end

      6   function block.execAll(descriptor, current, propagate, err)
   4949     local parent = busted.context.parent(current)

   4949     if propagate and parent then
   3692       local success, ancestor = block.execAll(descriptor, parent, propagate)
   3692       if not success then
******0         return success, ancestor
              end
            end

   4949     local list = current[descriptor] or {}

   4949     local success = true
   7203     for _, v in ipairs(list) do
   2254       if not exec(descriptor, v):success() then
******0         if err then err(descriptor) end
******0         success = nil
              end
            end
   4949     return success, current
          end

      6   function block.dexecAll(descriptor, current, propagate, err)
   5115     local parent = busted.context.parent(current)
   5115     local list = current[descriptor] or {}

   5115     local success = true
   5115     for _, v in ipairs(list) do
******0       if not exec(descriptor, v):success() then
******0         if err then err(descriptor) end
******0         success = nil
              end
            end

   5115     if propagate and parent then
   3692       if not block.dexecAll(descriptor, parent, propagate) then
******0         success = nil
              end
            end
   5115     return success
          end

      6   function block.lazySetup(element, err)
   1091     return block.execAllOnce('lazy_setup', element, err)
          end

      6   function block.lazyTeardown(element, err)
    166     if element.lazy_setup and element.lazy_setup.success ~= nil then
    166       block.dexecAll('lazy_teardown', element, nil, err)
    166       element.lazy_setup.success = nil
            end
          end

      6   function block.setup(element, err)
    166       return block.execAll('strict_setup', element, nil, err)
          end

      6   function block.teardown(element, err)
    166       return block.dexecAll('strict_teardown', element, nil, err)
          end

      6   function block.execute(descriptor, element)
    160     if not element.env then element.env = {} end

    160     local randomize = busted.randomize
    160     local randomseed = busted.randomseed
    160     element.env.randomize = function(...)
******0       randomize = (select('#', ...) == 0 or ...)
******0       if randomize then
******0         randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed
              end
            end

    160     if busted.safe(descriptor, element.run, element):success() then
    160       if busted.sort then
******0         sort(busted.context.children(element))
    160       elseif randomize then
******0         element.randomseed = randomseed
******0         shuffle(busted.context.children(element), randomseed)
              end

    160       if block.setup(element) then
    160         busted.execute(element)
              end

    160       block.lazyTeardown(element)
    160       block.teardown(element)
            end
          end

      6   return block
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/compatibility.lua
==============================================================================
******0 return {
******0   getfenv = getfenv or function(f)
   3345     f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
            local name, value
   3345     local up = 0

            repeat
   4948       up = up + 1
   4948       name, value = debug.getupvalue(f, up)
   4948     until name == '_ENV' or name == nil

   3345     return name and value or _G
          end,

******0   setfenv = setfenv or function(f, t)
      8     f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
            local name
      8     local up = 0

            repeat
      8       up = up + 1
      8       name = debug.getupvalue(f, up)
      8     until name == '_ENV' or name == nil

      8     if name then
      8       debug.upvaluejoin(f, up, function() return name end, 1)
      8       debug.setupvalue(f, up, t)
            end

      8     if f ~= 0 then return f end
          end,

          loadstring = loadstring or load,
          unpack = table.unpack or unpack,

          exit = function(code, force)
      2     if not force and code ~= 0 and _VERSION:match('^Lua 5%.[12]$') then
******0       error()
      2     elseif code ~= 0 then
      2       code = 1
            end
      2     if _VERSION == 'Lua 5.1' and
******0       (type(jit) ~= 'table' or not jit.version or jit.version_num < 20000) then
              -- From Lua 5.1 manual:
              -- > The userdata itself is freed only in the next
              -- > garbage-collection cycle.
              -- Call collectgarbage() while collectgarbage('count')
              -- changes + 3 times, at least 3 times,
              -- at max 100 times (to prevent infinite loop).
******0       local times_const = 0
******0       for i = 1, 100 do
******0         local count_before = collectgarbage("count")
******0         collectgarbage()
******0         local count_after = collectgarbage("count")
******0         if count_after == count_before then
******0           times_const = times_const + 1
******0           if times_const > 3 then
                    break
                  end
                else
******0           times_const = 0
                end
              end
            end
      2     os.exit(code, true)
          end,

          execute = require 'pl.utils'.execute,
        }

==============================================================================
/opt/homebrew/share/lua/5.4/busted/context.lua
==============================================================================
******0 local tablex = require 'pl.tablex'

        local function save()
      8   local g = {}
    368   for k,_ in next, _G, nil do
    360     g[k] = rawget(_G, k)
          end
      8   return {
      8     gmt = debug.getmetatable(_G),
      8     g = g,
      8     loaded = tablex.copy(package.loaded)
      8   }
        end

        local function restore(state)
      8   setmetatable(_G, state.gmt)
    368   for k,_ in next, _G, nil do
    360     rawset(_G, k, state.g[k])
          end
    368   for k, v in next, state.g, nil do
            -- reset globals that were set to nil during the insulation block
    360     if rawget(_G, k) == nil then
******0       rawset(_G, k, v)
            end
          end
   1550   local sync = function(k) package.loaded[k] = state.loaded[k] end
    791   for k,_ in pairs(package.loaded) do sync(k) end
    767   for k,_ in pairs(state.loaded) do sync(k) end
        end

        return function()
******0   local context = {}

******0   local data = { descriptor = 'suite', attributes = {} }
******0   local parents = {}
******0   local children = {}
******0   local stack = {}
******0   local states = {}

******0   function context.ref()
******0     local ref = {}
******0     local ctx = data

            local function unwrap(element, levels)
   2254       local levels = levels or 1
   2254       local parent = element
   4508       for i = 1, levels do
   2254         parent = ref.parent(parent)
   2254         if not parent then break end
              end
   2254       if not element.env then element.env = {} end
   4508       setmetatable(element.env, {
                __newindex = function(self, key, value)
******0           if not parent then
******0             _G[key] = value
                  else
******0             if not parent.env then parent.env = {} end
******0             parent.env[key] = value
                  end
                end
              })
            end

            local function push_state(current)
   3505       local state = false
   3505       if current.attributes.envmode == 'insulate' then
      8         state = save()
   3497       elseif current.attributes.envmode == 'unwrap' then
   2254         unwrap(current)
   1243       elseif current.attributes.envmode == 'expose' then
******0         unwrap(current, 2)
              end
   3505       table.insert(states, state)
            end

            local function pop_state(current)
   3505       local state = table.remove(states)
   3505       if current.attributes.envmode == 'expose' then
******0         states[#states] = states[#states] and save()
              end
   3505       if state then
      8         restore(state)
              end
            end

******0     function ref.get(key)
  68416       if not key then return ctx end
******0       return ctx[key]
            end

******0     function ref.set(key, value)
******0       ctx[key] = value
            end

******0     function ref.clear()
******0       data = { descriptor = 'suite', attributes = {} }
******0       parents = {}
******0       children = {}
******0       stack = {}
******0       states = {}
******0       ctx = data
            end

******0     function ref.attach(child)
   1307       if not children[ctx] then children[ctx] = {} end
   1307       parents[child] = ctx
   1307       table.insert(children[ctx], child)
            end

******0     function ref.children(parent)
    172       return children[parent] or {}
            end

******0     function ref.parent(child)
 160682       return parents[child]
            end

******0     function ref.push(current)
   7270       if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
   7270       if ctx ~= current then push_state(current) end
   7270       table.insert(stack, ctx)
   7270       ctx = current
            end

******0     function ref.pop()
   7270       local current = ctx
   7270       ctx = table.remove(stack)
   7270       if ctx ~= current then pop_state(current) end
   7270       if not ctx then error('Context stack empty. Cannot pop.') end
            end

******0     return ref
          end

******0   return context
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/core.lua
==============================================================================
******0 local getfenv = require 'busted.compatibility'.getfenv
******0 local setfenv = require 'busted.compatibility'.setfenv
******0 local unpack = require 'busted.compatibility'.unpack
******0 local throw = error

******0 local failureMt = {
          __index = {},
     24   __tostring = function(e) return tostring(e.message) end,
******0   __type = 'failure'
        }

******0 local failureMtNoString = {
          __index = {},
******0   __type = 'failure'
        }

******0 local pendingMt = {
          __index = {},
          __tostring = function(p) return p.message end,
******0   __type = 'pending'
        }

        local function errortype(obj)
     18   local mt = debug.getmetatable(obj)
     18   if mt == failureMt or mt == failureMtNoString then
     12     return 'failure'
      6   elseif mt == pendingMt then
******0     return 'pending'
          end
      6   return 'error'
        end

        local function hasToString(obj)
     30   return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
        end

        local function isCallable(obj)
      8   return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
        end

        return function()
******0   local mediator = require 'mediator'()
******0   local path = require 'pl.path'
******0   local pretty = require 'pl.pretty'
******0   local system = require 'system'

******0   local busted = {}
******0   busted.version = '2.3.0'

******0   local root = require 'busted.context'()
******0   busted.context = root.ref()

******0   local environment = require 'busted.environment'(busted.context)

******0   busted.api = {}
******0   busted.executors = {}
******0   local executors = {}
******0   local eattributes = {}

******0   busted.gettime = system.gettime
******0   busted.monotime = system.monotime
******0   busted.sleep = system.sleep
******0   busted.status = require 'busted.status'

******0   function busted.getTrace(element, level, msg)
            local function trimTrace(info)
******0       local index = info.traceback:find('\n%s*%[C]')
******0       info.traceback = info.traceback:sub(1, index)
******0       return info
            end
   1317     level = level or  3

   1317     local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
   1317     local info = debug.getinfo(level, 'Sl')
   1353     while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
   1329           (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
     36       level = level + 1
     36       info = debug.getinfo(level, 'Sl')
            end

   1317     info.traceback = debug.traceback('', level)
   1317     info.message = tostring(msg)

   1317     local file = busted.getFile(element)
   1317     return file and file.getTrace(file.name, info) or trimTrace(info)
          end

******0   function busted.rewriteMessage(element, message, trace)
     18     local file = busted.getFile(element)
     18     local msg = hasToString(message) and tostring(message)
     18     msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
     18     msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)

     18     local hasFileLine = msg:match('^[^\n]-:%d+: .*')
     18     if not hasFileLine then
******0       local trace = trace or busted.getTrace(element, 3, message)
******0       local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
******0       msg = fileline .. msg
            end

     18     return msg
          end

******0   function busted.publish(...)
   3845     return mediator:publish(...)
          end

******0   function busted.subscribe(...)
    204     return mediator:subscribe(...)
          end

******0   function busted.unsubscribe(...)
******0     return mediator:removeSubscriber(...)
          end

******0   function busted.getFile(element)
   1335     local parent = busted.context.parent(element)

   3115     while parent do
   3115       if parent.file then
      8         local file = parent.file[1]
      8         return {
      8           name = file.name,
      8           getTrace = file.run.getTrace,
      8           rewriteMessage = file.run.rewriteMessage
      8         }
              end

   3107       if parent.descriptor == 'file' then
   1327         return {
   1327           name = parent.name,
   1327           getTrace = parent.run.getTrace,
   1327           rewriteMessage = parent.run.rewriteMessage
   1327         }
              end

   1780       parent = busted.context.parent(parent)
            end

******0     return parent
          end

******0   function busted.fail(msg, level)
     12     local rawlevel = (type(level) ~= 'number' or level <= 0) and level
     12     local level = level or 1
     12     local _, emsg = pcall(throw, msg, rawlevel or level+2)
     12     local e = { message = emsg }
     12     setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
     12     throw(e, rawlevel or level+1)
          end

******0   function busted.pending(msg)
******0     local p = { message = msg }
******0     setmetatable(p, pendingMt)
******0     throw(p)
          end

******0   function busted.bindfenv(callable, var, value)
******0     local env = {}
******0     local f = (debug.getmetatable(callable) or {}).__call or callable
******0     setmetatable(env, { __index = getfenv(f) })
******0     env[var] = value
******0     setfenv(f, env)
          end

******0   function busted.wrap(callable)
      8     if isCallable(callable) then
              -- prioritize __call if it exists, like in files
      8       environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
            end
          end

******0   function busted.safe(descriptor, run, element)
   7270     busted.context.push(element)
            local trace, message
   7270     local status = 'success'

  14540     local ret = { xpcall(run, function(msg)
     18       status = errortype(msg)
     18       trace = busted.getTrace(element, 3, msg)
     18       message = busted.rewriteMessage(element, msg, trace)
  14558     end) }

   7270     if not ret[1] then
     18       if status == 'success' then
******0         status = 'error'
******0         trace = busted.getTrace(element, 3, ret[2])
******0         message = busted.rewriteMessage(element, ret[2], trace)
     18       elseif status == 'failure' and descriptor ~= 'it' then
                -- Only 'it' blocks can generate test failures. Failures in all
                -- other blocks are errors outside the test.
******0         status = 'error'
              end
              -- Note: descriptor may be different from element.descriptor when
              -- safe_publish is used (i.e. for test start/end). The safe_publish
              -- descriptor needs to be different for 'it' blocks so that we can
              -- detect that a 'failure' in a test start/end handler is not really
              -- a test failure, but rather an error outside the test, much like a
              -- failure in a support function (i.e. before_each/after_each or
              -- setup/teardown).
     18       busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)
            end
   7270     ret[1] = busted.status(status)

   7270     busted.context.pop()
   7270     return unpack(ret)
          end

******0   function busted.safe_publish(descriptor, channel, element, ...)
   2514     local args = {...}
   2514     local n = select('#', ...)
   2514     if channel[2] == 'start' then
   1257       element.starttick = busted.monotime()
   1257       element.starttime = busted.gettime()
   1257     elseif channel[2] == 'end' then
   1257       element.endtime = busted.gettime()
   1257       element.endtick = busted.monotime()
   1257       element.duration = element.starttick and (element.endtick - element.starttick)
            end
   5028     local status = busted.safe(descriptor, function()
   2514       busted.publish(channel, element, unpack(args, 1, n))
   5028     end, element)
   2514     return status:success()
          end

******0   function busted.exportApi(key, value)
******0     busted.api[key] = value
          end

******0   function busted.export(key, value)
******0     busted.exportApi(key, value)
******0     environment.set(key, value)
          end

******0   function busted.hide(key, value)
******0     busted.api[key] = nil
******0     environment.set(key, nil)
          end

******0   function busted.register(descriptor, executor, attributes)
            local alias = nil
******0     if type(executor) == 'string' then
******0       alias = descriptor
******0       descriptor = executor
******0       executor = executors[descriptor]
******0       attributes = attributes or eattributes[descriptor]
******0       executors[alias] = executor
******0       eattributes[alias] = attributes
            else
******0       if executor ~= nil and not isCallable(executor) then
******0         attributes = executor
******0         executor = nil
              end
******0       executors[descriptor] = executor
******0       eattributes[descriptor] = attributes
            end

            local publisher = function(name, fn)
   1307       if not fn and type(name) == 'function' then
     56         fn = name
     56         name = alias
   1251       elseif not fn then
******0         fn = attributes and attributes.default_fn
              end

              local trace

   1307       local ctx = busted.context.get()
   1307       if busted.context.parent(ctx) then
   1299         trace = busted.getTrace(ctx, 3, name)
              end

              local publish = function(f)
   1307         busted.publish({ 'register', descriptor }, name, f, trace, attributes)
              end

   1307       if fn then publish(fn) else return publish end
            end

******0     local edescriptor = alias or descriptor
******0     busted.executors[edescriptor] = publisher
******0     busted.export(edescriptor, publisher)

******0     busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
   1307       local ctx = busted.context.get()
   1307       local plugin = {
   1307         descriptor = descriptor,
   1307         attributes = attributes or {},
   1307         name = name,
   1307         run = fn,
   1307         trace = trace,
   1307         starttick = nil,
   1307         endtick = nil,
   1307         starttime = nil,
   1307         endtime = nil,
   1307         duration = nil,
              }

   1307       busted.context.attach(plugin)

   1307       if not ctx[descriptor] then
    234         ctx[descriptor] = { plugin }
              else
   1073         ctx[descriptor][#ctx[descriptor]+1] = plugin
              end
            end)
          end

******0   function busted.execute(current)
    166     if not current then current = busted.context.get() end
   1473     for _, v in pairs(busted.context.children(current)) do
   1307       local executor = executors[v.descriptor]
   1307       if executor and not busted.skipAll then
   2502         busted.safe(v.descriptor, function() executor(v) end, v)
              end
            end
          end

******0   return busted
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/environment.lua
==============================================================================
******0 local setfenv = require 'busted.compatibility'.setfenv

        return function(context)

******0   local environment = {}

          local function getEnv(self, key)
 196298     if not self then return nil end
******0     return
 184970       self.env and self.env[key] or
 131605       getEnv(context.parent(self), key) or
 184970       _G[key]
          end

          local function setEnv(self, key, value)
******0     if not self.env then self.env = {} end
******0     self.env[key] = value
          end

          local function __index(self, key)
  64693     return getEnv(context.get(), key)
          end

          local function __newindex(self, key, value)
******0     setEnv(context.get(), key, value)
          end

******0   local env = setmetatable({}, { __index=__index, __newindex=__newindex })

******0   function environment.wrap(fn)
      8     return setfenv(fn, env)
          end

******0   function environment.set(key, value)
******0     local env = context.get('env')

******0     if not env then
******0       env = {}
******0       context.set('env', env)
            end

******0     env[key] = value
          end
******0   return environment
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/execute.lua
==============================================================================
      6 local shuffle = require 'busted.utils'.shuffle
      6 local urandom = require 'busted.utils'.urandom
      6 local tablex = require 'pl.tablex'

        local function sort(elements)
******0   table.sort(elements, function(t1, t2)
******0     if t1.name and t2.name then
******0       return t1.name < t2.name
            end
******0     return t2.name ~= nil
          end)
******0   return elements
        end

        return function(busted)
      6   local block = require 'busted.block'(busted)

          local function execute(runs, options)
      6     local root = busted.context.get()
      6     local children = tablex.copy(busted.context.children(root))

            local function suite_reset()
******0       local oldctx = busted.context.get()

******0       busted.context.clear()
******0       local ctx = busted.context.get()
******0       for k, v in pairs(oldctx) do
******0         ctx[k] = v
              end

******0       for _, child in ipairs(children) do
******0         for descriptor, _ in pairs(busted.executors) do
******0           child[descriptor] = nil
                end
******0         busted.context.attach(child)
              end

******0       busted.randomseed = tonumber(options.seed) or urandom() or os.time()
            end

     12     for i = 1, runs do
      6       if i > 1 then
******0         suite_reset()
******0         root = busted.context.get()
******0         busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)
              end

      6       if options.sort then
******0         sort(busted.context.children(root))
      6       elseif options.shuffle then
******0         root.randomseed = busted.randomseed
******0         shuffle(busted.context.children(root), busted.randomseed)
              end

      6       local seed = (busted.randomize and busted.randomseed or nil)
      6       if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
      6         if block.setup(root) then
      6           busted.execute()
                end
      6         block.lazyTeardown(root)
      6         block.teardown(root)
              end
      6       busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)

      6       if busted.skipAll then
                break
              end
            end
          end

      6   return execute
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/init.lua
==============================================================================
        local function init(busted)
******0   local block = require 'busted.block'(busted)

          local file = function(file)
      8     busted.wrap(file.run)
      8     if busted.safe_publish('file', { 'file', 'start' }, file) then
      8       block.execute('file', file)
            end
      8     busted.safe_publish('file', { 'file', 'end' }, file)
          end

          local describe = function(describe)
    152     local parent = busted.context.parent(describe)
    152     if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
    152       block.execute('describe', describe)
            end
    152     busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
          end

          local it = function(element)
   1091     local parent = busted.context.parent(element)
            local finally

   1091     if not block.lazySetup(parent) then
              -- skip test if any setup failed
******0       return
            end

   1091     if not element.env then element.env = {} end

   1091     block.rejectAll(element)
   1091     element.env.finally = function(fn) finally = fn end
   1091     element.env.pending = busted.pending

   1091     local pass, ancestor = block.execAll('before_each', parent, true)

   1091     if pass then
   1091       local status = busted.status('success')
   1091       if busted.safe_publish('test', { 'test', 'start' }, element, parent) then
   1091         status:update(busted.safe('it', element.run, element))
   1091         if finally then
******0           block.reject('pending', element)
******0           status:update(busted.safe('finally', finally, element))
                end
              else
******0         status = busted.status('error')
              end
   1091       busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))
            end

   1091     block.dexecAll('after_each', ancestor, true)
          end

          local pending = function(element)
******0     local parent = busted.context.parent(element)
******0     local status = 'pending'
******0     if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
******0       status = 'error'
            end
******0     busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
          end

******0   busted.register('file', file, { envmode = 'insulate' })

******0   busted.register('describe', describe)
******0   busted.register('insulate', 'describe', { envmode = 'insulate' })
******0   busted.register('expose', 'describe', { envmode = 'expose' })

******0   busted.register('it', it)

******0   busted.register('pending', pending, { default_fn = function() end })

******0   busted.register('before_each', { envmode = 'unwrap' })
******0   busted.register('after_each', { envmode = 'unwrap' })

******0   busted.register('lazy_setup', { envmode = 'unwrap' })
******0   busted.register('lazy_teardown', { envmode = 'unwrap' })
******0   busted.register('strict_setup', { envmode = 'unwrap' })
******0   busted.register('strict_teardown', { envmode = 'unwrap' })

******0   busted.register('setup', 'strict_setup')
******0   busted.register('teardown', 'strict_teardown')

******0   busted.register('context', 'describe')
******0   busted.register('spec', 'it')
******0   busted.register('test', 'it')

******0   busted.hide('file')

******0   local assert = require 'luassert'
******0   local spy = require 'luassert.spy'
******0   local mock = require 'luassert.mock'
******0   local stub = require 'luassert.stub'
******0   local match = require 'luassert.match'

          require 'busted.fixtures'  -- just load into the environment, not exposing it

******0   busted.export('assert', assert)
******0   busted.export('spy', spy)
******0   busted.export('mock', mock)
******0   busted.export('stub', stub)
******0   busted.export('match', match)

******0   busted.exportApi('publish', busted.publish)
******0   busted.exportApi('subscribe', busted.subscribe)
******0   busted.exportApi('unsubscribe', busted.unsubscribe)

******0   busted.exportApi('bindfenv', busted.bindfenv)
******0   busted.exportApi('fail', busted.fail)
******0   busted.exportApi('gettime', busted.gettime)
******0   busted.exportApi('monotime', busted.monotime)
******0   busted.exportApi('sleep', busted.sleep)
******0   busted.exportApi('parent', busted.context.parent)
******0   busted.exportApi('children', busted.context.children)
******0   busted.exportApi('version', busted.version)

******0   busted.bindfenv(assert, 'error', busted.fail)
******0   busted.bindfenv(assert.is_true, 'error', busted.fail)

******0   return busted
        end

******0 return setmetatable({}, {
          __call = function(self, busted)
******0     init(busted)

******0     return setmetatable(self, {
              __index = function(self, key)
   3794         return busted.api[key]
              end,

              __newindex = function(self, key, value)
******0         error('Attempt to modify busted')
              end
            })
          end
        })

==============================================================================
/opt/homebrew/share/lua/5.4/busted/languages/en.lua
==============================================================================
      6 local s = require('say')

      6 s:set_namespace('en')

        -- 'Pending: test.lua @ 12 \n description
      6 s:set('output.pending', 'Pending')
      6 s:set('output.failure', 'Failure')
      6 s:set('output.error', 'Error')
      6 s:set('output.success', 'Success')

      6 s:set('output.pending_plural', 'pending')
      6 s:set('output.failure_plural', 'failures')
      6 s:set('output.error_plural', 'errors')
      6 s:set('output.success_plural', 'successes')

      6 s:set('output.pending_zero', 'pending')
      6 s:set('output.failure_zero', 'failures')
      6 s:set('output.error_zero', 'errors')
      6 s:set('output.success_zero', 'successes')

      6 s:set('output.pending_single', 'pending')
      6 s:set('output.failure_single', 'failure')
      6 s:set('output.error_single', 'error')
      6 s:set('output.success_single', 'success')

      6 s:set('output.seconds', 'seconds')

      6 s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
      6 s:set('output.file_not_found', 'Cannot find file or directory: %s')

        -- definitions following are not used within the 'say' namespace
      6 return {
      6   failure_messages = {
      6     'You have %d busted specs',
      6     'Your specs are busted',
      6     'Your code is bad and you should feel bad',
      6     'Your code is in the Danger Zone',
      6     'Strange game. The only way to win is not to test',
      6     'My grandmother wrote better specs on a 3 86',
      6     'Every time there\'s a failure, drink another beer',
            'Feels bad man'
      6   },
      6   success_messages = {
      6     'Aww yeah, passing specs',
      6     'Doesn\'t matter, had specs',
      6     'Feels good, man',
      6     'Great success',
            'Tests pass, drink another beer',
      6   }
      6 }

==============================================================================
/opt/homebrew/share/lua/5.4/busted/luajit.lua
==============================================================================
      6 local isJit = (tostring(assert):match('builtin') ~= nil)

      6 if not isJit then
     12   return function() end
        end

        -- pre-load the ffi module, such that it becomes part of the environment
        -- and Busted will not try to GC and reload it. The ffi is not suited
        -- for that and will occasionally segfault if done so.
******0 local ffi = require "ffi"


        -- patching assumes;
        --  * first parameter to be a unique key to identify repeated calls
        --  * only a single return value

        local function patch_with_return_value(func_name)
******0   local original = ffi[func_name]
******0   local original_store = {}

          ffi[func_name] = function (primary, ...)
******0     if original_store[primary] then
******0       return original_store[primary]
            end
******0     local success, result, err = pcall(original, primary, ...)
******0     if not success then
              -- hard error was thrown
******0       error(result, 2)
            end
******0     if not result then
              -- soft error was returned
******0       return result, err
            end
            -- it worked, store and return
******0     original_store[primary] = result
******0     return result
          end
        end

        local function patch_without_return_value(func_name)
******0   local original = ffi[func_name]
******0   local original_store = {}

          ffi[func_name] = function (primary, ...)
******0     if original_store[primary] then
******0       return
            end
******0     local success, result = pcall(original, primary, ...)
******0     if not success then
              -- hard error was thrown
******0       error(result, 2)
            end
            -- store and return
******0     original_store[primary] = true
******0     return result
          end
        end

        return function()
******0     patch_without_return_value("cdef")
******0     patch_with_return_value("typeof")
******0     patch_with_return_value("metatype")
******0     patch_with_return_value("load")
          end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/modules/files/lua.lua
==============================================================================
      6 local path = require 'pl.path'

      6 local ret = {}

        local getTrace = function(filename, info)
   1317   local index = info.traceback:find('\n%s*%[C]')
   1317   info.traceback = info.traceback:sub(1, index)
   1317   return info
        end

        ret.match = function(busted, filename)
      8   return path.extension(filename) == '.lua'
        end

        ret.load = function(busted, filename)
      8   local file, err = loadfile(filename)
      8   if not file then
******0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
          end
      8   return file, getTrace
        end

      6 return ret

==============================================================================
/opt/homebrew/share/lua/5.4/busted/modules/files/moonscript.lua
==============================================================================
      6 local path = require 'pl.path'

     12 local ok, moonscript, line_tables, util = pcall(function()
      6   return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
        end)

      6 local _cache = {}

        -- find the line number of `pos` chars into fname
        local lookup_line = function(fname, pos)
******0   if not _cache[fname] then
******0     local f = io.open(fname)
******0     _cache[fname] = f:read('*a')
******0     f:close()
          end

******0   return util.pos_to_line(_cache[fname], pos)
        end

        local rewrite_linenumber = function(fname, lineno)
******0   local tbl = line_tables['@' .. fname]
******0   if fname and tbl then
******0     for i = lineno, 0 ,-1 do
******0       if tbl[i] then
******0         return lookup_line(fname, tbl[i])
              end
            end
          end

******0   return lineno
        end

        local rewrite_filename = function(filename)
          -- sometimes moonscript gives files like [string "./filename.moon"], so
          -- we'll chop it up to only get the filename.
******0   return filename:match('string "(.+)"') or filename
        end

        local rewrite_traceback = function(fname, trace)
          local rewrite_one = function(line, pattern, sub)
******0     if line == nil then return '' end

******0     local fname, lineno = line:match(pattern)

******0     if fname and lineno then
******0       fname = rewrite_filename(fname)
******0       local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
******0       if new_lineno then
******0         line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
              end
            end

******0     return line
          end

******0   local lines = {}
******0   local j = 0

******0   for line in trace:gmatch('[^\r\n]+') do
******0     j = j + 1
******0     local newline = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
******0     newline = rewrite_one(newline, '<(.*):(%d+)>', ':%d>')
******0     lines[j] = newline
          end

******0   return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
        end

      6 local ret = {}

        local getTrace = function(filename, info)
******0   local index = info.traceback:find('\n%s*%[C]')
******0   info.traceback = info.traceback:sub(1, index)

******0   info.short_src = rewrite_filename(info.short_src)
******0   info.traceback = rewrite_traceback(filename, info.traceback)
******0   info.linedefined = rewrite_linenumber(filename, info.linedefined)
******0   info.currentline = rewrite_linenumber(filename, info.currentline)

******0   return info
        end

        local rewriteMessage = function(filename, message)
******0   local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
******0   if not fname then
******0     return message
          end

******0   fname = rewrite_filename(fname)
******0   line = rewrite_linenumber(fname, tonumber(line))

******0   return fname .. ':' .. tostring(line) .. ': ' .. msg
        end

        ret.match = function(busted, filename)
******0   return ok and path.extension(filename) == '.moon'
        end

        ret.load = function(busted, filename)
******0   local file, err = moonscript.loadfile(filename)
******0   if not file then
******0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
          end
******0   return file, getTrace, rewriteMessage
        end

      6 return ret

==============================================================================
/opt/homebrew/share/lua/5.4/busted/modules/filter_loader.lua
==============================================================================
        return function()
          local function filter(busted, options)
            local getFullName = function(name)
   1091       local parent = busted.context.get()
   1091       local names = { name }

   3692       while parent and (parent.name or parent.descriptor) and
   3692             parent.descriptor ~= 'file' do
   2601         table.insert(names, 1, parent.name or parent.descriptor)
   2601         parent = busted.context.parent(parent)
              end

   1091       return table.concat(names, ' ')
            end

            local hasTag = function(name, tag)
******0       local found = name:find('#' .. tag)
******0       return (found ~= nil)
            end

            local filterExcludeTags = function(name)
   1243       for i, tag in pairs(options.excludeTags) do
******0         if hasTag(name, tag) then
******0           return nil, false
                end
              end
   1243       return nil, true
            end

            local filterTags = function(name)
   1091       local fullname = getFullName(name)
   1091       for i, tag in pairs(options.tags) do
******0         if hasTag(fullname, tag) then
******0           return nil, true
                end
              end
   1091       return nil, (#options.tags == 0)
            end

            local filterOutNames = function(name)
   1243       for _, filter in pairs(options.filterOut) do
******0         if getFullName(name):find(filter) ~= nil then
******0           return nil, false
                end
              end
   1243       return nil, true
            end

      6     local excludeNames = {}
      6     if options.excludeNamesFile then
******0       for name in io.lines(options.excludeNamesFile) do
******0         table.insert(excludeNames, name)
              end
            end

            local excludeNamesFile = function(name)
******0       for _, filter in ipairs(excludeNames) do
******0         if getFullName(name) == filter then
******0           return nil, false
                end
              end
******0       return nil, true
            end

            local name = function(name)
   1243       for _, candidate in pairs(options.name) do
******0         if string.find(candidate, getFullName(name), 1, true) then
******0           return nil, true
                end
              end
   1243       return nil, (#options.name == 0)
            end

            local filterNames = function(name)
   1091       for _, filter in pairs(options.filter) do
******0         if getFullName(name):find(filter) ~= nil then
******0           return nil, true
                end
              end
   1091       return nil, (#options.filter == 0)
            end

            local printTestName = function(element, parent, status)
******0       if not (options.suppressPending and status == 'pending') then
******0         local fullname = getFullName()
******0         local trace = element.trace
******0         if trace and trace.what == 'Lua' then
******0           fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname
                end
******0         print(fullname)
              end
******0       return nil, false
            end

            local ignoreAll = function()
******0       return nil, false
            end

      6     local noop = function() end
            local stubOut = function(descriptor, name, fn, ...)
******0       if fn == noop then
******0         return nil, true
              end
******0       busted.publish({ 'register', descriptor }, name, noop, ...)
******0       return nil, false
            end

            local skipOnError = function()
******0       return nil, not busted.skipAll
            end

            local applyFilter = function(descriptors, name, fn)
     60       if options[name] and options[name] ~= '' then
    108         for _, descriptor in ipairs(descriptors) do
     78           busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
                end
              end
            end

            local applyDescFilter = function(descriptors, name, fn)
******0       if options[name] and options[name] ~= '' then
******0         for _, descriptor in ipairs(descriptors) do
******0           local f = function(...) return fn(descriptor, ...) end
******0           busted.subscribe({ 'register', descriptor }, f, { priority = 1 })
                end
              end
            end

      6     if options.list then
******0       busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })
******0       busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })
******0       applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)
******0       applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)
******0       applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)
******0       applyDescFilter({ 'it', 'pending' }, 'list', stubOut)
            end

      6     applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
      6     applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
      6     applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
      6     applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)

            -- The following filters are applied in reverse order
      6     applyFilter({ 'it', 'pending' }            , 'filter'          , filterNames           )
      6     applyFilter({ 'describe', 'it', 'pending' }, 'name'            , name                  )
      6     applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'       , filterOutNames        )
      6     applyFilter({ 'describe', 'it', 'pending' }, 'excludeNamesFile', excludeNamesFile      )
      6     applyFilter({ 'it', 'pending' }            , 'tags'            , filterTags            )
      6     applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags'     , filterExcludeTags     )
          end

******0   return filter
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/modules/helper_loader.lua
==============================================================================
******0 local path = require 'pl.path'
******0 local hasMoon, moonscript = pcall(require, 'moonscript')
******0 local utils = require 'busted.utils'

        return function()
          local loadHelper = function(busted, helper, options)
      6     local old_arg = _G.arg
     12     local success, err = pcall(function()
              local fn

      6       utils.copy_interpreter_args(options.arguments)
      6       _G.arg = options.arguments

      6       if helper:match('%.lua$') then
      6         fn = dofile(path.normpath(helper))
******0       elseif hasMoon and helper:match('%.moon$') then
******0         fn = moonscript.dofile(path.normpath(helper))
              else
******0         fn = require(helper)
              end

      6       if type(fn) == 'function' then
******0         assert(fn(busted, helper, options))
              end
            end)

      6     arg = old_arg   --luacheck: ignore

      6     if not success then
******0       return nil, err
            end
      6     return true
          end

******0   return loadHelper
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/modules/output_handler_loader.lua
==============================================================================
******0 local path = require 'pl.path'
******0 local hasMoon, moonscript = pcall(require, 'moonscript')
******0 local utils = require 'busted.utils'

        return function()
          local loadOutputHandler = function(busted, output, options)
            local handler

      6     utils.copy_interpreter_args(options.arguments)
     12     local success, err = pcall(function()
      6       if output:match('%.lua$') then
******0         handler = dofile(path.normpath(output))
      6       elseif hasMoon and output:match('%.moon$') then
******0         handler = moonscript.dofile(path.normpath(output))
              else
      6         handler = require('busted.outputHandlers.' .. output)
              end
            end)

      6     if not success and err:match("module '.-' not found:") then
******0       success, err = pcall(function() handler = require(output) end)
            end

      6     if not success then
******0       busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
******0       handler = require('busted.outputHandlers.' .. options.defaultOutput)
            end

      6     if options.enableSound then
******0       require 'busted.outputHandlers.sound'(options)
            end

      6     handler(options):subscribe(options)
          end

******0   return loadOutputHandler
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/modules/test_file_loader.lua
==============================================================================
      6 local s = require 'say'

        return function(busted, loaders)
      6   local path = require 'pl.path'
      6   local dir = require 'pl.dir'
      6   local tablex = require 'pl.tablex'
      6   local fileLoaders = {}

     18   for _, v in pairs(loaders) do
     12     local loader = require('busted.modules.files.'..v)
     12     fileLoaders[#fileLoaders+1] = loader
          end

          local getTestFiles = function(rootFile, patterns, options)
            local fileList

      6     if path.isfile(rootFile) then
      1       fileList = { rootFile }
      5     elseif path.isdir(rootFile) then
      5       local getfiles = options.recursive and dir.getallfiles or dir.getfiles
      5       fileList = getfiles(rootFile)

     10       fileList = tablex.filter(fileList, function(filename)
    495         local basename = path.basename(filename)
    689         for _, patt in ipairs(options.excludes) do
    198           if patt ~= '' and basename:find(patt) then
      4             return nil
                  end
                end
    975         for _, patt in ipairs(patterns) do
    491           if basename:find(patt) then
      7             return true
                  end
                end
    484         return #patterns == 0
              end)

     10       fileList = tablex.filter(fileList, function(filename)
      7         if path.is_windows then
******0           return not filename:find('%\\%.%w+.%w+', #rootFile)
                else
      7           return not filename:find('/%.%w+.%w+', #rootFile)
                end
              end)
            else
******0       busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})
******0       fileList = {}
            end

      6     table.sort(fileList)
      6     return fileList
          end

          local getAllTestFiles = function(rootFiles, patterns, options)
      6     local fileList = {}
     12     for _, root in ipairs(rootFiles) do
      6       tablex.insertvalues(fileList, getTestFiles(root, patterns, options))
            end
      6     return fileList
          end

          -- runs a testfile, loading its tests
          local loadTestFile = function(busted, filename)
      8     for _, v in pairs(fileLoaders) do
      8       if v.match(busted, filename) then
      8         return v.load(busted, filename)
              end
            end
          end

          local loadTestFiles = function(rootFiles, patterns, options)
      6     local fileList = getAllTestFiles(rootFiles, patterns, options)

     14     for i, fileName in ipairs(fileList) do
      8       local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)

      8       if testFile then
     16         local file = setmetatable({
      8           getTrace = getTrace,
      8           rewriteMessage = rewriteMessage
      8         }, {
      8           __call = testFile
                })

      8         busted.executors.file(fileName, file)
              end
            end

      6     if #fileList == 0 then
******0       local pattern = patterns[1]
******0       if #patterns > 1 then
******0         pattern = '\n\t' .. table.concat(patterns, '\n\t')
              end
******0       busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
            end

      6     return fileList
          end

      6   return loadTestFiles, loadTestFile, getAllTestFiles
        end


==============================================================================
/opt/homebrew/share/lua/5.4/busted/outputHandlers/base.lua
==============================================================================
      6 local table_concat = table.concat
      6 local table_insert = table.insert

        return function()
      6   local busted = require 'busted'
      6   local handler = {
      6     successes = {},
      6     successesCount = 0,
      6     pendings = {},
      6     pendingsCount = 0,
      6     failures = {},
      6     failuresCount = 0,
      6     errors = {},
      6     errorsCount = 0,
      6     inProgress = {}
          }

          handler.cancelOnPending = function(element, parent, status)
   3273     return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
          end

          handler.subscribe = function(handler, options)
      6     require('busted.languages.en')
      6     handler.options = options

      6     if options.language ~= 'en' then
******0       require('busted.languages.' .. options.language)
            end

      6     busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
      6     busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
      6     busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
      6     busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
      6     busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
      6     busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
      6     busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
      6     busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
      6     busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
      6     busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
          end

          handler.getFullName = function(context)
   1091     local parent = busted.parent(context)
   1091     local names = { (context.name or context.descriptor) }

   3692     while parent and (parent.name or parent.descriptor) and
   3692           parent.descriptor ~= 'file' do

   2601       table_insert(names, 1, parent.name or parent.descriptor)
   2601       parent = busted.parent(parent)
            end

   1091     return table_concat(names, ' ')
          end

          handler.format = function(element, parent, message, debug, isError)
            local function copyElement(e)
   1091       local copy = {}
  13038       for k,v in next, e do
  11947         if type(v) ~= 'function' and k ~= 'env' then
   9765           copy[k] = v
                end
              end
   1091       return copy
            end

   1091     local formatted = {
   1091       trace = debug or element.trace,
   1091       element = copyElement(element),
   1091       name = handler.getFullName(element),
   1091       message = message,
   1091       randomseed = parent and parent.randomseed,
   1091       isError = isError
            }
   1091     formatted.element.trace = element.trace or debug

   1091     return formatted
          end

          handler.getDuration = function()
      6     if not handler.endTick or not handler.startTick then
******0       return 0
            end

      6     return handler.endTick - handler.startTick
          end

          handler.baseSuiteStart = function(suite)
      6     handler.startTick = suite.starttick
      6     handler.startTime = suite.starttime
      6     return nil, true
          end

          handler.baseSuiteReset = function()
******0     handler.successes = {}
******0     handler.successesCount = 0
******0     handler.pendings = {}
******0     handler.pendingsCount = 0
******0     handler.failures = {}
******0     handler.failuresCount = 0
******0     handler.errors = {}
******0     handler.errorsCount = 0
******0     handler.inProgress = {}

******0     return nil, true
          end

          handler.baseSuiteEnd = function(suite)
      6     handler.endTick = suite.endtick
      6     handler.endTime = suite.endtime
      6     return nil, true
          end

          handler.baseTestStart = function(element, parent)
   1091     handler.inProgress[tostring(element)] = {}
   1091     return nil, true
          end

          handler.baseTestEnd = function(element, parent, status, debug)
            local insertTable

   1091     if status == 'success' then
   1073       insertTable = handler.successes
   1073       handler.successesCount = handler.successesCount + 1
     18     elseif status == 'pending' then
******0       insertTable = handler.pendings
******0       handler.pendingsCount = handler.pendingsCount + 1
     18     elseif status == 'failure' then
              -- failure already saved in failure handler
     12       handler.failuresCount = handler.failuresCount + 1
     12       return nil, true
      6     elseif status == 'error' then
              -- error count already incremented and saved in error handler
      6       return nil, true
            end

   1073     local formatted = handler.format(element, parent, element.message, debug)

   1073     local id = tostring(element)
   1073     if handler.inProgress[id] then
   1073       for k, v in pairs(handler.inProgress[id]) do
******0         formatted[k] = v
              end

   1073       handler.inProgress[id] = nil
            end

   1073     table_insert(insertTable, formatted)

   1073     return nil, true
          end

          handler.basePending = function(element, parent, message, debug)
******0     local id = tostring(element)
******0     handler.inProgress[id].message = message
******0     handler.inProgress[id].trace = debug
******0     return nil, true
          end

          handler.baseTestFailure = function(element, parent, message, debug)
     12     table_insert(handler.failures, handler.format(element, parent, message, debug))
     12     return nil, true
          end

          handler.baseTestError = function(element, parent, message, debug)
      6     handler.errorsCount = handler.errorsCount + 1
      6     table_insert(handler.errors, handler.format(element, parent, message, debug, true))
      6     return nil, true
          end

          handler.baseError = function(element, parent, message, debug)
     18     if element.descriptor ~= 'it' then
******0       handler.errorsCount = handler.errorsCount + 1
******0       table_insert(handler.errors, handler.format(element, parent, message, debug, true))
            end

     18     return nil, true
          end

      6   return handler
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/outputHandlers/plainTerminal.lua
==============================================================================
      6 local s = require 'say'
      6 local pretty = require 'pl.pretty'
      6 local io = io
      6 local type = type
      6 local string_format = string.format
      6 local string_gsub = string.gsub
      6 local io_write = io.write
      6 local io_flush = io.flush
      6 local pairs = pairs

        return function(options)
      6   local busted = require 'busted'
      6   local handler = require 'busted.outputHandlers.base'()

      6   local successDot =  '+'
      6   local failureDot =  '-'
      6   local errorDot =  '*'
      6   local pendingDot = '.'

          local pendingDescription = function(pending)
******0     local name = pending.name

******0     local string = s('output.pending') .. ' -> ' ..
******0       pending.trace.short_src .. ' @ ' ..
******0       pending.trace.currentline  ..
******0       '\n' .. name

******0     if type(pending.message) == 'string' then
******0       string = string .. '\n' .. pending.message
******0     elseif pending.message ~= nil then
******0       string = string .. '\n' .. pretty.write(pending.message)
            end

******0     return string
          end

          local failureMessage = function(failure)
     18     local string = failure.randomseed and ('Random seed: ' .. failure.randomseed .. '\n') or ''
     18     if type(failure.message) == 'string' then
     18       string = string .. failure.message
******0     elseif failure.message == nil then
******0       string = string .. 'Nil error'
            else
******0       string = string .. pretty.write(failure.message)
            end

     18     return string
          end

          local failureDescription = function(failure, isError)
     18     local string = s('output.failure') .. ' -> '
     18     if isError then
      6       string = s('output.error') .. ' -> '
            end

     18     if not failure.element.trace or not failure.element.trace.short_src then
******0       string = string ..
******0         failureMessage(failure) .. '\n' ..
                failure.name
            else
     18       string = string ..
     18         failure.element.trace.short_src .. ' @ ' ..
     18         failure.element.trace.currentline .. '\n' ..
     36         failure.name .. '\n' ..
     36         failureMessage(failure)
            end

     18     if options.verbose and failure.trace and failure.trace.traceback then
******0       string = string .. '\n' .. failure.trace.traceback
            end

     18     return string
          end

          local statusString = function()
      6     local successString = s('output.success_plural')
      6     local failureString = s('output.failure_plural')
      6     local pendingString = s('output.pending_plural')
      6     local errorString = s('output.error_plural')

      6     local sec = handler.getDuration()
      6     local successes = handler.successesCount
      6     local pendings = handler.pendingsCount
      6     local failures = handler.failuresCount
      6     local errors = handler.errorsCount

      6     if successes == 0 then
******0       successString = s('output.success_zero')
      6     elseif successes == 1 then
******0       successString = s('output.success_single')
            end

      6     if failures == 0 then
      4       failureString = s('output.failure_zero')
      2     elseif failures == 1 then
******0       failureString = s('output.failure_single')
            end

      6     if pendings == 0 then
      6       pendingString = s('output.pending_zero')
******0     elseif pendings == 1 then
******0       pendingString = s('output.pending_single')
            end

      6     if errors == 0 then
      4       errorString = s('output.error_zero')
      2     elseif errors == 1 then
******0       errorString = s('output.error_single')
            end

      6     local formattedTime = string_gsub(string_format('%.6f', sec), '([0-9])0+$', '%1')

      6     return successes .. ' ' .. successString .. ' / ' ..
      6       failures .. ' ' .. failureString .. ' / ' ..
      6       errors .. ' ' .. errorString .. ' / ' ..
      6       pendings .. ' ' .. pendingString .. ' : ' ..
      6       formattedTime .. ' ' .. s('output.seconds')
          end

          handler.testEnd = function(element, parent, status, debug)
   1091     if not options.deferPrint then
   1091       local string = successDot

   1091       if status == 'pending' then
******0         string = pendingDot
   1091       elseif status == 'failure' then
     12         string = failureDot
   1079       elseif status == 'error' then
      6         string = errorDot
              end

   1091       io_write(string)
   1091       io_flush()
            end

   1091     return nil, true
          end

          handler.suiteStart = function(suite, count, total)
      6     local runString = (total > 1 and '\nRepeating all tests (run %u of %u) . . .\n\n' or '')
      6     io_write(string_format(runString, count, total))
      6     io_flush()

      6     return nil, true
          end

          handler.suiteEnd = function()
      6     io_write('\n')
      6     io_write(statusString()..'\n')

      6     for i, pending in pairs(handler.pendings) do
******0       io_write('\n')
******0       io_write(pendingDescription(pending)..'\n')
            end

     18     for i, err in pairs(handler.failures) do
     12       io_write('\n')
     12       io_write(failureDescription(err)..'\n')
            end

     12     for i, err in pairs(handler.errors) do
      6       io_write('\n')
      6       io_write(failureDescription(err, true)..'\n')
            end

      6     return nil, true
          end

          handler.error = function(element, parent, message, debug)
******0     io_write(errorDot)
******0     io_flush()

******0     return nil, true
          end

      6   busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
      6   busted.subscribe({ 'suite', 'start' }, handler.suiteStart)
      6   busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
      6   busted.subscribe({ 'error', 'file' }, handler.error)
      6   busted.subscribe({ 'failure', 'file' }, handler.error)
      6   busted.subscribe({ 'error', 'describe' }, handler.error)
      6   busted.subscribe({ 'failure', 'describe' }, handler.error)

      6   return handler
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/runner.lua
==============================================================================
        -- Busted command-line runner

******0 local utils = require 'busted.utils'
******0 local exit = require 'busted.compatibility'.exit
******0 local loadstring = require 'busted.compatibility'.loadstring
******0 local loaded = false

        return function(options)
******0   if loaded then return function() end else loaded = true end

******0   local path = require 'pl.path'
******0   local tablex = require 'pl.tablex'
******0   local term = require 'term'

******0   local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)
******0   options = tablex.update(require 'busted.options', options or {})
******0   options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')

******0   local busted = require 'busted.core'()

******0   local cli = require 'busted.modules.cli'(options)
******0   local filterLoader = require 'busted.modules.filter_loader'()
******0   local helperLoader = require 'busted.modules.helper_loader'()
******0   local outputHandlerLoader = require 'busted.modules.output_handler_loader'()

******0   local luacov = require 'busted.modules.luacov'()

******0   require 'busted'(busted)

******0   local level = 2
******0   local info = debug.getinfo(level, 'Sf')
******0   local source = info.source
******0   local fileName = source:sub(1,1) == '@' and source:sub(2) or nil
******0   local forceExit = fileName == nil

          -- Parse the cli arguments
******0   local appName = path.basename(fileName or 'busted')
******0   cli:set_name(appName)
******0   local cliArgs, err = cli:parse(arg)
******0   if not cliArgs then
******0     io.stderr:write(err .. '\n')
******0     exit(1, forceExit)
          end

******0   if cliArgs.help then
******0     io.stdout:write(cliArgs.helpText .. '\n')
******0     exit(0, forceExit)
          end

******0   if cliArgs.version then
            -- Return early if asked for the version
******0     io.stdout:write(busted.version .. '\n')
******0     exit(0, forceExit)
          end

          -- Load current working directory
******0   local _, err = path.chdir(path.normpath(cliArgs.directory))
******0   if err then
******0     io.stderr:write(appName .. ': error: ' .. err .. '\n')
******0     exit(1, forceExit)
          end

          -- If coverage arg is passed in, load LuaCovsupport
******0   if cliArgs.coverage then
******0     local ok, err = luacov(cliArgs['coverage-config-file'])
      6     if not ok then
******0       io.stderr:write(appName .. ': error: ' .. err .. '\n')
******0       exit(1, forceExit)
            end
          end

          -- If auto-insulate is disabled, re-register file without insulation
      6   if not cliArgs['auto-insulate'] then
******0     busted.register('file', 'file', {})
          end

          -- If lazy is enabled, make lazy setup/teardown the default
      6   if cliArgs.lazy then
******0     busted.register('setup', 'lazy_setup')
******0     busted.register('teardown', 'lazy_teardown')
          end

          -- Add additional package paths based on lpath and cpath cliArgs
      6   if #cliArgs.lpath > 0 then
      6     package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
          end

      6   if #cliArgs.cpath > 0 then
      6     package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
          end

          -- Load and execute commands given on the command-line
      6   if cliArgs.e then
      6     for k,v in ipairs(cliArgs.e) do
******0       loadstring(v)()
            end
          end

          -- watch for test errors and failures
      6   local failures = 0
      6   local errors = 0
      6   local quitOnError = not cliArgs['keep-going']

     12   busted.subscribe({ 'error', 'output' }, function(element, parent, message)
******0     io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
******0     return nil, true
          end)

     12   busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
******0     io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
******0     return nil, true
          end)

     12   busted.subscribe({ 'error' }, function(element, parent, message)
      6     errors = errors + 1
      6     busted.skipAll = quitOnError
      6     return nil, true
          end)

     12   busted.subscribe({ 'failure' }, function(element, parent, message)
     12     if element.descriptor == 'it' then
     12       failures = failures + 1
            else
******0       errors = errors + 1
            end
     12     busted.skipAll = quitOnError
     12     return nil, true
          end)

          -- Set up randomization options
      6   busted.sort = cliArgs['sort-tests']
      6   busted.randomize = cliArgs['shuffle-tests']
      6   busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()

          -- Set up output handler to listen to events
     12   outputHandlerLoader(busted, cliArgs.output, {
      6     defaultOutput = options.output,
      6     enableSound = cliArgs['enable-sound'],
      6     verbose = cliArgs.verbose,
      6     suppressPending = cliArgs['suppress-pending'],
      6     language = cliArgs.lang,
      6     deferPrint = cliArgs['defer-print'],
      6     arguments = cliArgs.Xoutput,
          })

          -- Pre-load the LuaJIT 'ffi' module if applicable
      6   require 'busted.luajit'()

          -- Set up helper script, must succeed to even start tests
      6   if cliArgs.helper and cliArgs.helper ~= '' then
     12     local ok, err = helperLoader(busted, cliArgs.helper, {
      6       verbose = cliArgs.verbose,
      6       language = cliArgs.lang,
      6       arguments = cliArgs.Xhelper
            })
      6     if not ok then
******0       io.stderr:write(appName .. ': failed running the specified helper (' ..
******0                       cliArgs.helper .. '), error: ' .. err .. '\n')
******0       exit(1, forceExit)
            end
          end

          local getFullName = function(name)
******0     local parent = busted.context.get()
******0     local names = { name }

******0     while parent and (parent.name or parent.descriptor) and
******0       parent.descriptor ~= 'file' do
******0       table.insert(names, 1, parent.name or parent.descriptor)
******0       parent = busted.context.parent(parent)
            end

******0     return table.concat(names, ' ')
          end

      6   if cliArgs['log-success'] then
******0     local logFile = assert(io.open(cliArgs['log-success'], 'a'))
******0     busted.subscribe({ 'test', 'end' }, function (test, parent, status)
******0       if status == "success" then
******0         logFile:write(getFullName() .. "\n")
              end
            end)
          end

          -- Load tag and test filters
     12   filterLoader(busted, {
      6     tags = cliArgs.tags,
      6     excludeTags = cliArgs['exclude-tags'],
      6     filter = cliArgs.filter,
      6     name = cliArgs.name,
      6     filterOut = cliArgs['filter-out'],
      6     excludeNamesFile = cliArgs['exclude-names-file'],
      6     list = cliArgs.list,
      6     nokeepgoing = not cliArgs['keep-going'],
      6     suppressPending = cliArgs['suppress-pending'],
          })

      6   if cliArgs.ROOT then
            -- Load test directories/files
      6     local rootFiles = cliArgs.ROOT
      6     local patterns = cliArgs.pattern
      6     local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
     12     testFileLoader(rootFiles, patterns, {
      6       excludes = cliArgs['exclude-pattern'],
      6       verbose = cliArgs.verbose,
      6       recursive = cliArgs['recursive'],
      6     })
          else
            -- Running standalone, use standalone loader
******0     local testFileLoader = require 'busted.modules.standalone_loader'(busted)
******0     testFileLoader(info, { verbose = cliArgs.verbose })
          end

      6   local runs = cliArgs['repeat']
      6   local execute = require 'busted.execute'(busted)
     12   execute(runs, {
      6     seed = cliArgs.seed,
      6     shuffle = cliArgs['shuffle-files'],
      6     sort = cliArgs['sort-files'],
          })

      6   busted.publish({ 'exit' })

      6   if options.standalone or failures > 0 or errors > 0 then
      2     exit(failures + errors, forceExit)
          end
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/status.lua
==============================================================================
        local function get_status(status)
   9452   local smap = {
   9452     ['success'] = 'success',
   9452     ['pending'] = 'pending',
   9452     ['failure'] = 'failure',
   9452     ['error'] = 'error',
   9452     ['true'] = 'success',
   9452     ['false'] = 'failure',
   9452     ['nil'] = 'error',
          }
   9452   return smap[tostring(status)] or 'error'
        end

        return function(inital_status)
   8361   local objstat = get_status(inital_status)
   8361   local obj = {
  13289     success = function(self) return (objstat == 'success') end,
   8361     pending = function(self) return (objstat == 'pending') end,
   8361     failure = function(self) return (objstat == 'failure') end,
   8361     error   = function(self) return (objstat == 'error') end,

            get = function(self)
******0       return objstat
            end,

            set = function(self, status)
******0       objstat = get_status(status)
            end,

            update = function(self, status)
              -- prefer current failure/error status over new status
   1091       status = get_status(status)
   1091       if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
   1091         objstat = status
              end
            end
          }

  16722   return setmetatable(obj, {
   8361     __index = {},
  10543     __tostring = function(self) return objstat end
          })
        end

==============================================================================
/opt/homebrew/share/lua/5.4/busted/utils.lua
==============================================================================
******0 return {
          copy_interpreter_args = function(arguments)
            -- copy non-positive command-line args auto-inserted by Lua interpreter
     12     if arguments and _G.arg then
     12       local i = 0
     60       while _G.arg[i] do
     48         arguments[i] = _G.arg[i]
     48         i = i - 1
              end
            end
          end,

          split = require 'pl.utils'.split,

          shuffle = function(t, seed)
******0     if seed then math.randomseed(seed) end
******0     local n = #t
******0     while n >= 2 do
******0       local k = math.random(n)
******0       t[n], t[k] = t[k], t[n]
******0       n = n - 1
            end
******0     return t
          end,

          urandom = function()
      6     local f = io.open('/dev/urandom', 'rb')
      6     if not f then return nil end
      6     local s = f:read(4) f:close()
      6     local bytes = {s:byte(1, 4)}
      6     local value = 0
     30     for _, v in ipairs(bytes) do
     24       value = value * 256 + v
            end
      6     return value
          end,
        }

==============================================================================
/opt/homebrew/share/lua/5.4/luarocks/core/dir.lua
==============================================================================
******0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local package = _tl_compat and _tl_compat.package or package; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local dir = {}



******0 local dir_sep = package.config:sub(1, 1)

        local function unquote(c)
  11930    local first, last = c:sub(1, 1), c:sub(-1)
  11930    if (first == '"' and last == '"') or
  11930       (first == "'" and last == "'") then
******0       return c:sub(2, -2)
           end
  11930    return c
        end






******0 function dir.split_url(url)

   7158    url = unquote(url)
   7158    local protocol, pathname = url:match("^([^:]*)://(.*)")
   7158    if not protocol then
   7158       protocol = "file"
   7158       pathname = url
           end
   7158    return protocol, pathname
        end







******0 function dir.normalize(name)
   7158    local protocol, pathname = dir.split_url(name)
   7158    pathname = pathname:gsub("\\", "/"):gsub("(.)/*$", "%1"):gsub("//", "/")
   7158    local pieces = {}
   7158    local drive = ""
   7158    if pathname:match("^.:") then
******0       drive, pathname = pathname:match("^(.:)(.*)$")
           end
   7158    pathname = pathname .. "/"
  40562    for piece in pathname:gmatch("(.-)/") do
  33404       if piece == ".." then
******0          local prev = pieces[#pieces]
******0          if not prev or prev == ".." then
******0             table.insert(pieces, "..")
******0          elseif prev ~= "" then
******0             table.remove(pieces)
                 end
  33404       elseif piece ~= "." then
  33404          table.insert(pieces, piece)
              end
           end
   7158    if #pieces == 0 then
******0       pathname = drive .. "."
   7158    elseif #pieces == 1 and pieces[1] == "" then
******0       pathname = drive .. "/"
           else
   7158       pathname = drive .. table.concat(pieces, "/")
           end
   7158    if protocol ~= "file" then
******0       pathname = protocol .. "://" .. pathname
           else
   7158       pathname = pathname:gsub("/", dir_sep)
           end
   7158    return pathname
        end











******0 function dir.path(...)
   2386    local t = { ... }
   2386    while t[1] == "" do
******0       table.remove(t, 1)
           end
   7158    for i, c in ipairs(t) do
   4772       t[i] = unquote(c)
           end
   2386    return dir.normalize(table.concat(t, "/"))
        end

******0 return dir

==============================================================================
/opt/homebrew/share/lua/5.4/luarocks/core/manif.lua
==============================================================================
******0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local type = type

******0 local manif = {}


******0 local persist = require("luarocks.core.persist")
******0 local cfg = require("luarocks.core.cfg")
******0 local dir = require("luarocks.core.dir")
******0 local util = require("luarocks.core.util")
******0 local vers = require("luarocks.core.vers")
******0 local path = require("luarocks.core.path")














******0 local manifest_cache = {}





******0 function manif.cache_manifest(repo_url, lua_version, manifest)
******0    lua_version = lua_version or cfg.lua_version
******0    manifest_cache[repo_url] = manifest_cache[repo_url] or {}
******0    manifest_cache[repo_url][lua_version] = manifest
        end





******0 function manif.get_cached_manifest(repo_url, lua_version)
   2386    lua_version = lua_version or cfg.lua_version
   2386    return manifest_cache[repo_url] and manifest_cache[repo_url][lua_version]
        end








******0 function manif.manifest_loader(file, repo_url, lua_version)
           local manifest, err, errcode

******0    if file:match(".*%.json$") then
******0       manifest, err, errcode = persist.load_json_into_table(file)
           else
******0       manifest, err, errcode = persist.load_into_table(file)
           end

******0    if not manifest and type(err) == "string" then
******0       return nil, "Failed loading manifest for " .. repo_url .. ": " .. err, errcode
           end

******0    manif.cache_manifest(repo_url, lua_version, manifest)
******0    return manifest, err, errcode
        end






******0 function manif.fast_load_local_manifest(repo_url)

   2386    local cached_manifest = manif.get_cached_manifest(repo_url)
   2386    if cached_manifest then
   2386       return cached_manifest
           end

******0    local pathname = dir.path(repo_url, "manifest")
******0    return manif.manifest_loader(pathname, repo_url, nil)
        end

******0 function manif.load_rocks_tree_manifests(deps_mode)
   1193    local trees = {}
   2386    path.map_trees(deps_mode, function(tree)
   2386       local manifest = manif.fast_load_local_manifest(path.rocks_dir(tree))
   2386       if manifest then
   2386          table.insert(trees, { tree = tree, manifest = manifest })
              end
           end)
   1193    return trees
        end

******0 function manif.scan_dependencies(name, version, tree_manifests, dest)
     59    if dest[name] then
     59       return
           end
******0    dest[name] = version

******0    for _, tree in ipairs(tree_manifests) do
******0       local manifest = tree.manifest

              local pkgdeps
******0       if manifest.dependencies and manifest.dependencies[name] then
******0          pkgdeps = manifest.dependencies[name][version]
              end
******0       if pkgdeps then
******0          for _, dep in ipairs(pkgdeps) do
******0             local pkg, constraints = dep.name, dep.constraints

******0             for _, t in ipairs(tree_manifests) do
******0                local entries = t.manifest.repository[pkg]
******0                if entries then
******0                   for ver, _ in util.sortedpairs(entries, vers.compare_versions) do
******0                      if (not constraints) or vers.match_constraints(vers.parse_version(ver), constraints) then
******0                         manif.scan_dependencies(pkg, ver, tree_manifests, dest)
                             end
                          end
                       end
                    end
                 end
******0          return
              end
           end
        end

******0 return manif

==============================================================================
/opt/homebrew/share/lua/5.4/luarocks/core/path.lua
==============================================================================
******0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local assert = _tl_compat and _tl_compat.assert or assert; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local package = _tl_compat and _tl_compat.package or package; local pairs = _tl_compat and _tl_compat.pairs or pairs; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local type = type
******0 local path = {}


******0 local cfg = require("luarocks.core.cfg")
******0 local dir = require("luarocks.core.dir")



******0 local dir_sep = package.config:sub(1, 1)


******0 function path.rocks_dir(tree)
   2386    if tree == nil then
******0       tree = cfg.root_dir
******0       if tree == nil then
******0          error("root_dir could not be determined in configuration")
              end
           end
   2386    if type(tree) == "string" then
******0       return dir.path(tree, cfg.rocks_subdir)
           end
   2386    if tree.rocks_dir then
******0       return tree.rocks_dir
           end
   2386    if tree.root and cfg.rocks_subdir then
   2386       return dir.path(tree.root, cfg.rocks_subdir)
           end
******0    error("invalid configuration for local repository")
        end







******0 function path.versioned_name(file, prefix, name, version)
******0    assert(not name:match(dir_sep))

******0    local rest = file:sub(#prefix + 1):gsub("^" .. dir_sep .. "*", "")
******0    local name_version = (name .. "_" .. version):gsub("%-", "_"):gsub("%.", "_")
******0    return dir.path(prefix, name_version .. "-" .. rest)
        end








******0 function path.path_to_module(file)

     59    local exts = {}
     59    local paths = package.path .. ";" .. package.cpath
   1202    for entry in paths:gmatch("[^;]+") do
   1143       local ext = entry:match("%.([a-z]+)$")
   1143       if ext then
   1143          exts[ext] = true
              end
           end

           local name
     89    for ext, _ in pairs(exts) do
     89       name = file:match("(.*)%." .. ext .. "$")
     89       if name then
     59          name = name:gsub("[\\/]", ".")
     59          break
              end
           end

     59    if not name then name = file end


     59    name = name:gsub("^%.+", ""):gsub("%.+$", "")

     59    return name
        end

******0 function path.deploy_lua_dir(tree)
******0    if type(tree) == "string" then
******0       return dir.path(tree, cfg.lua_modules_path)
           else
******0       return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)
           end
        end

******0 function path.deploy_lib_dir(tree)
******0    if type(tree) == "string" then
******0       return dir.path(tree, cfg.lib_modules_path)
           else
******0       return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)
           end
        end

******0 local is_src_extension = { [".lua"] = true, [".tl"] = true, [".tld"] = true, [".moon"] = true }









******0 function path.which_i(file_name, name, version, tree, i)
           local deploy_dir
******0    local extension = file_name:match("%.[a-z]+$")
******0    if is_src_extension[extension] then
******0       deploy_dir = path.deploy_lua_dir(tree)
******0       file_name = dir.path(deploy_dir, file_name)
           else
******0       deploy_dir = path.deploy_lib_dir(tree)
******0       file_name = dir.path(deploy_dir, file_name)
           end
******0    if i > 1 then
******0       file_name = path.versioned_name(file_name, deploy_dir, name, version)
           end
******0    return file_name
        end

******0 function path.rocks_tree_to_string(tree)
   4772    if type(tree) == "string" then
******0       return tree
           else
   4772       return tree.root
           end
        end








******0 function path.map_trees(deps_mode, fn, ...)
   1193    local result = {}
   1193    local current = cfg.root_dir or cfg.rocks_trees[1]
   1193    if deps_mode == "one" then
******0       table.insert(result, (fn(current, ...)) or 0)
           else
   1193       local use = false
   1193       if deps_mode == "all" then
******0          use = true
              end
   3579       for _, tree in ipairs(cfg.rocks_trees or {}) do
   2386          if dir.normalize(path.rocks_tree_to_string(tree)) == dir.normalize(path.rocks_tree_to_string(current)) then
   1193             use = true
                 end
   2386          if use then
   2386             table.insert(result, (fn(tree, ...)) or 0)
                 end
              end
           end
   1193    return result
        end

******0 return path

==============================================================================
/opt/homebrew/share/lua/5.4/luarocks/loader.lua
==============================================================================
******0 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local debug = _tl_compat and _tl_compat.debug or debug; local io = _tl_compat and _tl_compat.io or io; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local package = _tl_compat and _tl_compat.package or package; local pairs = _tl_compat and _tl_compat.pairs or pairs; local pcall = _tl_compat and _tl_compat.pcall or pcall; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local type = type






******0 local loaders = package.loaders or package.searchers
        local require, ipairs, table, type, next, tostring, error =
******0 require, ipairs, table, type, next, tostring, error

******0 local loader = {}




******0 local is_clean = not package.loaded["luarocks.core.cfg"]


******0 local cfg = require("luarocks.core.cfg")
******0 local cfg_ok, _err = cfg.init()
******0 if cfg_ok then
******0    cfg.init_package_paths()
        end

******0 local path = require("luarocks.core.path")
******0 local manif = require("luarocks.core.manif")
******0 local vers = require("luarocks.core.vers")

























******0 local temporary_global = false
******0 local status, luarocks_value = pcall(function()
******0    return luarocks
        end)
******0 if status and luarocks_value then



******0    luarocks.loader = loader
        else





******0    local info = debug and debug.getinfo(2, "nS")
******0    if info and info.what == "C" and not info.name then
******0       luarocks = { loader = loader }
******0       temporary_global = true


           end
        end





******0 loader.context = {}






******0 function loader.add_context(name, version)
     59    if temporary_global then


******0       luarocks = nil
******0       temporary_global = false
           end

     59    local tree_manifests = manif.load_rocks_tree_manifests()
     59    if not tree_manifests then
******0       return
           end

     59    manif.scan_dependencies(name, version, tree_manifests, loader.context)
        end







        local function sort_versions(a, b)
******0    return a.version > b.version
        end
















        local function call_other_loaders(module, name, version, module_name)
    177    for _, a_loader in ipairs(loaders) do
    177       if a_loader ~= loader.luarocks_loader then
    118          local results = { a_loader(module_name) }
    118          local f = results[1]
    118          if type(f) == "function" then
     59             if #results == 2 then
     59                return f, results[2]
                    else
******0                return f
                    end
                 end
              end
           end
******0    return "Failed loading module " .. module .. " in LuaRocks rock " .. name .. " " .. version
        end















        local function add_providers(providers, entries, tree, module, filter_name)
     59    for i, entry in ipairs(entries) do
     59       local name, version = entry:match("^([^/]*)/(.*)$")

     59       local file_name = tree.manifest.repository[name][version][1].modules[module]
     59       if type(file_name) ~= "string" then
******0          error("Invalid data in manifest file for module " .. tostring(module) .. " (invalid data for " .. tostring(name) .. " " .. tostring(version) .. ")")
              end

     59       file_name = filter_name(file_name, name, version, tree.tree, i)

     59       if loader.context[name] == version then
     59          return name, version, file_name
              end

******0       table.insert(providers, {
                 name = name,
                 version = vers.parse_version(version),
                 module_name = file_name,
                 tree = tree,
              })
           end
        end













        local function select_module(module, filter_name)

   1134    local tree_manifests = manif.load_rocks_tree_manifests()
   1134    if not tree_manifests then
******0       return nil
           end

   1134    local providers = {}
           local initmodule
   3343    for _, tree in ipairs(tree_manifests) do
   2268       local entries = tree.manifest.modules[module]
   2268       if entries then
     59          local n, v, f = add_providers(providers, entries, tree, module, filter_name)
     59          if n then
     59             return n, v, f
                 end
              else
   2209          initmodule = initmodule or module .. ".init"
   2209          entries = tree.manifest.modules[initmodule]
   2209          if entries then
******0             local n, v, f = add_providers(providers, entries, tree, initmodule, filter_name)
******0             if n then
******0                return n, v, f
                    end
                 end
              end
           end

   1075    if next(providers) then
******0       table.sort(providers, sort_versions)
******0       local first = providers[1]
******0       return first.name, first.version.string, first.module_name
           end
        end












        local function filter_module_name(file_name, name, version, _tree, i)
     59    if i > 1 then
******0       file_name = path.versioned_name(file_name, "", name, version)
           end
     59    return path.path_to_module(file_name)
        end









        local function pick_module(module)
   1134    return select_module(module, filter_module_name)
        end













******0 function loader.which(module, where)
******0    where = where or "l"
******0    if where:match("l") then
******0       local rock_name, rock_version, file_name = select_module(module, path.which_i)
******0       if rock_name then
******0          local fd = io.open(file_name)
******0          if fd then
******0             fd:close()
******0             return file_name, rock_name, rock_version, "l"
                 end
              end
           end
******0    if where:match("p") then
******0       local modpath = module:gsub("%.", "/")
******0       for _, v in ipairs({ package.path, package.cpath }) do
******0          for p in v:gmatch("([^;]+)") do
******0             local file_name = p:gsub("%?", modpath)
******0             local fd = io.open(file_name)
******0             if fd then
******0                fd:close()
******0                return file_name, v, nil, "p"
                    end
                 end
              end
           end
        end













******0 function loader.luarocks_loader(module)
   1134    local name, version, module_name = pick_module(module)
   1134    if not name then
   1075       return "No LuaRocks module found for " .. module
           else
     59       loader.add_context(name, version)
     59       return call_other_loaders(module, name, version, module_name)
           end
        end

******0 table.insert(loaders, 1, loader.luarocks_loader)

******0 if is_clean then
******0    for modname, _ in pairs(package.loaded) do
******0       if modname:match("^luarocks%.") then
******0          package.loaded[modname] = nil
              end
           end
        end

******0 return loader

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/assert.lua
==============================================================================
******0 local s = require 'say'
******0 local astate = require 'luassert.state'
******0 local util = require 'luassert.util'
******0 local unpack = util.unpack
        local obj   -- the returned module table
******0 local level_mt = {}

        -- list of namespaces
******0 local namespace = require 'luassert.namespaces'

        local function geterror(assertion_message, failure_message, args)
     12   if util.hastostring(failure_message) then
******0     failure_message = tostring(failure_message)
     12   elseif failure_message ~= nil then
******0     failure_message = astate.format_argument(failure_message)
          end
     12   local message = s(assertion_message, obj:format(args))
     12   if message and failure_message then
******0     message = failure_message .. "\n" .. message
          end
     12   return message or failure_message
        end

******0 local __state_meta = {

          __call = function(self, ...)
   1486     local keys = util.extract_keys("assertion", self.tokens)

            local assertion

   4610     for _, key in ipairs(keys) do
   3124       assertion = namespace.assertion[key] or assertion
            end

   1486     if assertion then
   4610       for _, key in ipairs(keys) do
   3124         if namespace.modifier[key] then
   1638           namespace.modifier[key].callback(self)
                end
              end

   1486       local arguments = util.make_arglist(...)
   1486       local val, retargs = assertion.callback(self, arguments, util.errorlevel())

   1486       if (not val) == self.mod then
     12         local message = assertion.positive_message
     12         if not self.mod then
******0           message = assertion.negative_message
                end
     12         local err = geterror(message, rawget(self,"failure_message"), arguments)
     12         error(err or "assertion failed!", util.errorlevel())
              end

   1474       if retargs then
******0         return unpack(retargs)
              end
   1474       return ...
            else
******0       local arguments = util.make_arglist(...)
******0       self.tokens = {}

******0       for _, key in ipairs(keys) do
******0         if namespace.modifier[key] then
******0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
                end
              end
            end

******0     return self
          end,

          __index = function(self, key)
   5194     for token in key:lower():gmatch('[^_]+') do
   3124       table.insert(self.tokens, token)
            end

   2070     return self
          end
        }

******0 obj = {
   1486   state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,

          -- registers a function in namespace
          register = function(self, nspace, name, callback, positive_message, negative_message)
******0     local lowername = name:lower()
******0     if not namespace[nspace] then
******0       namespace[nspace] = {}
            end
******0     namespace[nspace][lowername] = {
              callback = callback,
              name = lowername,
              positive_message=positive_message,
******0       negative_message=negative_message
            }
          end,

          -- unregisters a function in a namespace
          unregister = function(self, nspace, name)
******0     local lowername = name:lower()
******0     if not namespace[nspace] then
******0       namespace[nspace] = {}
            end
******0     namespace[nspace][lowername] = nil
          end,

          -- registers a formatter
          -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
          add_formatter = function(self, callback)
******0     astate.add_formatter(callback)
          end,

          -- unregisters a formatter
          remove_formatter = function(self, fmtr)
******0     astate.remove_formatter(fmtr)
          end,

          format = function(self, args)
            -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
     12     local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
     12     local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
     36     for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
     24       if not nofmt[i] then
     24         local val = args[i]
     24         local valfmt = astate.format_argument(val, nil, fmtargs[i])
     24         if valfmt == nil then valfmt = tostring(val) end -- no formatter found
     24         args[i] = valfmt
              end
            end
     12     return args
          end,

          set_parameter = function(self, name, value)
******0     astate.set_parameter(name, value)
          end,

          get_parameter = function(self, name)
******0     return astate.get_parameter(name)
          end,

          add_spy = function(self, spy)
******0     astate.add_spy(spy)
          end,

          snapshot = function(self)
******0     return astate.snapshot()
          end,

          level = function(self, level)
******0     return setmetatable({
******0         level = level
******0       }, level_mt)
          end,

          -- returns the level if a level-value, otherwise nil
          get_level = function(self, level)
******0     if getmetatable(level) ~= level_mt then
******0       return nil -- not a valid error-level
            end
******0     return level.level
          end,
        }

******0 local __meta = {

          __call = function(self, bool, message, level, ...)
    633     if not bool then
******0       local err_level = (self:get_level(level) or 1) + 1
******0       error(message or "assertion failed!", err_level)
            end
    633     return bool , message , level , ...
          end,

          __index = function(self, key)
   1486     return rawget(self, key) or self.state()[key]
          end,

        }

******0 return setmetatable(obj, __meta)

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/assertions.lua
==============================================================================
        -- module will not return anything, only register assertions with the main assert engine

        -- assertions take 2 parameters;
        -- 1) state
        -- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils
        -- 3) level The level of the error position relative to the called function
        -- returns; boolean; whether assertion passed

******0 local assert = require('luassert.assert')
******0 local astate = require ('luassert.state')
******0 local util = require ('luassert.util')
******0 local s = require('say')

        local function format(val)
******0   return astate.format_argument(val) or tostring(val)
        end

        local function set_failure_message(state, message)
   1486   if message ~= nil then
      6     state.failure_message = message
          end
        end

        local function unique(state, arguments, level)
******0   local list = arguments[1]
          local deep
******0   local argcnt = arguments.n
******0   if type(arguments[2]) == "boolean" or (arguments[2] == nil and argcnt > 2) then
******0     deep = arguments[2]
******0     set_failure_message(state, arguments[3])
          else
******0     if type(arguments[3]) == "boolean" then
******0       deep = arguments[3]
            end
******0     set_failure_message(state, arguments[2])
          end
******0   for k,v in pairs(list) do
******0     for k2, v2 in pairs(list) do
******0       if k ~= k2 then
******0         if deep and util.deepcompare(v, v2, true) then
******0           return false
                else
******0           if v == v2 then
******0             return false
                  end
                end
              end
            end
          end
******0   return true
        end

        local function near(state, arguments, level)
******0   local level = (level or 1) + 1
******0   local argcnt = arguments.n
******0   assert(argcnt > 2, s("assertion.internal.argtolittle", { "near", 3, tostring(argcnt) }), level)
******0   local expected = tonumber(arguments[1])
******0   local actual = tonumber(arguments[2])
******0   local tolerance = tonumber(arguments[3])
******0   local numbertype = "number or object convertible to a number"
******0   assert(expected, s("assertion.internal.badargtype", { 1, "near", numbertype, format(arguments[1]) }), level)
******0   assert(actual, s("assertion.internal.badargtype", { 2, "near", numbertype, format(arguments[2]) }), level)
******0   assert(tolerance, s("assertion.internal.badargtype", { 3, "near", numbertype, format(arguments[3]) }), level)
          -- switch arguments for proper output message
******0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
******0   arguments[3] = tolerance
******0   arguments.nofmt = arguments.nofmt or {}
******0   arguments.nofmt[3] = true
******0   set_failure_message(state, arguments[4])
******0   return (actual >= expected - tolerance and actual <= expected + tolerance)
        end

        local function matches(state, arguments, level)
******0   local level = (level or 1) + 1
******0   local argcnt = arguments.n
******0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "matches", 2, tostring(argcnt) }), level)
******0   local pattern = arguments[1]
          local actual = nil
******0   if util.hastostring(arguments[2]) or type(arguments[2]) == "number" then
******0     actual = tostring(arguments[2])
          end
          local err_message
******0   local init_arg_num = 3
******0   for i=3,argcnt,1 do
******0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
******0       if i == 3 then init_arg_num = init_arg_num + 1 end
******0       err_message = util.tremove(arguments, i)
              break
            end
          end
******0   local init = arguments[3]
******0   local plain = arguments[4]
******0   local stringtype = "string or object convertible to a string"
******0   assert(type(pattern) == "string", s("assertion.internal.badargtype", { 1, "matches", "string", type(arguments[1]) }), level)
******0   assert(actual, s("assertion.internal.badargtype", { 2, "matches", stringtype, format(arguments[2]) }), level)
******0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)
          -- switch arguments for proper output message
******0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
******0   set_failure_message(state, err_message)
          local retargs
          local ok
******0   if plain then
******0     ok = (actual:find(pattern, init, plain) ~= nil)
******0     retargs = ok and { pattern } or {}
          else
******0     retargs = { actual:match(pattern, init) }
******0     ok = (retargs[1] ~= nil)
          end
******0   return ok, retargs
        end

        local function equals(state, arguments, level)
    628   local level = (level or 1) + 1
    628   local argcnt = arguments.n
    628   assert(argcnt > 1, s("assertion.internal.argtolittle", { "equals", 2, tostring(argcnt) }), level)
    628   local result =  arguments[1] == arguments[2]
          -- switch arguments for proper output message
    628   util.tinsert(arguments, 1, util.tremove(arguments, 2))
    628   set_failure_message(state, arguments[3])
    628   return result
        end

        local function same(state, arguments, level)
******0   local level = (level or 1) + 1
******0   local argcnt = arguments.n
******0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "same", 2, tostring(argcnt) }), level)
******0   if type(arguments[1]) == 'table' and type(arguments[2]) == 'table' then
******0     local result, crumbs = util.deepcompare(arguments[1], arguments[2], true)
            -- switch arguments for proper output message
******0     util.tinsert(arguments, 1, util.tremove(arguments, 2))
******0     arguments.fmtargs = arguments.fmtargs or {}
******0     arguments.fmtargs[1] = { crumbs = crumbs }
******0     arguments.fmtargs[2] = { crumbs = crumbs }
******0     set_failure_message(state, arguments[3])
******0     return result
          end
******0   local result = arguments[1] == arguments[2]
          -- switch arguments for proper output message
******0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
******0   set_failure_message(state, arguments[3])
******0   return result
        end

        local function truthy(state, arguments, level)
******0   local argcnt = arguments.n
******0   assert(argcnt > 0, s("assertion.internal.argtolittle", { "truthy", 1, tostring(argcnt) }), level)
******0   set_failure_message(state, arguments[2])
******0   return arguments[1] ~= false and arguments[1] ~= nil
        end

        local function falsy(state, arguments, level)
******0   local argcnt = arguments.n
******0   assert(argcnt > 0, s("assertion.internal.argtolittle", { "falsy", 1, tostring(argcnt) }), level)
******0   return not truthy(state, arguments, level)
        end

        local function has_error(state, arguments, level)
******0   local level = (level or 1) + 1
******0   local retargs = util.shallowcopy(arguments)
******0   local func = arguments[1]
******0   local err_expected = arguments[2]
******0   local failure_message = arguments[3]
******0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error", "function or callable object", type(func) }), level)
******0   local ok, err_actual = pcall(func)
******0   if type(err_actual) == 'string' then
            -- remove 'path/to/file:line: ' from string
******0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
          end
******0   retargs[1] = err_actual
******0   arguments.nofmt = {}
******0   arguments.n = 2
******0   arguments[1] = (ok and '(no error)' or err_actual)
******0   arguments[2] = (err_expected == nil and '(error)' or err_expected)
******0   arguments.nofmt[1] = ok
******0   arguments.nofmt[2] = (err_expected == nil)
******0   set_failure_message(state, failure_message)

******0   if ok or err_expected == nil then
******0     return not ok, retargs
          end
******0   if type(err_expected) == 'string' then
            -- err_actual must be (convertible to) a string
******0     if util.hastostring(err_actual) then
******0       err_actual = tostring(err_actual)
******0       retargs[1] = err_actual
            end
******0     if type(err_actual) == 'string' then
******0       return err_expected == err_actual, retargs
            end
******0   elseif type(err_expected) == 'number' then
******0     if type(err_actual) == 'string' then
******0       return tostring(err_expected) == tostring(tonumber(err_actual)), retargs
            end
          end
******0   return same(state, {err_expected, err_actual, ["n"] = 2}), retargs
        end

        local function error_matches(state, arguments, level)
******0   local level = (level or 1) + 1
******0   local retargs = util.shallowcopy(arguments)
******0   local argcnt = arguments.n
******0   local func = arguments[1]
******0   local pattern = arguments[2]
******0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "error_matches", 2, tostring(argcnt) }), level)
******0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error_matches", "function or callable object", type(func) }), level)
******0   assert(pattern == nil or type(pattern) == "string", s("assertion.internal.badargtype", { 2, "error", "string", type(pattern) }), level)

          local failure_message
******0   local init_arg_num = 3
******0   for i=3,argcnt,1 do
******0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
******0       if i == 3 then init_arg_num = init_arg_num + 1 end
******0       failure_message = util.tremove(arguments, i)
              break
            end
          end
******0   local init = arguments[3]
******0   local plain = arguments[4]
******0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)

******0   local ok, err_actual = pcall(func)
******0   if type(err_actual) == 'string' then
            -- remove 'path/to/file:line: ' from string
******0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
          end
******0   retargs[1] = err_actual
******0   arguments.nofmt = {}
******0   arguments.n = 2
******0   arguments[1] = (ok and '(no error)' or err_actual)
******0   arguments[2] = pattern
******0   arguments.nofmt[1] = ok
******0   arguments.nofmt[2] = false
******0   set_failure_message(state, failure_message)

******0   if ok then return not ok, retargs end
******0   if err_actual == nil and pattern == nil then
******0     return true, {}
          end

          -- err_actual must be (convertible to) a string
******0   if util.hastostring(err_actual) or
******0      type(err_actual) == "number" or
******0      type(err_actual) == "boolean" then
******0     err_actual = tostring(err_actual)
******0     retargs[1] = err_actual
          end
******0   if type(err_actual) == 'string' then
            local ok
            local retargs_ok
******0     if plain then
******0       retargs_ok = { pattern }
******0       ok = (err_actual:find(pattern, init, plain) ~= nil)
            else
******0       retargs_ok = { err_actual:match(pattern, init) }
******0       ok = (retargs_ok[1] ~= nil)
            end
******0     if ok then retargs = retargs_ok end
******0     return ok, retargs
          end

******0   return false, retargs
        end

        local function is_true(state, arguments, level)
    272   util.tinsert(arguments, 2, true)
    272   set_failure_message(state, arguments[3])
    272   return arguments[1] == arguments[2]
        end

        local function is_false(state, arguments, level)
     48   util.tinsert(arguments, 2, false)
     48   set_failure_message(state, arguments[3])
     48   return arguments[1] == arguments[2]
        end

        local function is_type(state, arguments, level, etype)
    538   util.tinsert(arguments, 2, "type " .. etype)
    538   arguments.nofmt = arguments.nofmt or {}
    538   arguments.nofmt[2] = true
    538   set_failure_message(state, arguments[3])
    538   return arguments.n > 1 and type(arguments[1]) == etype
        end

        local function returned_arguments(state, arguments, level)
******0   arguments[1] = tostring(arguments[1])
******0   arguments[2] = tostring(arguments.n - 1)
******0   arguments.nofmt = arguments.nofmt or {}
******0   arguments.nofmt[1] = true
******0   arguments.nofmt[2] = true
******0   if arguments.n < 2 then arguments.n = 2 end
******0   return arguments[1] == arguments[2]
        end

        local function set_message(state, arguments, level)
******0   state.failure_message = arguments[1]
        end

******0 local function is_boolean(state, arguments, level)  return is_type(state, arguments, level, "boolean")  end
     16 local function is_number(state, arguments, level)   return is_type(state, arguments, level, "number")   end
     10 local function is_string(state, arguments, level)   return is_type(state, arguments, level, "string")   end
     92 local function is_table(state, arguments, level)    return is_type(state, arguments, level, "table")    end
    246 local function is_nil(state, arguments, level)      return is_type(state, arguments, level, "nil")      end
******0 local function is_userdata(state, arguments, level) return is_type(state, arguments, level, "userdata") end
    174 local function is_function(state, arguments, level) return is_type(state, arguments, level, "function") end
******0 local function is_thread(state, arguments, level)   return is_type(state, arguments, level, "thread")   end

******0 assert:register("modifier", "message", set_message)
******0 assert:register("assertion", "true", is_true, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "false", is_false, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "boolean", is_boolean, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "number", is_number, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "string", is_string, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "table", is_table, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "nil", is_nil, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "userdata", is_userdata, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "function", is_function, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "thread", is_thread, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "returned_arguments", returned_arguments, "assertion.returned_arguments.positive", "assertion.returned_arguments.negative")

******0 assert:register("assertion", "same", same, "assertion.same.positive", "assertion.same.negative")
******0 assert:register("assertion", "matches", matches, "assertion.matches.positive", "assertion.matches.negative")
******0 assert:register("assertion", "match", matches, "assertion.matches.positive", "assertion.matches.negative")
******0 assert:register("assertion", "near", near, "assertion.near.positive", "assertion.near.negative")
******0 assert:register("assertion", "equals", equals, "assertion.equals.positive", "assertion.equals.negative")
******0 assert:register("assertion", "equal", equals, "assertion.equals.positive", "assertion.equals.negative")
******0 assert:register("assertion", "unique", unique, "assertion.unique.positive", "assertion.unique.negative")
******0 assert:register("assertion", "error", has_error, "assertion.error.positive", "assertion.error.negative")
******0 assert:register("assertion", "errors", has_error, "assertion.error.positive", "assertion.error.negative")
******0 assert:register("assertion", "error_matches", error_matches, "assertion.error.positive", "assertion.error.negative")
******0 assert:register("assertion", "error_match", error_matches, "assertion.error.positive", "assertion.error.negative")
******0 assert:register("assertion", "matches_error", error_matches, "assertion.error.positive", "assertion.error.negative")
******0 assert:register("assertion", "match_error", error_matches, "assertion.error.positive", "assertion.error.negative")
******0 assert:register("assertion", "truthy", truthy, "assertion.truthy.positive", "assertion.truthy.negative")
******0 assert:register("assertion", "falsy", falsy, "assertion.falsy.positive", "assertion.falsy.negative")

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/formatters/init.lua
==============================================================================
        -- module will not return anything, only register formatters with the main assert engine
******0 local assert = require('luassert.assert')
******0 local match = require('luassert.match')
******0 local util = require('luassert.util')

******0 local isatty, colors do
******0   local ok, term = pcall(require, 'term')
******0   isatty = io.type(io.stdout) == 'file' and ok and term.isatty(io.stdout)
******0   if not isatty then
******0     local isWindows = package.config:sub(1,1) == '\\'
******0     if isWindows and os.getenv("ANSICON") then
******0       isatty = true
            end
          end

******0   colors = setmetatable({
******0     none = function(c) return c end
******0   },{ __index = function(self, key)
            return function(c)
******0       for token in key:gmatch("[^%.]+") do
******0         c = term.colors[token](c)
              end
******0       return c
            end
          end
          })
        end

        local function fmt_string(arg)
******0   if type(arg) == "string" then
******0     return string.format("(string) '%s'", arg)
          end
        end

        -- A version of tostring which formats numbers more precisely.
        local function tostr(arg)
     24   if type(arg) ~= "number" then
******0     return tostring(arg)
          end

     24   if arg ~= arg then
******0     return "NaN"
     24   elseif arg == 1/0 then
******0     return "Inf"
     24   elseif arg == -1/0 then
******0     return "-Inf"
          end

     24   local str = string.format("%.20g", arg)

     24   if math.type and math.type(arg) == "float" and not str:find("[%.,]") then
            -- Number is a float but looks like an integer.
            -- Insert ".0" after first run of digits.
******0     str = str:gsub("%d+", "%0.0", 1)
          end

     24   return str
        end

        local function fmt_number(arg)
     24   if type(arg) == "number" then
     24     return string.format("(number) %s", tostr(arg))
          end
        end

        local function fmt_boolean(arg)
     24   if type(arg) == "boolean" then
******0     return string.format("(boolean) %s", tostring(arg))
          end
        end

        local function fmt_nil(arg)
     24   if type(arg) == "nil" then
******0     return "(nil)"
          end
        end

******0 local type_priorities = {
          number = 1,
          boolean = 2,
          string = 3,
          table = 4,
          ["function"] = 5,
          userdata = 6,
******0   thread = 7
        }

        local function is_in_array_part(key, length)
******0   return type(key) == "number" and 1 <= key and key <= length and math.floor(key) == key
        end

        local function get_sorted_keys(t)
******0   local keys = {}
******0   local nkeys = 0

******0   for key in pairs(t) do
******0     nkeys = nkeys + 1
******0     keys[nkeys] = key
          end

******0   local length = #t

          local function key_comparator(key1, key2)
******0     local type1, type2 = type(key1), type(key2)
******0     local priority1 = is_in_array_part(key1, length) and 0 or type_priorities[type1] or 8
******0     local priority2 = is_in_array_part(key2, length) and 0 or type_priorities[type2] or 8

******0     if priority1 == priority2 then
******0       if type1 == "string" or type1 == "number" then
******0         return key1 < key2
******0       elseif type1 == "boolean" then
******0         return key1  -- put true before false
              end
            else
******0       return priority1 < priority2
            end
          end

******0   table.sort(keys, key_comparator)
******0   return keys, nkeys
        end

        local function fmt_table(arg, fmtargs)
     24   if type(arg) ~= "table" then
     24     return
          end

******0   local tmax = assert:get_parameter("TableFormatLevel")
******0   local showrec = assert:get_parameter("TableFormatShowRecursion")
******0   local errchar = assert:get_parameter("TableErrorHighlightCharacter") or ""
******0   local errcolor = assert:get_parameter("TableErrorHighlightColor")
******0   local crumbs = fmtargs and fmtargs.crumbs or {}
******0   local cache = {}
          local type_desc

******0   if getmetatable(arg) == nil then
******0     type_desc = "(" .. tostring(arg) .. ") "
******0   elseif not pcall(setmetatable, arg, getmetatable(arg)) then
            -- cannot set same metatable, so it is protected, skip id
******0     type_desc = "(table) "
          else
            -- unprotected metatable, temporary remove the mt
******0     local mt = getmetatable(arg)
******0     setmetatable(arg, nil)
******0     type_desc = "(" .. tostring(arg) .. ") "
******0     setmetatable(arg, mt)
          end

          local function ft(t, l, with_crumbs)
******0     if showrec and cache[t] and cache[t] > 0 then
******0       return "{ ... recursive }"
            end

******0     if next(t) == nil then
******0       return "{ }"
            end

******0     if l > tmax and tmax >= 0 then
******0       return "{ ... more }"
            end

******0     local result = "{"
******0     local keys, nkeys = get_sorted_keys(t)

******0     cache[t] = (cache[t] or 0) + 1
******0     local crumb = crumbs[#crumbs - l + 1]

******0     for i = 1, nkeys do
******0       local k = keys[i]
******0       local v = t[k]
******0       local use_crumbs = with_crumbs and k == crumb

******0       if type(v) == "table" then
******0         v = ft(v, l + 1, use_crumbs)
******0       elseif type(v) == "string" then
******0         v = "'"..v.."'"
              end

******0       local ch = use_crumbs and errchar or ""
******0       local indent = string.rep(" ",l * 2 - ch:len())
******0       local mark = (ch:len() == 0 and "" or colors[errcolor](ch))
******0       result = result .. string.format("\n%s%s[%s] = %s", indent, mark, tostr(k), tostr(v))
            end

******0     cache[t] = cache[t] - 1

******0     return result .. " }"
          end

******0   return type_desc .. ft(arg, 1, true)
        end

        local function fmt_function(arg)
     24   if type(arg) == "function" then
******0     local debug_info = debug.getinfo(arg)
******0     return string.format("%s @ line %s in %s", tostring(arg), tostring(debug_info.linedefined), tostring(debug_info.source))
          end
        end

        local function fmt_userdata(arg)
     24   if type(arg) == "userdata" then
******0     return string.format("(userdata) '%s'", tostring(arg))
          end
        end

        local function fmt_thread(arg)
     24   if type(arg) == "thread" then
******0     return string.format("(thread) '%s'", tostring(arg))
          end
        end

        local function fmt_matcher(arg)
     24   if not match.is_matcher(arg) then
     24     return
          end
******0   local not_inverted = {
            [true] = "is.",
            [false] = "no.",
          }
******0   local args = {}
******0   for idx = 1, arg.arguments.n do
******0     table.insert(args, assert:format({ arg.arguments[idx], n = 1, })[1])
          end
******0   return string.format("(matcher) %s%s(%s)",
******0                        not_inverted[arg.mod],
******0                        tostring(arg.name),
******0                        table.concat(args, ", "))
        end

        local function fmt_arglist(arglist)
     24   if not util.is_arglist(arglist) then
     24     return
          end
******0   local formatted_vals = {}
******0   for idx = 1, arglist.n do
******0     table.insert(formatted_vals, assert:format({ arglist[idx], n = 1, })[1])
          end
******0   return "(values list) (" .. table.concat(formatted_vals, ", ") .. ")"
        end

******0 assert:add_formatter(fmt_string)
******0 assert:add_formatter(fmt_number)
******0 assert:add_formatter(fmt_boolean)
******0 assert:add_formatter(fmt_nil)
******0 assert:add_formatter(fmt_table)
******0 assert:add_formatter(fmt_function)
******0 assert:add_formatter(fmt_userdata)
******0 assert:add_formatter(fmt_thread)
******0 assert:add_formatter(fmt_matcher)
******0 assert:add_formatter(fmt_arglist)
        -- Set default table display depth for table formatter
******0 assert:set_parameter("TableFormatLevel", 3)
******0 assert:set_parameter("TableFormatShowRecursion", false)
******0 assert:set_parameter("TableErrorHighlightCharacter", "*")
******0 assert:set_parameter("TableErrorHighlightColor", isatty and "red" or "none")

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/match.lua
==============================================================================
******0 local namespace = require 'luassert.namespaces'
******0 local util = require 'luassert.util'

******0 local matcher_mt = {
          __call = function(self, value)
******0     return self.callback(value) == self.mod
          end,
        }

******0 local state_mt = {
          __call = function(self, ...)
******0     local keys = util.extract_keys("matcher", self.tokens)
******0     self.tokens = {}

            local matcher

******0     for _, key in ipairs(keys) do
******0       matcher = namespace.matcher[key] or matcher
            end

******0     if matcher then
******0       for _, key in ipairs(keys) do
******0         if namespace.modifier[key] then
******0           namespace.modifier[key].callback(self)
                end
              end

******0       local arguments = util.make_arglist(...)
******0       local matches = matcher.callback(self, arguments, util.errorlevel())
******0       return setmetatable({
                name = matcher.name,
                mod = self.mod,
                callback = matches,
                arguments = arguments,
******0       }, matcher_mt)
            else
******0       local arguments = util.make_arglist(...)

******0       for _, key in ipairs(keys) do
******0         if namespace.modifier[key] then
******0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
                end
              end
            end

******0     return self
          end,

          __index = function(self, key)
******0     for token in key:lower():gmatch('[^_]+') do
******0       table.insert(self.tokens, token)
            end

******0     return self
          end
        }

******0 local match = {
          _ = setmetatable({mod=true, callback=function() return true end}, matcher_mt),

          state = function() return setmetatable({mod=true, tokens={}}, state_mt) end,

          is_matcher = function(object)
     24     return type(object) == "table" and getmetatable(object) == matcher_mt
          end,

          is_ref_matcher = function(object)
******0     local ismatcher = (type(object) == "table" and getmetatable(object) == matcher_mt)
******0     return ismatcher and object.name == "ref"
          end,
        }

******0 local mt = {
          __index = function(self, key)
******0     return rawget(self, key) or self.state()[key]
          end,
        }

******0 return setmetatable(match, mt)

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/modifiers.lua
==============================================================================
        -- module will not return anything, only register assertions/modifiers with the main assert engine
******0 local assert = require('luassert.assert')

        local function is(state)
   1442   return state
        end

        local function is_not(state)
    196   state.mod = not state.mod
    196   return state
        end

******0 assert:register("modifier", "is", is)
******0 assert:register("modifier", "are", is)
******0 assert:register("modifier", "was", is)
******0 assert:register("modifier", "has", is)
******0 assert:register("modifier", "does", is)
******0 assert:register("modifier", "not", is_not)
******0 assert:register("modifier", "no", is_not)

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/state.lua
==============================================================================
        -- maintains a state of the assert engine in a linked-list fashion
        -- records; formatters, parameters, spies and stubs

******0 local state_mt = {
          __call = function(self)
******0     self:revert()
          end
        }

******0 local spies_mt = { __mode = "kv" }

******0 local nilvalue = {} -- unique ID to refer to nil values for parameters

        -- will hold the current state
        local current

        -- exported module table
******0 local state = {}

        ------------------------------------------------------
        -- Reverts to a (specific) snapshot.
        -- @param self (optional) the snapshot to revert to. If not provided, it will revert to the last snapshot.
        state.revert = function(self)
******0   if not self then
            -- no snapshot given, so move 1 up
******0     self = current
******0     if not self.previous then
              -- top of list, no previous one, nothing to do
******0       return
            end
          end
******0   if getmetatable(self) ~= state_mt then error("Value provided is not a valid snapshot", 2) end

******0   if self.next then
******0     self.next:revert()
          end
          -- revert formatters in 'last'
******0   self.formatters = {}
          -- revert parameters in 'last'
******0   self.parameters = {}
          -- revert spies/stubs in 'last'
******0   for s,_ in pairs(self.spies) do
******0     self.spies[s] = nil
******0     s:revert()
          end
******0   setmetatable(self, nil) -- invalidate as a snapshot
******0   current = self.previous
******0   current.next = nil
        end

        ------------------------------------------------------
        -- Creates a new snapshot.
        -- @return snapshot table
        state.snapshot = function()
******0   local new = setmetatable ({
            formatters = {},
            parameters = {},
            spies = setmetatable({}, spies_mt),
            previous = current,
            revert = state.revert,
******0   }, state_mt)
******0   if current then current.next = new end
******0   current = new
******0   return current
        end


        --  FORMATTERS
        state.add_formatter = function(callback)
******0   table.insert(current.formatters, 1, callback)
        end

        state.remove_formatter = function(callback, s)
******0   s = s or current
******0   for i, v in ipairs(s.formatters) do
******0     if v == callback then
******0       table.remove(s.formatters, i)
              break
            end
          end
          -- wasn't found, so traverse up 1 state
******0   if s.previous then
******0     state.remove_formatter(callback, s.previous)
          end
        end

        state.format_argument = function(val, s, fmtargs)
     24   s = s or current
    216   for _, fmt in ipairs(s.formatters) do
    216     local valfmt = fmt(val, fmtargs)
    216     if valfmt ~= nil then return valfmt end
          end
          -- nothing found, check snapshot 1 up in list
******0   if s.previous then
******0     return state.format_argument(val, s.previous, fmtargs)
          end
******0   return nil -- end of list, couldn't format
        end


        --  PARAMETERS
        state.set_parameter = function(name, value)
******0   if value == nil then value = nilvalue end
******0   current.parameters[name] = value
        end

        state.get_parameter = function(name, s)
******0   s = s or current
******0   local val = s.parameters[name]
******0   if val == nil and s.previous then
            -- not found, so check 1 up in list
******0     return state.get_parameter(name, s.previous)
          end
******0   if val ~= nilvalue then
******0     return val
          end
******0   return nil
        end

        --  SPIES / STUBS
        state.add_spy = function(spy)
******0   current.spies[spy] = true
        end

******0 state.snapshot()  -- create initial state

******0 return state

==============================================================================
/opt/homebrew/share/lua/5.4/luassert/util.lua
==============================================================================
******0 local util = {}
******0 local arglist_mt = {}

        -- have pack/unpack both respect the 'n' field
******0 local _unpack = table.unpack or unpack
******0 local unpack = function(t, i, j) return _unpack(t, i or 1, j or t.n or #t) end
******0 local pack = function(...) return { n = select("#", ...), ... } end
******0 util.pack = pack
******0 util.unpack = unpack


******0 function util.deepcompare(t1,t2,ignore_mt,cycles,thresh1,thresh2)
******0   local ty1 = type(t1)
******0   local ty2 = type(t2)
          -- non-table types can be directly compared
******0   if ty1 ~= 'table' or ty2 ~= 'table' then return t1 == t2 end
******0   local mt1 = debug.getmetatable(t1)
******0   local mt2 = debug.getmetatable(t2)
          -- would equality be determined by metatable __eq?
******0   if mt1 and mt1 == mt2 and mt1.__eq then
            -- then use that unless asked not to
******0     if not ignore_mt then return t1 == t2 end
          else -- we can skip the deep comparison below if t1 and t2 share identity
******0     if rawequal(t1, t2) then return true end
          end

          -- handle recursive tables
******0   cycles = cycles or {{},{}}
******0   thresh1, thresh2 = (thresh1 or 1), (thresh2 or 1)
******0   cycles[1][t1] = (cycles[1][t1] or 0)
******0   cycles[2][t2] = (cycles[2][t2] or 0)
******0   if cycles[1][t1] == 1 or cycles[2][t2] == 1 then
******0     thresh1 = cycles[1][t1] + 1
******0     thresh2 = cycles[2][t2] + 1
          end
******0   if cycles[1][t1] > thresh1 and cycles[2][t2] > thresh2 then
******0     return true
          end

******0   cycles[1][t1] = cycles[1][t1] + 1
******0   cycles[2][t2] = cycles[2][t2] + 1

******0   for k1,v1 in next, t1 do
******0     local v2 = t2[k1]
******0     if v2 == nil then
******0       return false, {k1}
            end

******0     local same, crumbs = util.deepcompare(v1,v2,nil,cycles,thresh1,thresh2)
******0     if not same then
******0       crumbs = crumbs or {}
******0       table.insert(crumbs, k1)
******0       return false, crumbs
            end
          end
******0   for k2,_ in next, t2 do
            -- only check whether each element has a t1 counterpart, actual comparison
            -- has been done in first loop above
******0     if t1[k2] == nil then return false, {k2} end
          end

******0   cycles[1][t1] = cycles[1][t1] - 1
******0   cycles[2][t2] = cycles[2][t2] - 1

******0   return true
        end

******0 function util.shallowcopy(t)
******0   if type(t) ~= "table" then return t end
******0   local copy = {}
******0   setmetatable(copy, getmetatable(t))
******0   for k,v in next, t do
******0     copy[k] = v
          end
******0   return copy
        end

******0 function util.deepcopy(t, deepmt, cache)
******0   local spy = require 'luassert.spy'
******0   if type(t) ~= "table" then return t end
******0   local copy = {}

          -- handle recursive tables
******0   local cache = cache or {}
******0   if cache[t] then return cache[t] end
******0   cache[t] = copy

******0   for k,v in next, t do
******0     copy[k] = (spy.is_spy(v) and v or util.deepcopy(v, deepmt, cache))
          end
******0   if deepmt then
******0     debug.setmetatable(copy, util.deepcopy(debug.getmetatable(t), false, cache))
          else
******0     debug.setmetatable(copy, debug.getmetatable(t))
          end
******0   return copy
        end

        -----------------------------------------------
        -- Copies arguments as a list of arguments
        -- @param args the arguments of which to copy
        -- @return the copy of the arguments
******0 function util.copyargs(args)
******0   local copy = {}
******0   setmetatable(copy, getmetatable(args))
******0   local match = require 'luassert.match'
******0   local spy = require 'luassert.spy'
******0   for k,v in pairs(args) do
******0     copy[k] = ((match.is_matcher(v) or spy.is_spy(v)) and v or util.deepcopy(v))
          end
******0   return { vals = copy, refs = util.shallowcopy(args) }
        end

        -----------------------------------------------
        -- Clear an arguments or return values list from a table
        -- @param arglist the table to clear of arguments or return values and their count
        -- @return No return values
******0 function util.cleararglist(arglist)
******0   for idx = arglist.n, 1, -1 do
******0     util.tremove(arglist, idx)
          end
******0   arglist.n = nil
        end

        -----------------------------------------------
        -- Test specs against an arglist in deepcopy and refs flavours.
        -- @param args deepcopy arglist
        -- @param argsrefs refs arglist
        -- @param specs arguments/return values to match against args/argsrefs
        -- @return true if specs match args/argsrefs, false otherwise
        local function matcharg(args, argrefs, specs)
******0   local match = require 'luassert.match'
******0   for idx, argval in pairs(args) do
******0     local spec = specs[idx]
******0     if match.is_matcher(spec) then
******0       if match.is_ref_matcher(spec) then
******0         argval = argrefs[idx]
              end
******0       if not spec(argval) then
******0         return false
              end
******0     elseif (spec == nil or not util.deepcompare(argval, spec)) then
******0       return false
            end
          end

******0   for idx, spec in pairs(specs) do
            -- only check whether each element has an args counterpart,
            -- actual comparison has been done in first loop above
******0     local argval = args[idx]
******0     if argval == nil then
              -- no args counterpart, so try to compare using matcher
******0       if match.is_matcher(spec) then
******0         if not spec(argval) then
******0           return false
                end
              else
******0         return false
              end
            end
          end
******0   return true
        end

        -----------------------------------------------
        -- Find matching arguments/return values in a saved list of
        -- arguments/returned values.
        -- @param invocations_list list of arguments/returned values to search (list of lists)
        -- @param specs arguments/return values to match against argslist
        -- @return the last matching arguments/returned values if a match is found, otherwise nil
******0 function util.matchargs(invocations_list, specs)
          -- Search the arguments/returned values last to first to give the
          -- most helpful answer possible. In the cases where you can place
          -- your assertions between calls to check this gives you the best
          -- information if no calls match. In the cases where you can't do
          -- that there is no good way to predict what would work best.
******0   assert(not util.is_arglist(invocations_list), "expected a list of arglist-object, got an arglist")
******0   for ii = #invocations_list, 1, -1 do
******0     local val = invocations_list[ii]
******0     if matcharg(val.vals, val.refs, specs) then
******0       return val
            end
          end
******0   return nil
        end

        -----------------------------------------------
        -- Find matching oncall for an actual call.
        -- @param oncalls list of oncalls to search
        -- @param args actual call argslist to match against
        -- @return the first matching oncall if a match is found, otherwise nil
******0 function util.matchoncalls(oncalls, args)
******0   for _, callspecs in ipairs(oncalls) do
            -- This lookup is done immediately on *args* passing into the stub
            -- so pass *args* as both *args* and *argsref* without copying
            -- either.
******0     if matcharg(args, args, callspecs.vals) then
******0       return callspecs
            end
          end
******0   return nil
        end

        -----------------------------------------------
        -- table.insert() replacement that respects nil values.
        -- The function will use table field 'n' as indicator of the
        -- table length, if not set, it will be added.
        -- @param t table into which to insert
        -- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!
        -- @param val value to insert
        -- @return No return values
******0 function util.tinsert(...)
          -- check optional POS value
   1486   local args = {...}
   1486   local c = select('#',...)
   1486   local t = args[1]
   1486   local pos = args[2]
   1486   local val = args[3]
   1486   if c < 3 then
******0     val = pos
******0     pos = nil
          end
          -- set length indicator n if not present (+1)
   1486   t.n = (t.n or #t) + 1
   1486   if not pos then
******0     pos = t.n
   1486   elseif pos > t.n then
            -- out of our range
******0     t[pos] = val
******0     t.n = pos
          end
          -- shift everything up 1 pos
   2120   for i = t.n, pos + 1, -1 do
    634     t[i]=t[i-1]
          end
          -- add element to be inserted
   1486   t[pos] = val
        end
        -----------------------------------------------
        -- table.remove() replacement that respects nil values.
        -- The function will use table field 'n' as indicator of the
        -- table length, if not set, it will be added.
        -- @param t table from which to remove
        -- @param pos (optional) position in table to remove
        -- @return No return values
******0 function util.tremove(t, pos)
          -- set length indicator n if not present (+1)
    628   t.n = t.n or #t
    628   if not pos then
******0     pos = t.n
    628   elseif pos > t.n then
******0     local removed = t[pos]
            -- out of our range
******0     t[pos] = nil
******0     return removed
          end
    628   local removed = t[pos]
          -- shift everything up 1 pos
   1256   for i = pos, t.n do
    628     t[i]=t[i+1]
          end
          -- set size, clean last
    628   t[t.n] = nil
    628   t.n = t.n - 1
    628   return removed
        end

        -----------------------------------------------
        -- Checks an element to be callable.
        -- The type must either be a function or have a metatable
        -- containing an '__call' function.
        -- @param object element to inspect on being callable or not
        -- @return boolean, true if the object is callable
******0 function util.callable(object)
******0   return type(object) == "function" or type((debug.getmetatable(object) or {}).__call) == "function"
        end

        -----------------------------------------------
        -- Checks an element has tostring.
        -- The type must either be a string or have a metatable
        -- containing an '__tostring' function.
        -- @param object element to inspect on having tostring or not
        -- @return boolean, true if the object has tostring
******0 function util.hastostring(object)
     12   return type(object) == "string" or type((debug.getmetatable(object) or {}).__tostring) == "function"
        end

        -----------------------------------------------
        -- Find the first level, not defined in the same file as the caller's
        -- code file to properly report an error.
        -- @param level the level to use as the caller's source file
        -- @return number, the level of which to report an error
******0 function util.errorlevel(level)
   1498   local level = (level or 1) + 1 -- add one to get level of the caller
   1498   local info = debug.getinfo(level)
   1498   local source = (info or {}).source
   1498   local file = source
   2996   while file and (file == source or source == "=(tail call)") do
   1498     level = level + 1
   1498     info = debug.getinfo(level)
   1498     source = (info or {}).source
          end
   1498   if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself
   1498   return level
        end

        -----------------------------------------------
        -- Extract modifier and namespace keys from list of tokens.
        -- @param nspace the namespace from which to match tokens
        -- @param tokens list of tokens to search for keys
        -- @return table, list of keys that were extracted
******0 function util.extract_keys(nspace, tokens)
   1486   local namespace = require 'luassert.namespaces'

          -- find valid keys by coalescing tokens as needed, starting from the end
   1486   local keys = {}
   1486   local key = nil
   1486   local i = #tokens
   4610   while i > 0 do
   3124     local token = tokens[i]
   3124     key = key and (token .. '_' .. key) or token

            -- find longest matching key in the given namespace
   3124     local longkey = i > 1 and (tokens[i-1] .. '_' .. key) or nil
   3124     while i > 1 and longkey and namespace[nspace][longkey] do
******0       key = longkey
******0       i = i - 1
******0       token = tokens[i]
******0       longkey = (token .. '_' .. key)
            end

   3124     if namespace.modifier[key] or namespace[nspace][key] then
   3124       table.insert(keys, 1, key)
   3124       key = nil
            end
   3124     i = i - 1
          end

          -- if there's anything left we didn't recognize it
   1486   if key then
******0     error("luassert: unknown modifier/" .. nspace .. ": '" .. key .."'", util.errorlevel(2))
          end

   1486   return keys
        end

        -----------------------------------------------
        -- store argument list for return values of a function in a table.
        -- The table will get a metatable to identify it as an arglist
******0 function util.make_arglist(...)
   1486   local arglist = { ... }
   1486   arglist.n = select('#', ...) -- add values count for trailing nils
   1486   return setmetatable(arglist, arglist_mt)
        end

        -----------------------------------------------
        -- check a table to be an arglist type.
******0 function util.is_arglist(object)
     24   return getmetatable(object) == arglist_mt
        end

******0 return util

==============================================================================
/opt/homebrew/share/lua/5.4/mediator.lua
==============================================================================
        local function getUniqueId(obj)
    204   return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
        end

        local function Subscriber(fn, options)
    204   local sub = {
    204     options = options or {},
    204     fn = fn,
    204     channel = nil,
            update = function(self, options)
******0       if options then
******0         self.fn = options.fn or self.fn
******0         self.options = options.options or self.options
              end
            end
          }
    204   sub.id = getUniqueId(sub)
    204   return sub
        end

        -- Channel class and functions --

        local function Channel(namespace, parent)
    150   return {
    150     stopped = false,
    150     namespace = namespace,
    150     callbacks = {},
    150     channels = {},
    150     parent = parent,

            addSubscriber = function(self, fn, options)
    204       local callback = Subscriber(fn, options)
    204       local priority = (#self.callbacks + 1)

    204       options = options or {}

    204       if options.priority and
    138         options.priority >= 0 and
    138         options.priority < priority
              then
    108           priority = options.priority
              end

    204       table.insert(self.callbacks, priority, callback)

    204       return callback
            end,

            getSubscriber = function(self, id)
******0       for i=1, #self.callbacks do
******0         local callback = self.callbacks[i]
******0         if callback.id == id then return { index = i, value = callback } end
              end
              local sub
******0       for _, channel in pairs(self.channels) do
******0         sub = channel:getSubscriber(id)
******0         if sub then break end
              end
******0       return sub
            end,

            setPriority = function(self, id, priority)
******0       local callback = self:getSubscriber(id)

******0       if callback.value then
******0         table.remove(self.callbacks, callback.index)
******0         table.insert(self.callbacks, priority, callback.value)
              end
            end,

            addChannel = function(self, namespace)
    150       self.channels[namespace] = Channel(namespace, self)
    150       return self.channels[namespace]
            end,

            hasChannel = function(self, namespace)
******0       return namespace and self.channels[namespace] and true
            end,

            getChannel = function(self, namespace)
   8062       return self.channels[namespace] or self:addChannel(namespace)
            end,

            removeSubscriber = function(self, id)
******0       local callback = self:getSubscriber(id)

******0       if callback and callback.value then
******0         for _, channel in pairs(self.channels) do
******0           channel:removeSubscriber(id)
                end

******0         return table.remove(self.callbacks, callback.index)
              end
            end,

            publish = function(self, result, ...)
  18177       for i = 1, #self.callbacks do
  10569         local callback = self.callbacks[i]

                -- if it doesn't have a predicate, or it does and it's true then run it
  10569         if not callback.options.predicate or callback.options.predicate(...) then
                   -- just take the first result and insert it into the result table
  10569           local value, continue = callback.fn(...)

  10569           if value then table.insert(result, value) end
  10569           if not continue then return result end
                end
              end

   7608       if parent then
   5070         return parent:publish(result, ...)
              else
   2538         return result
              end
            end
    150   }
        end

        -- Mediator class and functions --

******0 local Mediator = setmetatable(
        {
          Channel = Channel,
******0   Subscriber = Subscriber
        },
        {
          __call = function (fn, options)
******0     return {
              channel = Channel('root'),

              getChannel = function(self, channelNamespace)
   4049         local channel = self.channel

  12111         for i=1, #channelNamespace do
   8062           channel = channel:getChannel(channelNamespace[i])
                end

   4049         return channel
              end,

              subscribe = function(self, channelNamespace, fn, options)
    204         return self:getChannel(channelNamespace):addSubscriber(fn, options)
              end,

              getSubscriber = function(self, id, channelNamespace)
******0         return self:getChannel(channelNamespace):getSubscriber(id)
              end,

              removeSubscriber = function(self, id, channelNamespace)
******0         return self:getChannel(channelNamespace):removeSubscriber(id)
              end,

              publish = function(self, channelNamespace, ...)
   3845         return self:getChannel(channelNamespace):publish({}, ...)
              end
            }
          end
        })
******0 return Mediator

==============================================================================
/opt/homebrew/share/lua/5.4/pl/List.lua
==============================================================================
        --- Python-style list class.
        --
        -- **Please Note**: methods that change the list will return the list.
        -- This is to allow for method chaining, but please note that `ls = ls:sort()`
        -- does not mean that a new copy of the list is made. In-place (mutable) methods
        -- are marked as returning 'the list' in this documentation.
        --
        -- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
        --
        -- See <a href="http://www.python.org/doc/current/tut/tut.html">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1
        --
        -- **Note**: The comments before some of the functions are from the Python docs
        -- and contain Python code.
        --
        -- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
        --
        -- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`
        -- @classmod pl.List
        -- @pragma nostrip

      5 local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
      5 local setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string
      5 local tablex = require 'pl.tablex'
      5 local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
      5 local tsub = tablex.sub
      5 local utils = require 'pl.utils'
      5 local class = require 'pl.class'

      5 local array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg
      5 local normalize_slice = tablex._normalize_slice

        -- metatable for our list and map objects has already been defined..
      5 local Multimap = utils.stdmt.MultiMap
      5 local List = utils.stdmt.List

        local iter

      5 class(nil,nil,List)

        -- we want the result to be _covariant_, i.e. t must have type of obj if possible
        local function makelist (t,obj)
******0     local klass = List
******0     if obj then
******0         klass = getmetatable(obj)
            end
******0     return setmetatable(t,klass)
        end

        local function simple_table(t)
******0     return type(t) == 'table' and not getmetatable(t) and #t > 0
        end

      5 function List._create (src)
******0     if simple_table(src) then return src end
        end

      5 function List:_init (src)
******0     if self == src then return end -- existing table used as self!
******0     if src then
******0         for v in iter(src) do
******0             tinsert(self,v)
                end
            end
        end

        --- Create a new list. Can optionally pass a table;
        -- passing another instance of List will cause a copy to be created;
        -- this will return a plain table with an appropriate metatable.
        -- we pass anything which isn't a simple table to iterate() to work out
        -- an appropriate iterator
        -- @see List.iterate
        -- @param[opt] t An optional list-like table
        -- @return a new List
        -- @usage ls = List();  ls = List {1,2,3,4}
        -- @function List.new

      5 List.new = List

        --- Make a copy of an existing list.
        -- The difference from a plain 'copy constructor' is that this returns
        -- the actual List subtype.
      5 function List:clone()
******0     local ls = makelist({},self)
******0     ls:extend(self)
******0     return ls
        end

        --- Add an item to the end of the list.
        -- @param i An item
        -- @return the list
      5 function List:append(i)
******0     tinsert(self,i)
******0     return self
        end

      5 List.push = tinsert

        --- Extend the list by appending all the items in the given list.
        -- equivalent to 'a[len(a):] = L'.
        -- @tparam List L Another List
        -- @return the list
      5 function List:extend(L)
******0     assert_arg(1,L,'table')
******0     for i = 1,#L do tinsert(self,L[i]) end
******0     return self
        end

        --- Insert an item at a given position. i is the index of the
        -- element before which to insert.
        -- @int i index of element before whichh to insert
        -- @param x A data item
        -- @return the list
      5 function List:insert(i, x)
******0     assert_arg(1,i,'number')
******0     tinsert(self,i,x)
******0     return self
        end

        --- Insert an item at the beginning of the list.
        -- @param x a data item
        -- @return the list
      5 function List:put (x)
******0     return self:insert(1,x)
        end

        --- Remove an element given its index.
        -- (equivalent of Python's del s[i])
        -- @int i the index
        -- @return the list
      5 function List:remove (i)
******0     assert_arg(1,i,'number')
******0     tremove(self,i)
******0     return self
        end

        --- Remove the first item from the list whose value is given.
        -- (This is called 'remove' in Python; renamed to avoid confusion
        -- with table.remove)
        -- Return nil if there is no such item.
        -- @param x A data value
        -- @return the list
      5 function List:remove_value(x)
******0     for i=1,#self do
******0         if self[i]==x then tremove(self,i) return self end
            end
******0     return self
         end

        --- Remove the item at the given position in the list, and return it.
        -- If no index is specified, a:pop() returns the last item in the list.
        -- The item is also removed from the list.
        -- @int[opt] i An index
        -- @return the item
      5 function List:pop(i)
******0     if not i then i = #self end
******0     assert_arg(1,i,'number')
******0     return tremove(self,i)
        end

      5 List.get = List.pop

        --- Return the index in the list of the first item whose value is given.
        -- Return nil if there is no such item.
        -- @function List:index
        -- @param x A data value
        -- @int[opt=1] idx where to start search
        -- @return the index, or nil if not found.

      5 local tfind = tablex.find
      5 List.index = tfind

        --- Does this list contain the value?
        -- @param x A data value
        -- @return true or false
      5 function List:contains(x)
******0     return tfind(self,x) and true or false
        end

        --- Return the number of times value appears in the list.
        -- @param x A data value
        -- @return number of times x appears
      5 function List:count(x)
******0     local cnt=0
******0     for i=1,#self do
******0         if self[i]==x then cnt=cnt+1 end
            end
******0     return cnt
        end

        --- Sort the items of the list, in place.
        -- @func[opt='<'] cmp an optional comparison function
        -- @return the list
      5 function List:sort(cmp)
******0     if cmp then cmp = function_arg(1,cmp) end
******0     tsort(self,cmp)
******0     return self
        end

        --- Return a sorted copy of this list.
        -- @func[opt='<'] cmp an optional comparison function
        -- @return a new list
      5 function List:sorted(cmp)
******0     return List(self):sort(cmp)
        end

        --- Reverse the elements of the list, in place.
        -- @return the list
      5 function List:reverse()
******0     local t = self
******0     local n = #t
******0     for i = 1,n/2 do
******0         t[i],t[n] = t[n],t[i]
******0         n = n - 1
            end
******0     return self
        end

        --- Return the minimum and the maximum value of the list.
        -- @return minimum value
        -- @return maximum value
      5 function List:minmax()
******0     local vmin,vmax = 1e70,-1e70
******0     for i = 1,#self do
******0         local v = self[i]
******0         if v < vmin then vmin = v end
******0         if v > vmax then vmax = v end
            end
******0     return vmin,vmax
        end

        --- Emulate list slicing.  like  'list[first:last]' in Python.
        -- If first or last are negative then they are relative to the end of the list
        -- eg. slice(-2) gives last 2 entries in a list, and
        -- slice(-4,-2) gives from -4th to -2nd
        -- @param first An index
        -- @param last An index
        -- @return a new List
      5 function List:slice(first,last)
******0     return tsub(self,first,last)
        end

        --- Empty the list.
        -- @return the list
      5 function List:clear()
******0     for i=1,#self do tremove(self) end
******0     return self
        end

      5 local eps = 1.0e-10

        --- Emulate Python's range(x) function.
        -- Include it in List table for tidiness
        -- @int start A number
        -- @int[opt] finish A number greater than start; if absent,
        -- then start is 1 and finish is start
        -- @int[opt=1] incr an increment (may be less than 1)
        -- @return a List from start .. finish
        -- @usage List.range(0,3) == List{0,1,2,3}
        -- @usage List.range(4) = List{1,2,3,4}
        -- @usage List.range(5,1,-1) == List{5,4,3,2,1}
      5 function List.range(start,finish,incr)
******0     if not finish then
******0         finish = start
******0         start = 1
            end
******0     if incr then
******0     assert_arg(3,incr,'number')
******0     if math.ceil(incr) ~= incr then finish = finish + eps end
            else
******0         incr = 1
            end
******0     assert_arg(1,start,'number')
******0     assert_arg(2,finish,'number')
******0     local t = List()
******0     for i=start,finish,incr do tinsert(t,i) end
******0     return t
        end

        --- list:len() is the same as #list.
      5 function List:len()
******0     return #self
        end

        -- Extended operations --

        --- Remove a subrange of elements.
        -- equivalent to 'del s[i1:i2]' in Python.
        -- @int i1 start of range
        -- @int i2 end of range
        -- @return the list
      5 function List:chop(i1,i2)
******0     return tremovevalues(self,i1,i2)
        end

        --- Insert a sublist into a list
        -- equivalent to 's[idx:idx] = list' in Python
        -- @int idx index
        -- @tparam List list list to insert
        -- @return the list
        -- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
      5 function List:splice(idx,list)
******0     assert_arg(1,idx,'number')
******0     idx = idx - 1
******0     local i = 1
******0     for v in iter(list) do
******0         tinsert(self,i+idx,v)
******0         i = i + 1
            end
******0     return self
        end

        --- General slice assignment s[i1:i2] = seq.
        -- @int i1  start index
        -- @int i2  end index
        -- @tparam List seq a list
        -- @return the list
      5 function List:slice_assign(i1,i2,seq)
******0     assert_arg(1,i1,'number')
******0     assert_arg(1,i2,'number')
******0     i1,i2 = normalize_slice(self,i1,i2)
******0     if i2 >= i1 then self:chop(i1,i2) end
******0     self:splice(i1,seq)
******0     return self
        end

        --- Concatenation operator.
        -- @within metamethods
        -- @tparam List L another List
        -- @return a new list consisting of the list with the elements of the new list appended
      5 function List:__concat(L)
******0     assert_arg(1,L,'table')
******0     local ls = self:clone()
******0     ls:extend(L)
******0     return ls
        end

        --- Equality operator ==.  True iff all elements of two lists are equal.
        -- @within metamethods
        -- @tparam List L another List
        -- @return true or false
      5 function List:__eq(L)
******0     if #self ~= #L then return false end
******0     for i = 1,#self do
******0         if self[i] ~= L[i] then return false end
            end
******0     return true
        end

        --- Join the elements of a list using a delimiter.
        -- This method uses tostring on all elements.
        -- @string[opt=''] delim a delimiter string, can be empty.
        -- @return a string
      5 function List:join (delim)
******0     delim = delim or ''
******0     assert_arg(1,delim,'string')
******0     return concat(array_tostring(self),delim)
        end

        --- Join a list of strings. <br>
        -- Uses `table.concat` directly.
        -- @function List:concat
        -- @string[opt=''] delim a delimiter
        -- @return a string
      5 List.concat = concat

        local function tostring_q(val)
******0     local s = tostring(val)
******0     if type(val) == 'string' then
******0         s = '"'..s..'"'
            end
******0     return s
        end

        --- How our list should be rendered as a string. Uses join().
        -- @within metamethods
        -- @see List:join
      5 function List:__tostring()
******0     return '{'..self:join(',',tostring_q)..'}'
        end

        --- Call the function on each element of the list.
        -- @func fun a function or callable object
        -- @param ... optional values to pass to function
      5 function List:foreach (fun,...)
******0     fun = function_arg(1,fun)
******0     for i = 1,#self do
******0         fun(self[i],...)
            end
        end

        local function lookup_fun (obj,name)
******0     local f = obj[name]
******0     if not f then error(type(obj).." does not have method "..name,3) end
******0     return f
        end

        --- Call the named method on each element of the list.
        -- @string name the method name
        -- @param ... optional values to pass to function
      5 function List:foreachm (name,...)
******0     for i = 1,#self do
******0         local obj = self[i]
******0         local f = lookup_fun(obj,name)
******0         f(obj,...)
            end
        end

        --- Create a list of all elements which match a function.
        -- @func fun a boolean function
        -- @param[opt] arg optional argument to be passed as second argument of the predicate
        -- @return a new filtered list.
      5 function List:filter (fun,arg)
******0     return makelist(filter(self,fun,arg),self)
        end

        --- Split a string using a delimiter.
        -- @string s the string
        -- @string[opt] delim the delimiter (default spaces)
        -- @return a List of strings
        -- @see pl.utils.split
      5 function List.split (s,delim)
******0     assert_arg(1,s,'string')
******0     return makelist(split(s,delim))
        end

        --- Apply a function to all elements.
        -- Any extra arguments will be passed to the function.
        -- @func fun a function of at least one argument
        -- @param ... arbitrary extra arguments.
        -- @return a new list: {f(x) for x in self}
        -- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
        -- @see pl.tablex.imap
      5 function List:map (fun,...)
******0     return makelist(imap(fun,self,...),self)
        end

        --- Apply a function to all elements, in-place.
        -- Any extra arguments are passed to the function.
        -- @func fun A function that takes at least one argument
        -- @param ... arbitrary extra arguments.
        -- @return the list.
      5 function List:transform (fun,...)
******0     transform(fun,self,...)
******0     return self
        end

        --- Apply a function to elements of two lists.
        -- Any extra arguments will be passed to the function
        -- @func fun a function of at least two arguments
        -- @tparam List ls another list
        -- @param ... arbitrary extra arguments.
        -- @return a new list: {f(x,y) for x in self, for x in arg1}
        -- @see pl.tablex.imap2
      5 function List:map2 (fun,ls,...)
******0     return makelist(imap2(fun,self,ls,...),self)
        end

        --- apply a named method to all elements.
        -- Any extra arguments will be passed to the method.
        -- @string name name of method
        -- @param ... extra arguments
        -- @return a new list of the results
        -- @see pl.seq.mapmethod
      5 function List:mapm (name,...)
******0     local res = {}
******0     for i = 1,#self do
******0       local val = self[i]
******0       local fn = lookup_fun(val,name)
******0       res[i] = fn(val,...)
            end
******0     return makelist(res,self)
        end

        local function composite_call (method,f)
            return function(self,...)
******0         return self[method](self,f,...)
            end
        end

      5 function List.default_map_with(T)
            return function(self,name)
                local m
******0         if T then
******0             local f = lookup_fun(T,name)
******0             m = composite_call('map',f)
                else
******0             m = composite_call('mapn',name)
                end
******0         getmetatable(self)[name] = m -- and cache..
******0         return m
            end
        end

      5 List.default_map = List.default_map_with

        --- 'reduce' a list using a binary function.
        -- @func fun a function of two arguments
        -- @return result of the function
        -- @see pl.tablex.reduce
      5 function List:reduce (fun)
******0     return reduce(fun,self)
        end

        --- Partition a list using a classifier function.
        -- The function may return nil, but this will be converted to the string key '<nil>'.
        -- @func fun a function of at least one argument
        -- @param ... will also be passed to the function
        -- @treturn MultiMap a table where the keys are the returned values, and the values are Lists
        -- of values where the function returned that key.
        -- @see pl.MultiMap
      5 function List:partition (fun,...)
******0     fun = function_arg(1,fun)
******0     local res = {}
******0     for i = 1,#self do
******0         local val = self[i]
******0         local klass = fun(val,...)
******0         if klass == nil then klass = '<nil>' end
******0         if not res[klass] then res[klass] = List() end
******0         res[klass]:append(val)
            end
******0     return setmetatable(res,Multimap)
        end

        --- return an iterator over all values.
      5 function List:iter ()
******0     return iter(self)
        end

        --- Create an iterator over a sequence.
        -- This captures the Python concept of 'sequence'.
        -- For tables, iterates over all values with integer indices.
        -- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
        -- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55
        -- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p
      5 function List.iterate(seq)
******0     if type(seq) == 'string' then
******0         local idx = 0
******0         local n = #seq
******0         local sub = string.sub
                return function ()
******0             idx = idx + 1
******0             if idx > n then return nil
                    else
******0                 return sub(seq,idx,idx)
                    end
                end
******0     elseif type(seq) == 'table' then
******0         local idx = 0
******0         local n = #seq
                return function()
******0             idx = idx + 1
******0             if idx > n then return nil
                    else
******0                 return seq[idx]
                    end
                end
******0     elseif type(seq) == 'function' then
******0         return seq
******0     elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
******0         return seq:lines()
            end
        end
      5 iter = List.iterate

      5 return List


==============================================================================
/opt/homebrew/share/lua/5.4/pl/class.lua
==============================================================================
        --- Provides a reusable and convenient framework for creating classes in Lua.
        -- Two possible notations:
        --
        --    B = class(A)
        --    class.B(A)
        --
        -- The latter form creates a named class within the current environment. Note
        -- that this implicitly brings in `pl.utils` as a dependency.
        --
        -- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
        -- @module pl.class

        local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
******0     _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
        local compat

        -- this trickery is necessary to prevent the inheritance of 'super' and
        -- the resulting recursive call problems.
        local function call_ctor (c,obj,...)
******0     local init = rawget(c,'_init')
******0     local parent_with_init = rawget(c,'_parent_with_init')

******0     if parent_with_init then
******0         if not init then -- inheriting an init
******0             init = rawget(parent_with_init, '_init')
******0             parent_with_init = rawget(parent_with_init, '_parent_with_init')
                end
******0         if parent_with_init then -- super() points to one above wherever _init came from
******0             rawset(obj,'super',function(obj,...)
******0                 call_ctor(parent_with_init,obj,...)
                    end)
                end
            else
                -- Without this, calling super() where none exists will sometimes loop and stack overflow
******0         rawset(obj,'super',nil)
            end

******0     local res = init(obj,...)
******0     if parent_with_init then -- If this execution of call_ctor set a super, unset it
******0         rawset(obj,'super',nil)
            end

******0     return res
        end

        --- initializes an __instance__ upon creation.
        -- @function class:_init
        -- @param ... parameters passed to the constructor
        -- @usage local Cat = class()
        -- function Cat:_init(name)
        --   --self:super(name)   -- call the ancestor initializer if needed
        --   self.name = name
        -- end
        --
        -- local pussycat = Cat("pussycat")
        -- print(pussycat.name)  --> pussycat

        --- checks whether an __instance__ is derived from some class.
        -- Works the other way around as `class_of`. It has two ways of using;
        -- 1) call with a class to check against, 2) call without params.
        -- @function instance:is_a
        -- @param some_class class to check against, or `nil` to return the class
        -- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then
        -- it returns the class table of the instance
        -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
        -- if pussycat:is_a(Cat) then
        --   -- it's true, it is a Lion, but also a Cat
        -- end
        --
        -- if pussycat:is_a() == Lion then
        --   -- It's true
        -- end
        local function is_a(self,klass)
******0     if klass == nil then
                -- no class provided, so return the class this instance is derived from
******0         return getmetatable(self)
            end
******0     local m = getmetatable(self)
******0     if not m then return false end --*can't be an object!
******0     while m do
******0         if m == klass then return true end
******0         m = rawget(m,'_base')
            end
******0     return false
        end

        --- checks whether an __instance__ is derived from some class.
        -- Works the other way around as `is_a`.
        -- @function some_class:class_of
        -- @param some_instance instance to check against
        -- @return `true` if `some_instance` is derived from `some_class`
        -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
        -- if Cat:class_of(pussycat) then
        --   -- it's true
        -- end
        local function class_of(klass,obj)
******0     if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
******0     return klass.is_a(obj,klass)
        end

        --- cast an object to another class.
        -- It is not clever (or safe!) so use carefully.
        -- @param some_instance the object to be changed
        -- @function some_class:cast
        local function cast (klass, obj)
******0     return setmetatable(obj,klass)
        end


        local function _class_tostring (obj)
******0     local mt = obj._class
******0     local name = rawget(mt,'_name')
******0     setmetatable(obj,nil)
******0     local str = tostring(obj)
******0     setmetatable(obj,mt)
******0     if name then str = name ..str:gsub('table','') end
******0     return str
        end

        local function tupdate(td,ts,dont_override)
******0     for k,v in pairs(ts) do
******0         if not dont_override or td[k] == nil then
******0             td[k] = v
                end
            end
        end

        local function _class(base,c_arg,c)
            -- the class `c` will be the metatable for all its objects,
            -- and they will look up their methods in it.
      5     local mt = {}   -- a metatable for the class to support __call and _handler
            -- can define class by passing it a plain table of methods
      5     local plain = type(base) == 'table' and not getmetatable(base)
      5     if plain then
******0         c = base
******0         base = c._base
            else
      5         c = c or {}
            end

      5     if type(base) == 'table' then
                -- our new class is a shallow copy of the base class!
                -- but be careful not to wipe out any methods we have been given at this point!
******0         tupdate(c,base,plain)
******0         c._base = base
                -- inherit the 'not found' handler, if present
******0         if rawget(c,'_handler') then mt.__index = c._handler end
      5     elseif base ~= nil then
******0         error("must derive from a table type",3)
            end

      5     c.__index = c
      5     setmetatable(c,mt)
      5     if not plain then
      5         if base and rawget(base,'_init') then c._parent_with_init = base end -- For super and inherited init
      5         c._init = nil
            end

      5     if base and rawget(base,'_class_init') then
******0         base._class_init(c,c_arg)
            end

            -- expose a ctor which can be called by <classname>(<args>)
            mt.__call = function(class_tbl,...)
                local obj
******0         if rawget(c,'_create') then obj = c._create(...) end
******0         if not obj then obj = {} end
******0         setmetatable(obj,c)

******0         if rawget(c,'_init') or rawget(c,'_parent_with_init') then -- constructor exists
******0             local res = call_ctor(c,obj,...)
******0             if res then -- _if_ a ctor returns a value, it becomes the object...
******0                 obj = res
******0                 setmetatable(obj,c)
                    end
                end

******0         if base and rawget(base,'_post_init') then
******0             base._post_init(obj)
                end

******0         return obj
            end
            -- Call Class.catch to set a handler for methods/properties not found in the class!
            c.catch = function(self, handler)
******0         if type(self) == "function" then
                    -- called using . instead of :
******0             handler = self
                end
******0         c._handler = handler
******0         mt.__index = handler
            end
      5     c.is_a = is_a
      5     c.class_of = class_of
      5     c.cast = cast
      5     c._class = c

      5     if not rawget(c,'__tostring') then
      5         c.__tostring = _class_tostring
            end

      5     return c
        end

        --- create a new class, derived from a given base class.
        -- Supporting two class creation syntaxes:
        -- either `Name = class(base)` or `class.Name(base)`.
        -- The first form returns the class directly and does not set its `_name`.
        -- The second form creates a variable `Name` in the current environment set
        -- to the class, and also sets `_name`.
        -- @function class
        -- @param base optional base class
        -- @param c_arg optional parameter to class constructor
        -- @param c optional table to be used as class
        local class
******0 class = setmetatable({},{
            __call = function(fun,...)
      5         return _class(...)
            end,
            __index = function(tbl,key)
******0         if key == 'class' then
******0             io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
******0             return class
                end
******0         compat = compat or require 'pl.compat'
******0         local env = compat.getfenv(2)
                return function(...)
******0             local c = _class(...)
******0             c._name = key
******0             rawset(env,key,c)
******0             return c
                end
            end
        })

******0 class.properties = class()

******0 function class.properties._class_init(klass)
            klass.__index = function(t,key)
                -- normal class lookup!
******0         local v = klass[key]
******0         if v then return v end
                -- is it a getter?
******0         v = rawget(klass,'get_'..key)
******0         if v then
******0             return v(t)
                end
                -- is it a field?
******0         return rawget(t,'_'..key)
            end
            klass.__newindex = function (t,key,value)
                -- if there's a setter, use that, otherwise directly set table
******0         local p = 'set_'..key
******0         local setter = klass[p]
******0         if setter then
******0             setter(t,value)
                else
******0             rawset(t,key,value)
                end
            end
        end


******0 return class


==============================================================================
/opt/homebrew/share/lua/5.4/pl/dir.lua
==============================================================================
        --- Listing files in directories and creating/removing directory paths.
        --
        -- Dependencies: `pl.utils`, `pl.path`
        --
        -- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
        -- @module pl.dir

      6 local utils = require 'pl.utils'
      6 local path = require 'pl.path'
      6 local is_windows = path.is_windows
      6 local ldir = path.dir
      6 local mkdir = path.mkdir
      6 local rmdir = path.rmdir
      6 local sub = string.sub
      6 local os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable
      6 local remove = os.remove
      6 local append = table.insert
      6 local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

      6 local exists, isdir = path.exists, path.isdir
      6 local sep = path.sep

      6 local dir = {}

        local function makelist(l)
      5     return setmetatable(l, require('pl.List'))
        end

        local function assert_dir (n,val)
      5     assert_arg(n,val,'string',path.isdir,'not a directory',4)
        end

        local function filemask(mask)
    495     mask = utils.escape(path.normcase(mask))
    495     return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'
        end

        --- Test whether a file name matches a shell pattern.
        -- Both parameters are case-normalized if operating system is
        -- case-insensitive.
        -- @string filename A file name.
        -- @string pattern A shell pattern. The only special characters are
        -- `'*'` and `'?'`: `'*'` matches any sequence of characters and
        -- `'?'` matches any single character.
        -- @treturn bool
        -- @raise dir and mask must be strings
      6 function dir.fnmatch(filename,pattern)
******0     assert_string(1,filename)
******0     assert_string(2,pattern)
******0     return path.normcase(filename):find(filemask(pattern)) ~= nil
        end

        --- Return a list of all file names within an array which match a pattern.
        -- @tab filenames An array containing file names.
        -- @string pattern A shell pattern (see `fnmatch`).
        -- @treturn List(string) List of matching file names.
        -- @raise dir and mask must be strings
      6 function dir.filter(filenames,pattern)
******0     assert_arg(1,filenames,'table')
******0     assert_string(2,pattern)
******0     local res = {}
******0     local mask = filemask(pattern)
******0     for i,f in ipairs(filenames) do
******0         if path.normcase(f):find(mask) then append(res,f) end
            end
******0     return makelist(res)
        end

        local function _listfiles(dirname,filemode,match)
******0     local res = {}
******0     local check = utils.choose(filemode,path.isfile,path.isdir)
******0     if not dirname then dirname = '.' end
******0     for f in ldir(dirname) do
******0         if f ~= '.' and f ~= '..' then
******0             local p = path.join(dirname,f)
******0             if check(p) and (not match or match(f)) then
******0                 append(res,p)
                    end
                end
            end
******0     return makelist(res)
        end

        --- return a list of all files in a directory which match a shell pattern.
        -- @string[opt='.'] dirname A directory.
        -- @string[opt] mask A shell pattern (see `fnmatch`). If not given, all files are returned.
        -- @treturn {string} list of files
        -- @raise dirname and mask must be strings
      6 function dir.getfiles(dirname,mask)
******0     dirname = dirname or '.'
******0     assert_dir(1,dirname)
******0     if mask then assert_string(2,mask) end
            local match
******0     if mask then
******0         mask = filemask(mask)
                match = function(f)
******0             return path.normcase(f):find(mask)
                end
            end
******0     return _listfiles(dirname,true,match)
        end

        --- return a list of all subdirectories of the directory.
        -- @string[opt='.'] dirname A directory.
        -- @treturn {string} a list of directories
        -- @raise dir must be a valid directory
      6 function dir.getdirectories(dirname)
******0     dirname = dirname or '.'
******0     assert_dir(1,dirname)
******0     return _listfiles(dirname,false)
        end

        local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

        local function execute_command(cmd,parms)
******0    if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
******0    local err = path.is_windows and ' > ' or ' 2> '
******0     cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)
******0     local ret = utils.execute(cmd)
******0     if not ret then
******0         local err = (utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
******0         remove(cmd_tmpfile)
******0         return false,err
            else
******0         remove(cmd_tmpfile)
******0         return true
            end
        end

        local function find_ffi_copyfile ()
******0     if not ffi_checked then
******0         ffi_checked = true
                local res
******0         res,alien = pcall(require,'alien')
******0         if not res then
******0             alien = nil
******0             res, ffi = pcall(require,'ffi')
                end
******0         if not res then
******0             ffi = nil
******0             return
                end
            else
******0         return
            end
******0     if alien then
                -- register the Win32 CopyFile and MoveFile functions
******0         local kernel = alien.load('kernel32.dll')
******0         CopyFile = kernel.CopyFileA
******0         CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
******0         MoveFile = kernel.MoveFileA
******0         MoveFile:types{'string','string',ret='int',abi='stdcall'}
******0         GetLastError = kernel.GetLastError
******0         GetLastError:types{ret ='int', abi='stdcall'}
******0     elseif ffi then
******0         ffi.cdef [[
                    int CopyFileA(const char *src, const char *dest, int iovr);
                    int MoveFileA(const char *src, const char *dest);
                    int GetLastError();
******0         ]]
******0         CopyFile = ffi.C.CopyFileA
******0         MoveFile = ffi.C.MoveFileA
******0         GetLastError = ffi.C.GetLastError
            end
******0     win32_errors = {
                ERROR_FILE_NOT_FOUND    =         2,
                ERROR_PATH_NOT_FOUND    =         3,
                ERROR_ACCESS_DENIED    =          5,
                ERROR_WRITE_PROTECT    =          19,
                ERROR_BAD_UNIT         =          20,
                ERROR_NOT_READY        =          21,
                ERROR_WRITE_FAULT      =          29,
                ERROR_READ_FAULT       =          30,
                ERROR_SHARING_VIOLATION =         32,
                ERROR_LOCK_VIOLATION    =         33,
                ERROR_HANDLE_DISK_FULL  =         39,
                ERROR_BAD_NETPATH       =         53,
                ERROR_NETWORK_BUSY      =         54,
                ERROR_DEV_NOT_EXIST     =         55,
                ERROR_FILE_EXISTS       =         80,
                ERROR_OPEN_FAILED       =         110,
                ERROR_INVALID_NAME      =         123,
                ERROR_BAD_PATHNAME      =         161,
                ERROR_ALREADY_EXISTS    =         183,
            }
        end

        local function two_arguments (f1,f2)
******0     return utils.quote_arg(f1)..' '..utils.quote_arg(f2)
        end

        local function file_op (is_copy,src,dest,flag)
******0     if flag == 1 and path.exists(dest) then
******0         return false,"cannot overwrite destination"
            end
******0     if is_windows then
                -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
******0         find_ffi_copyfile()
                -- fallback if there's no Alien, just use DOS commands *shudder*
                -- 'rename' involves a copy and then deleting the source.
******0         if not CopyFile then
******0             if path.is_windows then
******0                 src = src:gsub("/","\\")
******0                 dest = dest:gsub("/","\\")
                    end
******0             local res, err = execute_command('copy',two_arguments(src,dest))
******0             if not res then return false,err end
******0             if not is_copy then
******0                 return execute_command('del',utils.quote_arg(src))
                    end
******0             return true
                else
******0             if path.isdir(dest) then
******0                 dest = path.join(dest,path.basename(src))
                    end
                    local ret
******0             if is_copy then ret = CopyFile(src,dest,flag)
******0             else ret = MoveFile(src,dest) end
******0             if ret == 0 then
******0                 local err = GetLastError()
******0                 for name,value in pairs(win32_errors) do
******0                     if value == err then return false,name end
                        end
******0                 return false,"Error #"..err
******0             else return true
                    end
                end
            else -- for Unix, just use cp for now
******0         return execute_command(is_copy and 'cp' or 'mv',
******0             two_arguments(src,dest))
            end
        end

        --- copy a file.
        -- @string src source file
        -- @string dest destination file or directory
        -- @bool flag true if you want to force the copy (default)
        -- @treturn bool operation succeeded
        -- @raise src and dest must be strings
      6 function dir.copyfile (src,dest,flag)
******0     assert_string(1,src)
******0     assert_string(2,dest)
******0     flag = flag==nil or flag
******0     return file_op(true,src,dest,flag and 0 or 1)
        end

        --- move a file.
        -- @string src source file
        -- @string dest destination file or directory
        -- @treturn bool operation succeeded
        -- @raise src and dest must be strings
      6 function dir.movefile (src,dest)
******0     assert_string(1,src)
******0     assert_string(2,dest)
******0     return file_op(false,src,dest,0)
        end

        local function _dirfiles(dirname,attrib)
******0     local dirs = {}
******0     local files = {}
******0     for f in ldir(dirname) do
******0         if f ~= '.' and f ~= '..' then
******0             local p = path.join(dirname,f)
******0             local mode = attrib(p,'mode')
******0             if mode=='directory' then
******0                 append(dirs,f)
                    else
******0                 append(files,f)
                    end
                end
            end
******0     return makelist(dirs), makelist(files)
        end


        --- return an iterator which walks through a directory tree starting at root.
        -- The iterator returns (root,dirs,files)
        -- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
        -- to get the actual full path)
        -- If bottom_up is false (or not present), then the entries at the current level are returned
        -- before we go deeper. This means that you can modify the returned list of directories before
        -- continuing.
        -- This is a clone of os.walk from the Python libraries.
        -- @string root A starting directory
        -- @bool bottom_up False if we start listing entries immediately.
        -- @bool follow_links follow symbolic links
        -- @return an iterator returning root,dirs,files
        -- @raise root must be a directory
      6 function dir.walk(root,bottom_up,follow_links)
******0     assert_dir(1,root)
            local attrib
******0     if path.is_windows or not follow_links then
******0         attrib = path.attrib
            else
******0         attrib = path.link_attrib
            end

******0     local to_scan = { root }
******0     local to_return = {}
            local iter = function()
******0         while #to_scan > 0 do
******0             local current_root = table.remove(to_scan)
******0             local dirs,files = _dirfiles(current_root, attrib)
******0             for _, d in ipairs(dirs) do
******0                 table.insert(to_scan, current_root..path.sep..d)
                    end
******0             if not bottom_up then
******0                 return current_root, dirs, files
                    else
******0                 table.insert(to_return, { current_root, dirs, files })
                    end
                end
******0         if #to_return > 0 then
******0             return utils.unpack(table.remove(to_return))
                end
            end

******0     return iter
        end

        --- remove a whole directory tree.
        -- Symlinks in the tree will be deleted without following them.
        -- @string fullpath A directory path (must be an actual directory, not a symlink)
        -- @return true or nil
        -- @return error if failed
        -- @raise fullpath must be a string
      6 function dir.rmtree(fullpath)
******0     assert_dir(1,fullpath)
******0     if path.islink(fullpath) then return false,'will not follow symlink' end
******0     for root,dirs,files in dir.walk(fullpath,true) do
******0         if path.islink(root) then
                    -- sub dir is a link, remove link, do not follow
******0             if is_windows then
                        -- Windows requires using "rmdir". Deleting the link like a file
                        -- will instead delete all files from the target directory!!
******0                 local res, err = rmdir(root)
******0                 if not res then return nil,err .. ": " .. root end
                    else
******0                 local res, err = remove(root)
******0                 if not res then return nil,err .. ": " .. root end
                    end
                else
******0             for i,f in ipairs(files) do
******0                 local res, err = remove(path.join(root,f))
******0                 if not res then return nil,err .. ": " .. path.join(root,f) end
                    end
******0             local res, err = rmdir(root)
******0             if not res then return nil,err .. ": " .. root end
                end
            end
******0     return true
        end


        do
          local dirpat
      6   if path.is_windows then
******0       dirpat = '(.+)\\[^\\]+$'
          else
      6       dirpat = '(.+)/[^/]+$'
          end

          local _makepath
      6   function _makepath(p)
              -- windows root drive case
******0       if p:find '^%a:[\\]*$' then
******0           return true
              end
******0       if not path.isdir(p) then
******0           local subp = p:match(dirpat)
******0           if subp then
******0             local ok, err = _makepath(subp)
******0             if not ok then return nil, err end
                  end
******0           return mkdir(p)
              else
******0           return true
              end
          end

          --- create a directory path.
          -- This will create subdirectories as necessary!
          -- @string p A directory path
          -- @return true on success, nil + errormsg on failure
          -- @raise failure to create
      6   function dir.makepath (p)
******0       assert_string(1,p)
******0       if path.is_windows then
******0           p = p:gsub("/", "\\")
              end
******0       return _makepath(path.abspath(p))
          end
        end

        --- clone a directory tree. Will always try to create a new directory structure
        -- if necessary.
        -- @string path1 the base path of the source tree
        -- @string path2 the new base path for the destination
        -- @func file_fun an optional function to apply on all files
        -- @bool verbose an optional boolean to control the verbosity of the output.
        --  It can also be a logging function that behaves like print()
        -- @return true, or nil
        -- @return error message, or list of failed directory creations
        -- @return list of failed file operations
        -- @raise path1 and path2 must be strings
        -- @usage clonetree('.','../backup',copyfile)
      6 function dir.clonetree (path1,path2,file_fun,verbose)
******0     assert_string(1,path1)
******0     assert_string(2,path2)
******0     if verbose == true then verbose = print end
******0     local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
******0     local faildirs,failfiles = {},{}
******0     if not isdir(path1) then return raise 'source is not a valid directory' end
******0     path1 = abspath(normcase(path1))
******0     path2 = abspath(normcase(path2))
******0     if verbose then verbose('normalized:',path1,path2) end
            -- particularly NB that the new path isn't fully contained in the old path
******0     if path1 == path2 then return raise "paths are the same" end
******0     local _,i2 = path2:find(path1,1,true)
******0     if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
******0         return raise 'destination is a subdirectory of the source'
            end
******0     local cp = path.common_prefix (path1,path2)
******0     local idx = #cp
******0     if idx == 0 then -- no common path, but watch out for Windows paths!
******0         if path1:sub(2,2) == ':' then idx = 3 end
            end
******0     for root,dirs,files in dir.walk(path1) do
******0         local opath = path2..root:sub(idx)
******0         if verbose then verbose('paths:',opath,root) end
******0         if not isdir(opath) then
******0             local ret = dir.makepath(opath)
******0             if not ret then append(faildirs,opath) end
******0             if verbose then verbose('creating:',opath,ret) end
                end
******0         if file_fun then
******0             for i,f in ipairs(files) do
******0                 local p1 = join(root,f)
******0                 local p2 = join(opath,f)
******0                 local ret = file_fun(p1,p2)
******0                 if not ret then append(failfiles,p2) end
******0                 if verbose then
******0                     verbose('files:',p1,p2,ret)
                        end
                    end
                end
            end
******0     return true,faildirs,failfiles
        end


        -- each entry of the stack is an array with three items:
        -- 1. the name of the directory
        -- 2. the lfs iterator function
        -- 3. the lfs iterator userdata
        local function treeiter(iterstack)
   1895     local diriter = iterstack[#iterstack]
   1895     if not diriter then
      5       return -- done
            end

   1890     local dirname = diriter[1]
   1890     local entry = diriter[2](diriter[3])
   1890     if not entry then
    350       table.remove(iterstack)
    350       return treeiter(iterstack) -- tail-call to try next
            end

   1540     if entry ~= "." and entry ~= ".." then
    840         entry = dirname .. sep .. entry
    840         if exists(entry) then  -- Just in case a symlink is broken.
    840             local is_dir = isdir(entry)
    840             if is_dir then
    345                 table.insert(iterstack, { entry, ldir(entry) })
                    end
    840             return entry, is_dir
                end
            end

    700     return treeiter(iterstack) -- tail-call to try next
        end


        --- return an iterator over all entries in a directory tree
        -- @string d a directory
        -- @return an iterator giving pathname and mode (true for dir, false otherwise)
        -- @raise d must be a non-empty string
      6 function dir.dirtree( d )
      5     assert( d and d ~= "", "directory parameter is missing or empty" )

      5     local last = sub ( d, -1 )
      5     if last == sep or last == '/' then
      5         d = sub( d, 1, -2 )
            end

      5     local iterstack = { {d, ldir(d)} }

      5     return treeiter, iterstack
        end


        --- Recursively returns all the file starting at 'path'. It can optionally take a shell pattern and
        -- only returns files that match 'shell_pattern'. If a pattern is given it will do a case insensitive search.
        -- @string[opt='.'] start_path  A directory.
        -- @string[opt='*'] shell_pattern A shell pattern (see `fnmatch`).
        -- @treturn List(string) containing all the files found recursively starting at 'path' and filtered by 'shell_pattern'.
        -- @raise start_path must be a directory
      6 function dir.getallfiles( start_path, shell_pattern )
      5     start_path = start_path or '.'
      5     assert_dir(1,start_path)
      5     shell_pattern = shell_pattern or "*"

      5     local files = {}
      5     local normcase = path.normcase
    845     for filename, mode in dir.dirtree( start_path ) do
    840         if not mode then
    495             local mask = filemask( shell_pattern )
    495             if normcase(filename):find( mask ) then
    495                 files[#files + 1] = filename
                    end
                end
            end

      5     return makelist(files)
        end

      6 return dir

==============================================================================
/opt/homebrew/share/lua/5.4/pl/path.lua
==============================================================================
        --- Path manipulation and file queries.
        --
        -- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
        --
        -- NOTE: the functions assume the paths being dealt with to originate
        -- from the OS the application is running on. Windows drive letters are not
        -- to be used when running on a Unix system for example. The one exception
        -- is Windows paths to allow both forward and backward slashes (since Lua
        -- also accepts those)
        --
        -- Dependencies: `pl.utils`, `lfs`
        -- @module pl.path

        -- imports and locals
******0 local _G = _G
******0 local sub = string.sub
******0 local getenv = os.getenv
******0 local tmpnam = os.tmpname
******0 local package = package
******0 local append, concat, remove = table.insert, table.concat, table.remove
******0 local utils = require 'pl.utils'
******0 local assert_string,raise = utils.assert_string,utils.raise

******0 local res,lfs = _G.pcall(_G.require,'lfs')
******0 if not res then
******0     error("pl.path requires LuaFileSystem")
        end

******0 local attrib = lfs.attributes
******0 local currentdir = lfs.currentdir
******0 local link_attrib = lfs.symlinkattributes

******0 local path = {}

        local function err_func(name, param, err, code)
******0   local ret = ("%s failed"):format(tostring(name))
******0   if param ~= nil then
******0     ret = ret .. (" for '%s'"):format(tostring(param))
          end
******0   ret = ret .. (": %s"):format(tostring(err))
******0   if code ~= nil then
******0     ret = ret .. (" (code %s)"):format(tostring(code))
          end
******0   return ret
        end

        --- Lua iterator over the entries of a given directory.
        -- Implicit link to [`luafilesystem.dir`](https://lunarmodules.github.io/luafilesystem/manual.html#dir)
        -- @function dir
******0 path.dir = lfs.dir

        --- Creates a directory.
        -- Implicit link to [`luafilesystem.mkdir`](https://lunarmodules.github.io/luafilesystem/manual.html#mkdir)
        -- @function mkdir
        path.mkdir = function(d)
******0   local ok, err, code = lfs.mkdir(d)
******0   if not ok then
******0     return ok, err_func("mkdir", d, err, code), code
          end
******0   return ok, err, code
        end

        --- Removes a directory.
        -- Implicit link to [`luafilesystem.rmdir`](https://lunarmodules.github.io/luafilesystem/manual.html#rmdir)
        -- @function rmdir
        path.rmdir = function(d)
******0   local ok, err, code = lfs.rmdir(d)
******0   if not ok then
******0     return ok, err_func("rmdir", d, err, code), code
          end
******0   return ok, err, code
        end

        --- Gets attributes.
        -- Implicit link to [`luafilesystem.attributes`](https://lunarmodules.github.io/luafilesystem/manual.html#attributes)
        -- @function attrib
        path.attrib = function(d, r)
******0   local ok, err, code = attrib(d, r)
******0   if not ok then
******0     return ok, err_func("attrib", d, err, code), code
          end
******0   return ok, err, code
        end

        --- Get the working directory.
        -- Implicit link to [`luafilesystem.currentdir`](https://lunarmodules.github.io/luafilesystem/manual.html#currentdir)
        -- @function currentdir
        path.currentdir = function()
******0   local ok, err, code = currentdir()
******0   if not ok then
******0     return ok, err_func("currentdir", nil, err, code), code
          end
******0   return ok, err, code
        end

        --- Gets symlink attributes.
        -- Implicit link to [`luafilesystem.symlinkattributes`](https://lunarmodules.github.io/luafilesystem/manual.html#symlinkattributes)
        -- @function link_attrib
        path.link_attrib = function(d, r)
******0   local ok, err, code = link_attrib(d, r)
******0   if not ok then
******0     return ok, err_func("link_attrib", d, err, code), code
          end
******0   return ok, err, code
        end

        --- Changes the working directory.
        -- On Windows, if a drive is specified, it also changes the current drive. If
        -- only specifying the drive, it will only switch drive, but not modify the path.
        -- Implicit link to [`luafilesystem.chdir`](https://lunarmodules.github.io/luafilesystem/manual.html#chdir)
        -- @function chdir
        path.chdir = function(d)
******0   local ok, err, code = lfs.chdir(d)
******0   if not ok then
******0     return ok, err_func("chdir", d, err, code), code
          end
******0   return ok, err, code
        end

        --- is this a directory?
        -- @string P A file path
******0 function path.isdir(P)
    850     assert_string(1,P)
    850     return attrib(P,'mode') == 'directory'
        end

        --- is this a file?
        -- @string P A file path
******0 function path.isfile(P)
      6     assert_string(1,P)
      6     return attrib(P,'mode') == 'file'
        end

        -- is this a symbolic link?
        -- @string P A file path
******0 function path.islink(P)
******0     assert_string(1,P)
******0     if link_attrib then
******0         return link_attrib(P,'mode')=='link'
            else
******0         return false
            end
        end

        --- return size of a file.
        -- @string P A file path
******0 function path.getsize(P)
******0     assert_string(1,P)
******0     return attrib(P,'size')
        end

        --- does a path exist?
        -- @string P A file path
        -- @return the file path if it exists (either as file, directory, socket, etc), false otherwise
******0 function path.exists(P)
    840     assert_string(1,P)
    840     return attrib(P,'mode') ~= nil and P
        end

        --- Return the time of last access as the number of seconds since the epoch.
        -- @string P A file path
******0 function path.getatime(P)
******0     assert_string(1,P)
******0     return attrib(P,'access')
        end

        --- Return the time of last modification as the number of seconds since the epoch.
        -- @string P A file path
******0 function path.getmtime(P)
******0     assert_string(1,P)
******0     return attrib(P,'modification')
        end

        ---Return the system's ctime as the number of seconds since the epoch.
        -- @string P A file path
******0 function path.getctime(P)
******0     assert_string(1,P)
******0     return path.attrib(P,'change')
        end


        local function at(s,i)
  53428     return sub(s,i,i)
        end

******0 path.is_windows = utils.is_windows

        local sep, other_sep, seps
        -- constant sep is the directory separator for this platform.
        -- constant dirsep is the separator in the PATH environment variable
******0 if path.is_windows then
******0     path.sep = '\\'; other_sep = '/'
******0     path.dirsep = ';'
******0     seps = { ['/'] = true, ['\\'] = true }
        else
******0     path.sep = '/'
******0     path.dirsep = ':'
******0     seps = { ['/'] = true }
        end
******0 sep = path.sep

        --- are we running Windows?
        -- @class field
        -- @name path.is_windows

        --- path separator for this platform.
        -- @class field
        -- @name path.sep

        --- separator for PATH for this platform
        -- @class field
        -- @name path.dirsep

        --- given a path, return the directory part and a file part.
        -- if there's no directory part, the first value will be empty
        -- @string P A file path
        -- @return directory part
        -- @return file part
        -- @usage
        -- local dir, file = path.splitpath("some/dir/myfile.txt")
        -- assert(dir == "some/dir")
        -- assert(file == "myfile.txt")
        --
        -- local dir, file = path.splitpath("some/dir/")
        -- assert(dir == "some/dir")
        -- assert(file == "")
        --
        -- local dir, file = path.splitpath("some_dir")
        -- assert(dir == "")
        -- assert(file == "some_dir")
******0 function path.splitpath(P)
   3141     assert_string(1,P)
   3141     local i = #P
   3141     local ch = at(P,i)
  53390     while i > 0 and ch ~= sep and ch ~= other_sep do
  50249         i = i - 1
  50249         ch = at(P,i)
            end
   3141     if i == 0 then
******0         return '',P
            else
   3141         return sub(P,1,i-1), sub(P,i+1)
            end
        end

        --- return an absolute path.
        -- @string P A file path
        -- @string[opt] pwd optional start path to use (default is current dir)
******0 function path.abspath(P,pwd)
******0     assert_string(1,P)
******0     local use_pwd = pwd ~= nil
******0     if use_pwd then assert_string(2,pwd) end
******0     if not use_pwd and not currentdir() then return P end
******0     P = P:gsub('[\\/]$','')
******0     pwd = pwd or currentdir()
******0     if not path.isabs(P) then
******0         P = path.join(pwd,P)
******0     elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
******0         P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
            end
******0     return path.normpath(P)
        end

        --- given a path, return the root part and the extension part.
        -- if there's no extension part, the second value will be empty
        -- @string P A file path
        -- @treturn string root part (everything upto the "."", maybe empty)
        -- @treturn string extension part (including the ".", maybe empty)
        -- @usage
        -- local file_path, ext = path.splitext("/bonzo/dog_stuff/cat.txt")
        -- assert(file_path == "/bonzo/dog_stuff/cat")
        -- assert(ext == ".txt")
        --
        -- local file_path, ext = path.splitext("")
        -- assert(file_path == "")
        -- assert(ext == "")
******0 function path.splitext(P)
      8     assert_string(1,P)
      8     local i = #P
      8     local ch = at(P,i)
     32     while i > 0 and ch ~= '.' do
     24         if seps[ch] then
******0             return P,''
                end
     24         i = i - 1
     24         ch = at(P,i)
            end
      8     if i == 0 then
******0         return P,''
            else
      8         return sub(P,1,i-1),sub(P,i)
            end
        end

        --- return the directory part of a path
        -- @string P A file path
        -- @treturn string everything before the last dir-separator
        -- @see splitpath
        -- @usage
        -- path.dirname("/some/path/file.txt")   -- "/some/path"
        -- path.dirname("file.txt")              -- "" (empty string)
******0 function path.dirname(P)
   2646     assert_string(1,P)
   2646     local p1 = path.splitpath(P)
   2646     return p1
        end

        --- return the file part of a path
        -- @string P A file path
        -- @treturn string
        -- @see splitpath
        -- @usage
        -- path.basename("/some/path/file.txt")  -- "file.txt"
        -- path.basename("/some/path/file/")     -- "" (empty string)
******0 function path.basename(P)
    495     assert_string(1,P)
    495     local _,p2 = path.splitpath(P)
    495     return p2
        end

        --- get the extension part of a path.
        -- @string P A file path
        -- @treturn string
        -- @see splitext
        -- @usage
        -- path.extension("/some/path/file.txt") -- ".txt"
        -- path.extension("/some/path/file_txt") -- "" (empty string)
******0 function path.extension(P)
      8     assert_string(1,P)
      8     local _,p2 = path.splitext(P)
      8     return p2
        end

        --- is this an absolute path?
        -- @string P A file path
        -- @usage
        -- path.isabs("hello/path")    -- false
        -- path.isabs("/hello/path")   -- true
        -- -- Windows;
        -- path.isabs("hello\path")    -- false
        -- path.isabs("\hello\path")   -- true
        -- path.isabs("C:\hello\path") -- true
        -- path.isabs("C:hello\path")  -- false
******0 function path.isabs(P)
******0     assert_string(1,P)
******0     if path.is_windows and at(P,2) == ":" then
******0         return seps[at(P,3)] ~= nil
            end
******0     return seps[at(P,1)] ~= nil
        end

        --- return the path resulting from combining the individual paths.
        -- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
        -- empty elements (except the last) will be ignored.
        -- @string p1 A file path
        -- @string p2 A file path
        -- @string ... more file paths
        -- @treturn string the combined path
        -- @usage
        -- path.join("/first","second","third")   -- "/first/second/third"
        -- path.join("first","second/third")      -- "first/second/third"
        -- path.join("/first","/second","third")  -- "/second/third"
******0 function path.join(p1,p2,...)
******0     assert_string(1,p1)
******0     assert_string(2,p2)
******0     if select('#',...) > 0 then
******0         local p = path.join(p1,p2)
******0         local args = {...}
******0         for i = 1,#args do
******0             assert_string(i,args[i])
******0             p = path.join(p,args[i])
                end
******0         return p
            end
******0     if path.isabs(p2) then return p2 end
******0     local endc = at(p1,#p1)
******0     if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
******0         p1 = p1..path.sep
            end
******0     return p1..p2
        end

        --- normalize the case of a pathname. On Unix, this returns the path unchanged,
        -- for Windows it converts;
        --
        -- * the path to lowercase
        -- * forward slashes to backward slashes
        -- @string P A file path
        -- @usage path.normcase("/Some/Path/File.txt")
        -- -- Windows: "\some\path\file.txt"
        -- -- Others : "/Some/Path/File.txt"
******0 function path.normcase(P)
    990     assert_string(1,P)
    990     if path.is_windows then
******0         return P:gsub('/','\\'):lower()
            else
    990         return P
            end
        end

        --- normalize a path name.
        -- `A//B`, `A/./B`, and `A/foo/../B` all become `A/B`.
        --
        -- An empty path results in '.'.
        -- @string P a file path
******0 function path.normpath(P)
      6     assert_string(1,P)
            -- Split path into anchor and relative path.
      6     local anchor = ''
      6     if path.is_windows then
******0         if P:match '^\\\\' then -- UNC
******0             anchor = '\\\\'
******0             P = P:sub(3)
******0         elseif seps[at(P, 1)] then
******0             anchor = '\\'
******0             P = P:sub(2)
******0         elseif at(P, 2) == ':' then
******0             anchor = P:sub(1, 2)
******0             P = P:sub(3)
******0             if seps[at(P, 1)] then
******0                 anchor = anchor..'\\'
******0                 P = P:sub(2)
                    end
                end
******0         P = P:gsub('/','\\')
            else
                -- According to POSIX, in path start '//' and '/' are distinct,
                -- but '///+' is equivalent to '/'.
      6         if P:match '^//' and at(P, 3) ~= '/' then
******0             anchor = '//'
******0             P = P:sub(3)
      6         elseif at(P, 1) == '/' then
******0             anchor = '/'
******0             P = P:match '^/*(.*)$'
                end
            end
      6     local parts = {}
     18     for part in P:gmatch('[^'..sep..']+') do
     12         if part == '..' then
******0             if #parts ~= 0 and parts[#parts] ~= '..' then
******0                 remove(parts)
                    else
******0                 append(parts, part)
                    end
     12         elseif part ~= '.' then
     12             append(parts, part)
                end
            end
      6     P = anchor..concat(parts, sep)
      6     if P == '' then P = '.' end
      6     return P
        end

        --- relative path from current directory or optional start point
        -- @string P a path
        -- @string[opt] start optional start point (default current directory)
******0 function path.relpath (P,start)
******0     assert_string(1,P)
******0     if start then assert_string(2,start) end
******0     local split,min,append = utils.split, math.min, table.insert
******0     P = path.abspath(P,start)
******0     start = start or currentdir()
            local compare
******0     if path.is_windows then
******0         P = P:gsub("/","\\")
******0         start = start:gsub("/","\\")
******0         compare = function(v) return v:lower() end
            else
******0         compare = function(v) return v end
            end
******0     local startl, Pl = split(start,sep), split(P,sep)
******0     local n = min(#startl,#Pl)
******0     if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then
******0         return P
            end
******0     local k = n+1 -- default value if this loop doesn't bail out!
******0     for i = 1,n do
******0         if compare(startl[i]) ~= compare(Pl[i]) then
******0             k = i
                    break
                end
            end
******0     local rell = {}
******0     for i = 1, #startl-k+1 do rell[i] = '..' end
******0     if k <= #Pl then
******0         for i = k,#Pl do append(rell,Pl[i]) end
            end
******0     return table.concat(rell,sep)
        end


        --- Replace a starting '~' with the user's home directory.
        -- In windows, if HOME isn't set, then USERPROFILE is used in preference to
        -- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
        -- @string P A file path
        -- @treturn[1] string The file path with the `~` prefix substituted, or the input path if it had no prefix.
        -- @treturn[2] nil
        -- @treturn[2] string Error message if the environment variables were unavailable.
******0 function path.expanduser(P)
******0     assert_string(1,P)
******0     if P:sub(1,1) ~= '~' then
******0         return P
            end

******0     local home = getenv('HOME')
******0     if (not home) and (not path.is_windows) then
                -- no more options to try on Nix
******0         return nil, "failed to expand '~' (HOME not set)"
            end

******0     if (not home) then
                -- try alternatives on Windows
******0         home = getenv 'USERPROFILE'
******0         if not home then
******0             local hd = getenv 'HOMEDRIVE'
******0             local hp = getenv 'HOMEPATH'
******0             if not (hd and hp) then
******0               return nil, "failed to expand '~' (HOME, USERPROFILE, and HOMEDRIVE and/or HOMEPATH not set)"
                    end
******0             home = hd..hp
                end
            end

******0     return home..sub(P,2)
        end


        ---Return a suitable full path to a new temporary file name.
        -- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)
******0 function path.tmpname ()
******0     local res = tmpnam()
            -- On Windows if Lua is compiled using MSVC14 os.tmpname
            -- already returns an absolute path within TEMP env variable directory,
            -- no need to prepend it.
******0     if path.is_windows and not res:find(':') then
******0         res = getenv('TEMP')..res
            end
******0     return res
        end

        --- return the largest common prefix path of two paths.
        -- @string path1 a file path
        -- @string path2 a file path
        -- @return the common prefix (Windows: separators will be normalized, casing will be original)
******0 function path.common_prefix (path1,path2)
******0     assert_string(1,path1)
******0     assert_string(2,path2)
            -- get them in order!
******0     if #path1 > #path2 then path2,path1 = path1,path2 end
            local compare
******0     if path.is_windows then
******0         path1 = path1:gsub("/", "\\")
******0         path2 = path2:gsub("/", "\\")
******0         compare = function(v) return v:lower() end
            else
******0         compare = function(v) return v end
            end
******0     for i = 1,#path1 do
******0         if compare(at(path1,i)) ~= compare(at(path2,i)) then
******0             local cp = path1:sub(1,i-1)
******0             if at(path1,i-1) ~= sep then
******0                 cp = path.dirname(cp)
                    end
******0             return cp
                end
            end
******0     if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
******0     return path1
            --return ''
        end

        --- return the full path where a particular Lua module would be found.
        -- Both package.path and package.cpath is searched, so the result may
        -- either be a Lua file or a shared library.
        -- @string mod name of the module
        -- @return on success: path of module, lua or binary
        -- @return on error: nil, error string listing paths tried
******0 function path.package_path(mod)
******0     assert_string(1,mod)
            local res, err1, err2
******0     res, err1 = package.searchpath(mod,package.path)
******0     if res then return res,true end
******0     res, err2 = package.searchpath(mod,package.cpath)
******0     if res then return res,false end
******0     return raise ('cannot find module on path\n' .. err1 .. "\n" .. err2)
        end


        ---- finis -----
******0 return path

==============================================================================
/opt/homebrew/share/lua/5.4/pl/tablex.lua
==============================================================================
        --- Extended operations on Lua tables.
        --
        -- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
        --
        -- Dependencies: `pl.utils`, `pl.types`
        -- @module pl.tablex
******0 local utils = require ('pl.utils')
******0 local types = require ('pl.types')
******0 local getmetatable,setmetatable,require = getmetatable,setmetatable,require
******0 local tsort,append,remove = table.sort,table.insert,table.remove
******0 local min = math.min
******0 local pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring
******0 local function_arg = utils.function_arg
******0 local assert_arg = utils.assert_arg

******0 local tablex = {}

        -- generally, functions that make copies of tables try to preserve the metatable.
        -- However, when the source has no obvious type, then we attach appropriate metatables
        -- like List, Map, etc to the result.
        local function setmeta (res,tbl,pl_class)
     10     local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)
     10     return mt and setmetatable(res, mt) or res
        end

        local function makelist(l)
******0     return setmetatable(l, require('pl.List'))
        end

        local function makemap(m)
******0     return setmetatable(m, require('pl.Map'))
        end

        local function complain (idx,msg)
******0     error(('argument %d is not %s'):format(idx,msg),3)
        end

        local function assert_arg_indexable (idx,val)
     10     if not types.is_indexable(val) then
******0         complain(idx,"indexable")
            end
        end

        local function assert_arg_iterable (idx,val)
     14     if not types.is_iterable(val) then
******0         complain(idx,"iterable")
            end
        end

        local function assert_arg_writeable (idx,val)
******0     if not types.is_writeable(val) then
******0         complain(idx,"writeable")
            end
        end

        --- copy a table into another, in-place.
        -- @within Copying
        -- @tab t1 destination table
        -- @tab t2 source (actually any iterable object)
        -- @return first table
******0 function tablex.update (t1,t2)
******0     assert_arg_writeable(1,t1)
******0     assert_arg_iterable(2,t2)
******0     for k,v in pairs(t2) do
******0         t1[k] = v
            end
******0     return t1
        end

        --- total number of elements in this table.
        -- Note that this is distinct from `#t`, which is the number
        -- of values in the array part; this value will always
        -- be greater or equal. The difference gives the size of
        -- the hash part, for practical purposes. Works for any
        -- object with a __pairs metamethod.
        -- @tab t a table
        -- @return the size
******0 function tablex.size (t)
******0     assert_arg_iterable(1,t)
******0     local i = 0
******0     for k in pairs(t) do i = i + 1 end
******0     return i
        end

        --- make a shallow copy of a table
        -- @within Copying
        -- @tab t an iterable source
        -- @return new table
******0 function tablex.copy (t)
     14     assert_arg_iterable(1,t)
     14     local res = {}
    781     for k,v in pairs(t) do
    767         res[k] = v
            end
     14     return res
        end

        local function cycle_aware_copy(t, cache)
******0     if type(t) ~= 'table' then return t end
******0     if cache[t] then return cache[t] end
******0     assert_arg_iterable(1,t)
******0     local res = {}
******0     cache[t] = res
******0     local mt = getmetatable(t)
******0     for k,v in pairs(t) do
******0         res[cycle_aware_copy(k, cache)] = cycle_aware_copy(v, cache)
            end
******0     setmetatable(res,mt)
******0     return res
        end

        --- make a deep copy of a table, recursively copying all the keys and fields.
        -- This supports cycles in tables; cycles will be reproduced in the copy.
        -- This will also set the copied table's metatable to that of the original.
        -- @within Copying
        -- @tab t A table
        -- @return new table
******0 function tablex.deepcopy(t)
******0     return cycle_aware_copy(t,{})
        end

******0 local abs = math.abs

        local function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)
******0     if cache[t1] and cache[t1][t2] then return true end
******0     local ty1 = type(t1)
******0     local ty2 = type(t2)
******0     if ty1 ~= ty2 then return false end
            -- non-table types can be directly compared
******0     if ty1 ~= 'table' then
******0         if ty1 == 'number' and eps then return abs(t1-t2) < eps end
******0         return t1 == t2
            end
            -- as well as tables which have the metamethod __eq
******0     local mt = getmetatable(t1)
******0     if not ignore_mt and mt and mt.__eq then return t1 == t2 end
******0     for k1 in pairs(t1) do
******0         if t2[k1]==nil then return false end
            end
******0     for k2 in pairs(t2) do
******0         if t1[k2]==nil then return false end
            end
******0     cache[t1] = cache[t1] or {}
******0     cache[t1][t2] = true
******0     for k1,v1 in pairs(t1) do
******0         local v2 = t2[k1]
******0         if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end
            end
******0     return true
        end

        --- compare two values.
        -- if they are tables, then compare their keys and fields recursively.
        -- @within Comparing
        -- @param t1 A value
        -- @param t2 A value
        -- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
        -- @number[opt] eps if defined, then used for any number comparisons
        -- @return true or false
******0 function tablex.deepcompare(t1,t2,ignore_mt,eps)
******0     return cycle_aware_compare(t1,t2,ignore_mt,eps,{})
        end

        --- compare two arrays using a predicate.
        -- @within Comparing
        -- @array t1 an array
        -- @array t2 an array
        -- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`
        -- @return true or false
        -- @usage
        -- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, "=="))
        --
        -- assert(tablex.compare(
        --    {1,2,3, hello = "world"},  -- fields are not compared!
        --    {1,2,3}, function(v1, v2) return v1 == v2 end)
******0 function tablex.compare (t1,t2,cmp)
******0     assert_arg_indexable(1,t1)
******0     assert_arg_indexable(2,t2)
******0     if #t1 ~= #t2 then return false end
******0     cmp = function_arg(3,cmp)
******0     for k = 1,#t1 do
******0         if not cmp(t1[k],t2[k]) then return false end
            end
******0     return true
        end

        --- compare two list-like tables using an optional predicate, without regard for element order.
        -- @within Comparing
        -- @array t1 a list-like table
        -- @array t2 a list-like table
        -- @param cmp A comparison function (may be nil)
******0 function tablex.compare_no_order (t1,t2,cmp)
******0     assert_arg_indexable(1,t1)
******0     assert_arg_indexable(2,t2)
******0     if cmp then cmp = function_arg(3,cmp) end
******0     if #t1 ~= #t2 then return false end
******0     local visited = {}
******0     for i = 1,#t1 do
******0         local val = t1[i]
                local gotcha
******0         for j = 1,#t2 do
******0             if not visited[j] then
                        local match
******0                 if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
******0                 if match then
******0                     gotcha = j
                            break
                        end
                    end
                end
******0         if not gotcha then return false end
******0         visited[gotcha] = true
            end
******0     return true
        end


        --- return the index of a value in a list.
        -- Like string.find, there is an optional index to start searching,
        -- which can be negative.
        -- @within Finding
        -- @array t A list-like table
        -- @param val A value
        -- @int idx index to start; -1 means last element,etc (default 1)
        -- @return index of value or nil if not found
        -- @usage find({10,20,30},20) == 2
        -- @usage find({'a','b','a','c'},'a',2) == 3
******0 function tablex.find(t,val,idx)
******0     assert_arg_indexable(1,t)
******0     idx = idx or 1
******0     if idx < 0 then idx = #t + idx + 1 end
******0     for i = idx,#t do
******0         if t[i] == val then return i end
            end
******0     return nil
        end

        --- return the index of a value in a list, searching from the end.
        -- Like string.find, there is an optional index to start searching,
        -- which can be negative.
        -- @within Finding
        -- @array t A list-like table
        -- @param val A value
        -- @param idx index to start; -1 means last element,etc (default `#t`)
        -- @return index of value or nil if not found
        -- @usage rfind({10,10,10},10) == 3
******0 function tablex.rfind(t,val,idx)
******0     assert_arg_indexable(1,t)
******0     idx = idx or #t
******0     if idx < 0 then idx = #t + idx + 1 end
******0     for i = idx,1,-1 do
******0         if t[i] == val then return i end
            end
******0     return nil
        end


        --- return the index (or key) of a value in a table using a comparison function.
        --
        -- *NOTE*: the 2nd return value of this function, the value returned
        -- by the comparison function, has a limitation that it cannot be `false`.
        -- Because if it is, then it indicates the comparison failed, and the
        -- function will continue the search. See examples.
        -- @within Finding
        -- @tab t A table
        -- @func cmp A comparison function
        -- @param arg an optional second argument to the function
        -- @return index of value, or nil if not found
        -- @return value returned by comparison function (cannot be `false`!)
        -- @usage
        -- -- using an operator
        -- local lst = { "Rudolph", true, false, 15 }
        -- local idx, cmp_result = tablex.rfind(lst, "==", "Rudolph")
        -- assert(idx == 1)
        -- assert(cmp_result == true)
        --
        -- local idx, cmp_result = tablex.rfind(lst, "==", false)
        -- assert(idx == 3)
        -- assert(cmp_result == true)       -- looking up 'false' works!
        --
        -- -- using a function returning the value looked up
        -- local cmp = function(v1, v2) return v1 == v2 and v2 end
        -- local idx, cmp_result = tablex.rfind(lst, cmp, "Rudolph")
        -- assert(idx == 1)
        -- assert(cmp_result == "Rudolph")  -- the value is returned
        --
        -- -- NOTE: this fails, since 'false' cannot be returned!
        -- local idx, cmp_result = tablex.rfind(lst, cmp, false)
        -- assert(idx == nil)               -- looking up 'false' failed!
        -- assert(cmp_result == nil)
******0 function tablex.find_if(t,cmp,arg)
******0     assert_arg_iterable(1,t)
******0     cmp = function_arg(2,cmp)
******0     for k,v in pairs(t) do
******0         local c = cmp(v,arg)
******0         if c then return k,c end
            end
******0     return nil
        end

        --- return a list of all values in a table indexed by another list.
        -- @tab tbl a table
        -- @array idx an index table (a list of keys)
        -- @return a list-like table
        -- @usage index_by({10,20,30,40},{2,4}) == {20,40}
        -- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
******0 function tablex.index_by(tbl,idx)
******0     assert_arg_indexable(1,tbl)
******0     assert_arg_indexable(2,idx)
******0     local res = {}
******0     for i = 1,#idx do
******0         res[i] = tbl[idx[i]]
            end
******0     return setmeta(res,tbl,'List')
        end

        --- apply a function to all values of a table.
        -- This returns a table of the results.
        -- Any extra arguments are passed to the function.
        -- @within MappingAndFiltering
        -- @func fun A function that takes at least one argument
        -- @tab t A table
        -- @param ... optional arguments
        -- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
******0 function tablex.map(fun,t,...)
******0     assert_arg_iterable(1,t)
******0     fun = function_arg(1,fun)
******0     local res = {}
******0     for k,v in pairs(t) do
******0         res[k] = fun(v,...)
            end
******0     return setmeta(res,t)
        end

        --- apply a function to all values of a list.
        -- This returns a table of the results.
        -- Any extra arguments are passed to the function.
        -- @within MappingAndFiltering
        -- @func fun A function that takes at least one argument
        -- @array t a table (applies to array part)
        -- @param ... optional arguments
        -- @return a list-like table
        -- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
******0 function tablex.imap(fun,t,...)
******0     assert_arg_indexable(1,t)
******0     fun = function_arg(1,fun)
******0     local res = {}
******0     for i = 1,#t do
******0         res[i] = fun(t[i],...) or false
            end
******0     return setmeta(res,t,'List')
        end

        --- apply a named method to values from a table.
        -- @within MappingAndFiltering
        -- @string name the method name
        -- @array t a list-like table
        -- @param ... any extra arguments to the method
        -- @return a `List` with the results of the method (1st result only)
        -- @usage
        -- local Car = {}
        -- Car.__index = Car
        -- function Car.new(car)
        --   return setmetatable(car or {}, Car)
        -- end
        -- Car.speed = 0
        -- function Car:faster(increase)
        --   self.speed = self.speed + increase
        --   return self.speed
        -- end
        --
        -- local ferrari = Car.new{ name = "Ferrari" }
        -- local lamborghini = Car.new{ name = "Lamborghini", speed = 50 }
        -- local cars = { ferrari, lamborghini }
        --
        -- assert(ferrari.speed == 0)
        -- assert(lamborghini.speed == 50)
        -- tablex.map_named_method("faster", cars, 10)
        -- assert(ferrari.speed == 10)
        -- assert(lamborghini.speed == 60)
******0 function tablex.map_named_method (name,t,...)
******0     utils.assert_string(1,name)
******0     assert_arg_indexable(2,t)
******0     local res = {}
******0     for i = 1,#t do
******0         local val = t[i]
******0         local fun = val[name]
******0         res[i] = fun(val,...)
            end
******0     return setmeta(res,t,'List')
        end

        --- apply a function to all values of a table, in-place.
        -- Any extra arguments are passed to the function.
        -- @func fun A function that takes at least one argument
        -- @tab t a table
        -- @param ... extra arguments passed to `fun`
        -- @see tablex.foreach
******0 function tablex.transform (fun,t,...)
******0     assert_arg_iterable(1,t)
******0     fun = function_arg(1,fun)
******0     for k,v in pairs(t) do
******0         t[k] = fun(v,...)
            end
        end

        --- generate a table of all numbers in a range.
        -- This is consistent with a numerical for loop.
        -- @int start  number
        -- @int finish number
        -- @int[opt=1] step  make this negative for start < finish
******0 function tablex.range (start,finish,step)
            local res
******0     step = step or 1
******0     if start == finish then
******0         res = {start}
******0     elseif (start > finish and step > 0) or (finish > start and step < 0) then
******0         res = {}
            else
******0         local k = 1
******0         res = {}
******0         for i=start,finish,step do res[k]=i; k=k+1 end
            end
******0     return makelist(res)
        end

        --- apply a function to values from two tables.
        -- @within MappingAndFiltering
        -- @func fun a function of at least two arguments
        -- @tab t1 a table
        -- @tab t2 a table
        -- @param ... extra arguments
        -- @return a table
        -- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
******0 function tablex.map2 (fun,t1,t2,...)
******0     assert_arg_iterable(1,t1)
******0     assert_arg_iterable(2,t2)
******0     fun = function_arg(1,fun)
******0     local res = {}
******0     for k,v in pairs(t1) do
******0         res[k] = fun(v,t2[k],...)
            end
******0     return setmeta(res,t1,'List')
        end

        --- apply a function to values from two arrays.
        -- The result will be the length of the shortest array.
        -- @within MappingAndFiltering
        -- @func fun a function of at least two arguments
        -- @array t1 a list-like table
        -- @array t2 a list-like table
        -- @param ... extra arguments
        -- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
******0 function tablex.imap2 (fun,t1,t2,...)
******0     assert_arg_indexable(2,t1)
******0     assert_arg_indexable(3,t2)
******0     fun = function_arg(1,fun)
******0     local res,n = {},math.min(#t1,#t2)
******0     for i = 1,n do
******0         res[i] = fun(t1[i],t2[i],...)
            end
******0     return res
        end

        --- 'reduce' a list using a binary function.
        -- @func fun a function of two arguments
        -- @array t a list-like table
        -- @array memo optional initial memo value. Defaults to first value in table.
        -- @return the result of the function
        -- @usage reduce('+',{1,2,3,4}) == 10
******0 function tablex.reduce (fun,t,memo)
******0     assert_arg_indexable(2,t)
******0     fun = function_arg(1,fun)
******0     local n = #t
******0     if n == 0 then
******0         return memo
            end
******0     local res = memo and fun(memo, t[1]) or t[1]
******0     for i = 2,n do
******0         res = fun(res,t[i])
            end
******0     return res
        end

        --- apply a function to all elements of a table.
        -- The arguments to the function will be the value,
        -- the key and _finally_ any extra arguments passed to this function.
        -- Note that the Lua 5.0 function table.foreach passed the _key_ first.
        -- @within Iterating
        -- @tab t a table
        -- @func fun a function on the elements; `function(value, key, ...)`
        -- @param ... extra arguments passed to `fun`
        -- @see tablex.transform
******0 function tablex.foreach(t,fun,...)
******0     assert_arg_iterable(1,t)
******0     fun = function_arg(2,fun)
******0     for k,v in pairs(t) do
******0         fun(v,k,...)
            end
        end

        --- apply a function to all elements of a list-like table in order.
        -- The arguments to the function will be the value,
        -- the index and _finally_ any extra arguments passed to this function
        -- @within Iterating
        -- @array t a table
        -- @func fun a function with at least one argument
        -- @param ... optional arguments
******0 function tablex.foreachi(t,fun,...)
******0     assert_arg_indexable(1,t)
******0     fun = function_arg(2,fun)
******0     for i = 1,#t do
******0         fun(t[i],i,...)
            end
        end

        --- Apply a function to a number of tables.
        -- A more general version of map
        -- The result is a table containing the result of applying that function to the
        -- ith value of each table. Length of output list is the minimum length of all the lists
        -- @within MappingAndFiltering
        -- @func fun a function of n arguments
        -- @tab ... n tables
        -- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
        -- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}
        -- @param fun A function that takes as many arguments as there are tables
******0 function tablex.mapn(fun,...)
******0     fun = function_arg(1,fun)
******0     local res = {}
******0     local lists = {...}
******0     local minn = 1e40
******0     for i = 1,#lists do
******0         minn = min(minn,#(lists[i]))
            end
******0     for i = 1,minn do
******0         local args,k = {},1
******0         for j = 1,#lists do
******0             args[k] = lists[j][i]
******0             k = k + 1
                end
******0         res[#res+1] = fun(unpack(args))
            end
******0     return res
        end

        --- call the function with the key and value pairs from a table.
        -- The function can return a value and a key (note the order!). If both
        -- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that
        -- key into a table and append into it. If only value is not nil, then it is appended to the result.
        -- @within MappingAndFiltering
        -- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
        -- @tab t A table
        -- @param ... optional arguments
        -- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
        -- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
******0 function tablex.pairmap(fun,t,...)
******0     assert_arg_iterable(1,t)
******0     fun = function_arg(1,fun)
******0     local res = {}
******0     for k,v in pairs(t) do
******0         local rv,rk = fun(k,v,...)
******0         if rk then
******0             if res[rk] then
******0                 if type(res[rk]) == 'table' then
******0                     table.insert(res[rk],rv)
                        else
******0                     res[rk] = {res[rk], rv}
                        end
                    else
******0                 res[rk] = rv
                    end
                else
******0             res[#res+1] = rv
                end
            end
******0     return res
        end

******0 local function keys_op(i,v) return i end

        --- return all the keys of a table in arbitrary order.
        -- @within Extraction
        -- @tab t A list-like table where the values are the keys of the input table
******0 function tablex.keys(t)
******0     assert_arg_iterable(1,t)
******0     return makelist(tablex.pairmap(keys_op,t))
        end

******0 local function values_op(i,v) return v end

        --- return all the values of the table in arbitrary order
        -- @within Extraction
        -- @tab t A list-like table where the values are the values of the input table
******0 function tablex.values(t)
******0     assert_arg_iterable(1,t)
******0     return makelist(tablex.pairmap(values_op,t))
        end

******0 local function index_map_op (i,v) return i,v end

        --- create an index map from a list-like table. The original values become keys,
        -- and the associated values are the indices into the original list.
        -- @array t a list-like table
        -- @return a map-like table
******0 function tablex.index_map (t)
******0     assert_arg_indexable(1,t)
******0     return makemap(tablex.pairmap(index_map_op,t))
        end

******0 local function set_op(i,v) return true,v end

        --- create a set from a list-like table. A set is a table where the original values
        -- become keys, and the associated values are all true.
        -- @array t a list-like table
        -- @return a set (a map-like table)
******0 function tablex.makeset (t)
******0     assert_arg_indexable(1,t)
******0     return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))
        end

        --- combine two tables, either as union or intersection. Corresponds to
        -- set operations for sets () but more general. Not particularly
        -- useful for list-like tables.
        -- @within Merging
        -- @tab t1 a table
        -- @tab t2 a table
        -- @bool dup true for a union, false for an intersection.
        -- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
        -- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
        -- @see tablex.index_map
******0 function tablex.merge (t1,t2,dup)
******0     assert_arg_iterable(1,t1)
******0     assert_arg_iterable(2,t2)
******0     local res = {}
******0     for k,v in pairs(t1) do
******0         if dup or t2[k] then res[k] = v end
            end
******0     if dup then
******0       for k,v in pairs(t2) do
******0         res[k] = v
              end
            end
******0     return setmeta(res,t1,'Map')
        end

        --- the union of two map-like tables.
        -- If there are duplicate keys, the second table wins.
        -- @tab t1 a table
        -- @tab t2 a table
        -- @treturn tab
        -- @see tablex.merge
******0 function tablex.union(t1, t2)
******0     return tablex.merge(t1, t2, true)
        end

        --- the intersection of two map-like tables.
        -- @tab t1 a table
        -- @tab t2 a table
        -- @treturn tab
        -- @see tablex.merge
******0 function tablex.intersection(t1, t2)
******0     return tablex.merge(t1, t2, false)
        end

        --- a new table which is the difference of two tables.
        -- With sets (where the values are all true) this is set difference and
        -- symmetric difference depending on the third parameter.
        -- @within Merging
        -- @tab s1 a map-like table or set
        -- @tab s2 a map-like table or set
        -- @bool symm symmetric difference (default false)
        -- @return a map-like table or set
******0 function tablex.difference (s1,s2,symm)
******0     assert_arg_iterable(1,s1)
******0     assert_arg_iterable(2,s2)
******0     local res = {}
******0     for k,v in pairs(s1) do
******0         if s2[k] == nil then res[k] = v end
            end
******0     if symm then
******0         for k,v in pairs(s2) do
******0             if s1[k] == nil then res[k] = v end
                end
            end
******0     return setmeta(res,s1,'Map')
        end

        --- A table where the key/values are the values and value counts of the table.
        -- @array t a list-like table
        -- @func cmp a function that defines equality (otherwise uses ==)
        -- @return a map-like table
        -- @see seq.count_map
******0 function tablex.count_map (t,cmp)
******0     assert_arg_indexable(1,t)
******0     local res,mask = {},{}
******0     cmp = function_arg(2,cmp or '==')
******0     local n = #t
******0     for i = 1,#t do
******0         local v = t[i]
******0         if not mask[v] then
******0             mask[v] = true
                    -- check this value against all other values
******0             res[v] = 1  -- there's at least one instance
******0             for j = i+1,n do
******0                 local w = t[j]
******0                 local ok = cmp(v,w)
******0                 if ok then
******0                     res[v] = res[v] + 1
******0                     mask[w] = true
                        end
                    end
                end
            end
******0     return makemap(res)
        end

        --- filter an array's values using a predicate function
        -- @within MappingAndFiltering
        -- @array t a list-like table
        -- @func pred a boolean function
        -- @param arg optional argument to be passed as second argument of the predicate
******0 function tablex.filter (t,pred,arg)
     10     assert_arg_indexable(1,t)
     10     pred = function_arg(2,pred)
     10     local res,k = {},1
    512     for i = 1,#t do
    502         local v = t[i]
    502         if pred(v,arg) then
     14             res[k] = v
     14             k = k + 1
                end
            end
     10     return setmeta(res,t,'List')
        end

        --- return a table where each element is a table of the ith values of an arbitrary
        -- number of tables. It is equivalent to a matrix transpose.
        -- @within Merging
        -- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
        -- @array ... arrays to be zipped
******0 function tablex.zip(...)
******0     return tablex.mapn(function(...) return {...} end,...)
        end

        local _copy
******0 function _copy (dest,src,idest,isrc,nsrc,clean_tail)
******0     idest = idest or 1
******0     isrc = isrc or 1
            local iend
******0     if not nsrc then
******0         nsrc = #src
******0         iend = #src
            else
******0         iend = isrc + min(nsrc-1,#src-isrc)
            end
******0     if dest == src then -- special case
******0         if idest > isrc and iend >= idest then -- overlapping ranges
******0             src = tablex.sub(src,isrc,nsrc)
******0             isrc = 1; iend = #src
                end
            end
******0     for i = isrc,iend do
******0         dest[idest] = src[i]
******0         idest = idest + 1
            end
******0     if clean_tail then
******0         tablex.clear(dest,idest)
            end
******0     return dest
        end

        --- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
        -- @within Copying
        -- @array dest a list-like table
        -- @array src a list-like table
        -- @int[opt=1] idest where to start copying values into destination
        -- @int[opt=1] isrc where to start copying values from source
        -- @int[opt=#src] nsrc number of elements to copy from source
******0 function tablex.icopy (dest,src,idest,isrc,nsrc)
******0     assert_arg_indexable(1,dest)
******0     assert_arg_indexable(2,src)
******0     return _copy(dest,src,idest,isrc,nsrc,true)
        end

        --- copy an array into another one.
        -- @within Copying
        -- @array dest a list-like table
        -- @array src a list-like table
        -- @int[opt=1] idest where to start copying values into destination
        -- @int[opt=1] isrc where to start copying values from source
        -- @int[opt=#src] nsrc number of elements to copy from source
******0 function tablex.move (dest,src,idest,isrc,nsrc)
******0     assert_arg_indexable(1,dest)
******0     assert_arg_indexable(2,src)
******0     return _copy(dest,src,idest,isrc,nsrc,false)
        end

******0 function tablex._normalize_slice(self,first,last)
******0   local sz = #self
******0   if not first then first=1 end
******0   if first<0 then first=sz+first+1 end
          -- make the range _inclusive_!
******0   if not last then last=sz end
******0   if last < 0 then last=sz+1+last end
******0   return first,last
        end

        --- Extract a range from a table, like  'string.sub'.
        -- If first or last are negative then they are relative to the end of the list
        -- eg. sub(t,-2) gives last 2 entries in a list, and
        -- sub(t,-4,-2) gives from -4th to -2nd
        -- @within Extraction
        -- @array t a list-like table
        -- @int first An index
        -- @int last An index
        -- @return a new List
******0 function tablex.sub(t,first,last)
******0     assert_arg_indexable(1,t)
******0     first,last = tablex._normalize_slice(t,first,last)
******0     local res={}
******0     for i=first,last do append(res,t[i]) end
******0     return setmeta(res,t,'List')
        end

        --- set an array range to a value. If it's a function we use the result
        -- of applying it to the indices.
        -- @array t a list-like table
        -- @param val a value
        -- @int[opt=1] i1 start range
        -- @int[opt=#t] i2 end range
******0 function tablex.set (t,val,i1,i2)
******0     assert_arg_indexable(1,t)
******0     i1,i2 = i1 or 1,i2 or #t
******0     if types.is_callable(val) then
******0         for i = i1,i2 do
******0             t[i] = val(i)
                end
            else
******0         for i = i1,i2 do
******0             t[i] = val
                end
            end
        end

        --- create a new array of specified size with initial value.
        -- @int n size
        -- @param val initial value (can be `nil`, but don't expect `#` to work!)
        -- @return the table
******0 function tablex.new (n,val)
******0     local res = {}
******0     tablex.set(res,val,1,n)
******0     return res
        end

        --- clear out the contents of a table.
        -- @array t a list
        -- @param istart optional start position
******0 function tablex.clear(t,istart)
******0     istart = istart or 1
******0     for i = istart,#t do remove(t) end
        end

        --- insert values into a table.
        -- similar to `table.insert` but inserts values from given table `values`,
        -- not the object itself, into table `t` at position `pos`.
        -- @within Copying
        -- @array t the list
        -- @int[opt] position (default is at end)
        -- @array values
******0 function tablex.insertvalues(t, ...)
      6     assert_arg(1,t,'table')
            local pos, values
      6     if select('#', ...) == 1 then
      6         pos,values = #t+1, ...
            else
******0         pos,values = ...
            end
      6     if #values > 0 then
      6         for i=#t,pos,-1 do
******0             t[i+#values] = t[i]
                end
      6         local offset = 1 - pos
     14         for i=pos,pos+#values-1 do
      8             t[i] = values[i + offset]
                end
            end
      6     return t
        end

        --- remove a range of values from a table.
        -- End of range may be negative.
        -- @array t a list-like table
        -- @int i1 start index
        -- @int i2 end index
        -- @return the table
******0 function tablex.removevalues (t,i1,i2)
******0     assert_arg(1,t,'table')
******0     i1,i2 = tablex._normalize_slice(t,i1,i2)
******0     for i = i1,i2 do
******0         remove(t,i1)
            end
******0     return t
        end

        local _find
        _find = function (t,value,tables)
******0     for k,v in pairs(t) do
******0         if v == value then return k end
            end
******0     for k,v in pairs(t) do
******0         if not tables[v] and type(v) == 'table' then
******0             tables[v] = true
******0             local res = _find(v,value,tables)
******0             if res then
******0                 res = tostring(res)
******0                 if type(k) ~= 'string' then
******0                     return '['..k..']'..res
                        else
******0                     return k..'.'..res
                        end
                    end
                end
            end
        end

        --- find a value in a table by recursive search.
        -- @within Finding
        -- @tab t the table
        -- @param value the value
        -- @array[opt] exclude any tables to avoid searching
        -- @return a fieldspec, e.g. 'a.b' or 'math.sin'
        -- @usage search(_G,math.sin,{package.path}) == 'math.sin'
******0 function tablex.search (t,value,exclude)
******0     assert_arg_iterable(1,t)
******0     local tables = {[t]=true}
******0     if exclude then
******0         for _,v in pairs(exclude) do tables[v] = true end
            end
******0     return _find(t,value,tables)
        end

        --- return an iterator to a table sorted by its keys
        -- @within Iterating
        -- @tab t the table
        -- @func f an optional comparison function (f(x,y) is true if x < y)
        -- @usage for k,v in tablex.sort(t) do print(k,v) end
        -- @return an iterator to traverse elements sorted by the keys
******0 function tablex.sort(t,f)
******0     local keys = {}
******0     for k in pairs(t) do keys[#keys + 1] = k end
******0     tsort(keys,f)
******0     local i = 0
            return function()
******0         i = i + 1
******0         return keys[i], t[keys[i]]
            end
        end

        --- return an iterator to a table sorted by its values
        -- @within Iterating
        -- @tab t the table
        -- @func f an optional comparison function (f(x,y) is true if x < y)
        -- @usage for k,v in tablex.sortv(t) do print(k,v) end
        -- @return an iterator to traverse elements sorted by the values
******0 function tablex.sortv(t,f)
******0     f = function_arg(2, f or '<')
******0     local keys = {}
******0     for k in pairs(t) do keys[#keys + 1] = k end
******0     tsort(keys,function(x, y) return f(t[x], t[y]) end)
******0     local i = 0
            return function()
******0         i = i + 1
******0         return keys[i], t[keys[i]]
            end
        end

        --- modifies a table to be read only.
        -- This only offers weak protection. Tables can still be modified with
        -- `table.insert` and `rawset`.
        --
        -- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the
        -- equivalent metamethods are only available in Lua 5.2 and newer.
        -- @tab t the table
        -- @return the table read only (a proxy).
******0 function tablex.readonly(t)
******0     local mt = {
                __index=t,
                __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
                __pairs=function() return pairs(t) end,
                __ipairs=function() return ipairs(t) end,
                __len=function() return #t end,
******0         __metatable=false
            }
******0     return setmetatable({}, mt)
        end

******0 return tablex

==============================================================================
/opt/homebrew/share/lua/5.4/pl/types.lua
==============================================================================
        ---- Dealing with Detailed Type Information

        -- Dependencies `pl.utils`
        -- @module pl.types

******0 local utils = require 'pl.utils'
******0 local math_ceil = math.ceil
******0 local assert_arg = utils.assert_arg
******0 local types = {}

        do
            -- we prefer debug.getmetatable, but only if available
******0     local gmt = (debug or {}).getmetatable or getmetatable

            --- is the object either a function or a callable object?.
            -- @param obj Object to check.
******0     function types.is_callable (obj)
******0         if type(obj) == 'function' then
******0             return true
                end
******0         local mt = gmt(obj)
******0         if not mt then
******0             return false
                end
******0         return type(rawget(mt, "__call")) == "function"
            end
        end

        --- is the object of the specified type?.
        -- If the type is a string, then use type, otherwise compare with metatable.
        --
        -- NOTE: this function is imported from `utils.is_type`.
        -- @param obj An object to check
        -- @param tp The expected type
        -- @function is_type
        -- @see utils.is_type
******0 types.is_type = utils.is_type

******0 local fileMT = getmetatable(io.stdout)

        --- a string representation of a type.
        -- For tables and userdata with metatables, we assume that the metatable has a `_name`
        -- field. If the field is not present it will return 'unknown table' or
        -- 'unknown userdata'.
        -- Lua file objects return the type 'file'.
        -- @param obj an object
        -- @return a string like 'number', 'table', 'file' or 'List'
******0 function types.type (obj)
******0     local t = type(obj)
******0     if t == 'table' or t == 'userdata' then
******0         local mt = getmetatable(obj)
******0         if mt == fileMT then
******0             return 'file'
******0         elseif mt == nil then
******0             return t
                else
                    -- TODO: the "unknown" is weird, it should just return the type
******0             return mt._name or "unknown "..t
                end
            else
******0         return t
            end
        end

        --- is this number an integer?
        -- @param x a number
        -- @raise error if x is not a number
        -- @return boolean
******0 function types.is_integer (x)
******0     return math_ceil(x)==x
        end

        --- Check if the object is "empty".
        -- An object is considered empty if it is:
        --
        -- - `nil`
        -- - a table without any items (key-value pairs or indexes)
        -- - a string with no content ("")
        -- - not a nil/table/string
        -- @param o The object to check if it is empty.
        -- @param ignore_spaces If the object is a string and this is true the string is
        -- considered empty if it only contains spaces.
        -- @return `true` if the object is empty, otherwise a falsy value.
******0 function types.is_empty(o, ignore_spaces)
******0     if o == nil then
******0         return true
******0     elseif type(o) == "table" then
******0         return next(o) == nil
******0     elseif type(o) == "string" then
******0         return o == "" or (not not ignore_spaces and (not not o:find("^%s+$")))
            else
******0         return true
            end
        end

        local function check_meta (val)
     24     if type(val) == 'table' then return true end
******0     return getmetatable(val)
        end

        --- is an object 'array-like'?
        -- An object is array like if:
        --
        -- - it is a table, or
        -- - it has a metatable with `__len` and `__index` methods
        --
        -- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata
        -- @param val any value.
        -- @return `true` if the object is array-like, otherwise a falsy value.
******0 function types.is_indexable (val)
     10     local mt = check_meta(val)
     10     if mt == true then return true end
******0     return mt and mt.__len and mt.__index and true
        end

        --- can an object be iterated over with `pairs`?
        -- An object is iterable if:
        --
        -- - it is a table, or
        -- - it has a metatable with a `__pairs` meta method
        --
        -- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata
        -- @param val any value.
        -- @return `true` if the object is iterable, otherwise a falsy value.
******0 function types.is_iterable (val)
     14     local mt = check_meta(val)
     14     if mt == true then return true end
******0     return mt and mt.__pairs and true
        end

        --- can an object accept new key/pair values?
        -- An object is iterable if:
        --
        -- - it is a table, or
        -- - it has a metatable with a `__newindex` meta method
        --
        -- @param val any value.
        -- @return `true` if the object is writeable, otherwise a falsy value.
******0 function types.is_writeable (val)
******0     local mt = check_meta(val)
******0     if mt == true then return true end
******0     return mt and mt.__newindex and true
        end

        -- Strings that should evaluate to true.   -- TODO: add on/off ???
******0 local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
        -- Conditions types should evaluate to true.
******0 local true_types = {
            boolean=function(o, true_strs, check_objs) return o end,
            string=function(o, true_strs, check_objs)
******0         o = o:lower()
******0         if trues[o] then
******0             return true
                end
                -- Check alternative user provided strings.
******0         for _,v in ipairs(true_strs or {}) do
******0             if type(v) == "string" and o == v:lower() then
******0                 return true
                    end
                end
******0         return false
            end,
            number=function(o, true_strs, check_objs) return o ~= 0 end,
******0     table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
        }
        --- Convert to a boolean value.
        -- True values are:
        --
        -- * boolean: true.
        -- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
        -- * number: Any non-zero value.
        -- * table: Is not empty and `check_objs` is true.
        -- * everything else: Is not `nil` and `check_objs` is true.
        --
        -- @param o The object to evaluate.
        -- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
        -- This should be a List of strings. E.g. "ja" to support German.
        -- @param[opt] check_objs True if objects should be evaluated.
        -- @return true if the input evaluates to true, otherwise false.
******0 function types.to_bool(o, true_strs, check_objs)
            local true_func
******0     if true_strs then
******0         assert_arg(2, true_strs, "table")
            end
******0     true_func = true_types[type(o)]
******0     if true_func then
******0         return true_func(o, true_strs, check_objs)
******0     elseif check_objs and o ~= nil then
******0         return true
            end
******0     return false
        end


******0 return types

==============================================================================
/opt/homebrew/share/lua/5.4/pl/utils.lua
==============================================================================
        --- Generally useful routines.
        -- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
        --
        -- Dependencies: `pl.compat`, all exported fields and functions from
        -- `pl.compat` are also available in this module.
        --
        -- @module pl.utils
******0 local format = string.format
******0 local compat = require 'pl.compat'
******0 local stdout = io.stdout
******0 local append = table.insert
******0 local concat = table.concat
******0 local _unpack = table.unpack  -- always injected by 'compat'
******0 local find = string.find
******0 local sub = string.sub
******0 local next = next
******0 local floor = math.floor

******0 local is_windows = compat.is_windows
******0 local err_mode = 'default'
        local raise
        local operators
******0 local _function_factories = {}


******0 local utils = { _VERSION = "1.15.0" }

******0 for k, v in pairs(compat) do utils[k] = v  end

        --- Some standard patterns
        -- @table patterns
******0 utils.patterns = {
            FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number
            INTEGER = '[+%-%d]%d*',                     -- integer number
            IDEN = '[%a_][%w_]*',                       -- identifier
            FILE = '[%a%.\\][:%][%w%._%-\\]*',          -- file
        }


        --- Standard meta-tables as used by other Penlight modules
        -- @table stdmt
        -- @field List the List metatable
        -- @field Map the Map metatable
        -- @field Set the Set metatable
        -- @field MultiMap the MultiMap metatable
******0 utils.stdmt = {
            List = {_name='List'},
            Map = {_name='Map'},
            Set = {_name='Set'},
            MultiMap = {_name='MultiMap'},
        }


        --- pack an argument list into a table.
        -- @param ... any arguments
        -- @return a table with field `n` set to the length
        -- @function utils.pack
        -- @see compat.pack
        -- @see utils.npairs
        -- @see utils.unpack
******0 utils.pack = table.pack  -- added here to be symmetrical with unpack

        --- unpack a table and return its contents.
        --
        -- NOTE: this implementation differs from the Lua implementation in the way
        -- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.
        -- @param t table to unpack
        -- @param[opt] i index from which to start unpacking, defaults to 1
        -- @param[opt] j index of the last element to unpack, defaults to `t.n` or else `#t`
        -- @return multiple return values from the table
        -- @function utils.unpack
        -- @see compat.unpack
        -- @see utils.pack
        -- @see utils.npairs
        -- @usage
        -- local t = table.pack(nil, nil, nil, 4)
        -- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil
        --
        -- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4
******0 function utils.unpack(t, i, j)
******0     return _unpack(t, i or 1, j or t.n or #t)
        end

        --- print an arbitrary number of arguments using a format.
        -- Output will be sent to `stdout`.
        -- @param fmt The format (see `string.format`)
        -- @param ... Extra arguments for format
******0 function utils.printf(fmt, ...)
******0     utils.assert_string(1, fmt)
******0     utils.fprintf(stdout, fmt, ...)
        end

        --- write an arbitrary number of arguments to a file using a format.
        -- @param f File handle to write to.
        -- @param fmt The format (see `string.format`).
        -- @param ... Extra arguments for format
******0 function utils.fprintf(f,fmt,...)
******0     utils.assert_string(2,fmt)
******0     f:write(format(fmt,...))
        end

        do
            local function import_symbol(T,k,v,libname)
******0         local key = rawget(T,k)
                -- warn about collisions!
******0         if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
******0             utils.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",libname,k)
******0             return
                end
******0         rawset(T,k,v)
            end

            local function lookup_lib(T,t)
******0         for k,v in pairs(T) do
******0             if v == t then return k end
                end
******0         return '?'
            end

******0     local already_imported = {}

            --- take a table and 'inject' it into the local namespace.
            -- @param t The table (table), or module name (string), defaults to this `utils` module table
            -- @param T An optional destination table (defaults to callers environment)
******0     function utils.import(t,T)
******0         T = T or _G
******0         t = t or utils
******0         if type(t) == 'string' then
******0             t = require (t)
                end
******0         local libname = lookup_lib(T,t)
******0         if already_imported[t] then return end
******0         already_imported[t] = libname
******0         for k,v in pairs(t) do
******0             import_symbol(T,k,v,libname)
                end
            end
        end

        --- return either of two values, depending on a condition.
        -- @param cond A condition
        -- @param value1 Value returned if cond is truthy
        -- @param value2 Value returned if cond is falsy
******0 function utils.choose(cond, value1, value2)
******0     if cond then
******0         return value1
            else
******0         return value2
            end
        end

        --- convert an array of values to strings.
        -- @param t a list-like table
        -- @param[opt] temp (table) buffer to use, otherwise allocate
        -- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.
        -- @return the converted buffer
******0 function utils.array_tostring (t,temp,tostr)
******0     temp, tostr = temp or {}, tostr or tostring
******0     for i = 1,#t do
******0         temp[i] = tostr(t[i],i)
            end
******0     return temp
        end



        --- is the object of the specified type?
        -- If the type is a string, then use type, otherwise compare with metatable
        -- @param obj An object to check
        -- @param tp String of what type it should be
        -- @return boolean
        -- @usage utils.is_type("hello world", "string")   --> true
        -- -- or check metatable
        -- local my_mt = {}
        -- local my_obj = setmetatable(my_obj, my_mt)
        -- utils.is_type(my_obj, my_mt)  --> true
******0 function utils.is_type (obj,tp)
******0     if type(tp) == 'string' then return type(obj) == tp end
******0     local mt = getmetatable(obj)
******0     return tp == mt
        end



        --- an iterator with indices, similar to `ipairs`, but with a range.
        -- This is a nil-safe index based iterator that will return `nil` when there
        -- is a hole in a list. To be safe ensure that table `t.n` contains the length.
        -- @tparam table t the table to iterate over
        -- @tparam[opt=1] integer i_start start index
        -- @tparam[opt=t.n or #t] integer i_end end index
        -- @tparam[opt=1] integer step step size
        -- @treturn integer index
        -- @treturn any value at index (which can be `nil`!)
        -- @see utils.pack
        -- @see utils.unpack
        -- @usage
        -- local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing
        --
        -- for i, v in utils.npairs(t, 2) do  -- start at index 2
        --   t[i] = tostring(t[i])
        -- end
        --
        -- -- t = { n = 3, [2] = "123", [3] = "nil" }
******0 function utils.npairs(t, i_start, i_end, step)
******0   step = step or 1
******0   if step == 0 then
******0     error("iterator step-size cannot be 0", 2)
          end
******0   local i = (i_start or 1) - step
******0   i_end = i_end or t.n or #t
******0   if step < 0 then
            return function()
******0       i = i + step
******0       if i < i_end then
******0         return nil
              end
******0       return i, t[i]
            end

          else
            return function()
******0       i = i + step
******0       if i > i_end then
******0         return nil
              end
******0       return i, t[i]
            end
          end
        end



        --- an iterator over all non-integer keys (inverse of `ipairs`).
        -- It will skip any key that is an integer number, so negative indices or an
        -- array with holes will not return those either (so it returns slightly less than
        -- 'the inverse of `ipairs`').
        --
        -- This uses `pairs` under the hood, so any value that is iterable using `pairs`
        -- will work with this function.
        -- @tparam table t the table to iterate over
        -- @treturn key
        -- @treturn value
        -- @usage
        -- local t = {
        --   "hello",
        --   "world",
        --   hello = "hallo",
        --   world = "Welt",
        -- }
        --
        -- for k, v in utils.kpairs(t) do
        --   print("German: ", v)
        -- end
        --
        -- -- output;
        -- -- German: hallo
        -- -- German: Welt
******0 function utils.kpairs(t)
          local index
          return function()
            local value
            while true do
******0       index, value = next(t, index)
******0       if type(index) ~= "number" or floor(index) ~= index then
                break
              end
            end
******0     return index, value
          end
        end



        --- Error handling
        -- @section Error-handling

        --- assert that the given argument is in fact of the correct type.
        -- @param n argument index
        -- @param val the value
        -- @param tp the type
        -- @param verify an optional verification function
        -- @param msg an optional custom message
        -- @param lev optional stack position for trace, default 2
        -- @return the validated value
        -- @raise if `val` is not the correct type
        -- @usage
        -- local param1 = assert_arg(1,"hello",'table')  --> error: argument 1 expected a 'table', got a 'string'
        -- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')
        --      --> error: argument 4: '!@#$%^&*' not a directory
******0 function utils.assert_arg (n,val,tp,verify,msg,lev)
   9506     if type(val) ~= tp then
******0         error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
            end
   9506     if verify and not verify(val) then
******0         error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
            end
   9506     return val
        end

        --- creates an Enum or constants lookup table for improved error handling.
        -- This helps prevent magic strings in code by throwing errors for accessing
        -- non-existing values, and/or converting strings/identifiers to other values.
        --
        -- Calling on the object does the same, but returns a soft error; `nil + err`, if
        -- the call is successful (the key exists), it will return the value.
        --
        -- When calling with varargs or an array the values will be equal to the keys.
        -- The enum object is read-only.
        -- @tparam table|vararg ... the input for the Enum. If varargs or an array then the
        -- values in the Enum will be equal to the names (must be strings), if a hash-table
        -- then values remain (any type), and the keys must be strings.
        -- @return Enum object (read-only table/object)
        -- @usage -- Enum access at runtime
        -- local obj = {}
        -- obj.MOVEMENT = utils.enum("FORWARD", "REVERSE", "LEFT", "RIGHT")
        --
        -- if current_movement == obj.MOVEMENT.FORWARD then
        --   -- do something
        --
        -- elseif current_movement == obj.MOVEMENT.REVERES then
        --   -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error
        --   -- "'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')"
        --
        -- end
        -- @usage -- standardized error codes
        -- local obj = {
        --   ERR = utils.enum {
        --     NOT_FOUND = "the item was not found",
        --     OUT_OF_BOUNDS = "the index is outside the allowed range"
        --   },
        --
        --   some_method = function(self)
        --     return nil, self.ERR.OUT_OF_BOUNDS
        --   end,
        -- }
        --
        -- local result, err = obj:some_method()
        -- if not result then
        --   if err == obj.ERR.NOT_FOUND then
        --     -- check on error code, not magic strings
        --
        --   else
        --     -- return the error description, contained in the constant
        --     return nil, "error: "..err  -- "error: the index is outside the allowed range"
        --   end
        -- end
        -- @usage -- validating/converting user-input
        -- local color = "purple"
        -- local ansi_colors = utils.enum {
        --   black     = 30,
        --   red       = 31,
        --   green     = 32,
        -- }
        -- local color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum
        -- if not color_code then
        --   print("bad 'color', " .. err)
        --   -- "bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')"
        --   os.exit(1)
        -- end
******0 function utils.enum(...)
******0   local first = select(1, ...)
******0   local enum = {}
          local lst

******0   if type(first) ~= "table" then
            -- vararg with strings
******0     lst = utils.pack(...)
******0     for i, value in utils.npairs(lst) do
******0       utils.assert_arg(i, value, "string")
******0       enum[value] = value
            end

          else
            -- table/array with values
******0     utils.assert_arg(1, first, "table")
******0     lst = {}
            -- first add array part
******0     for i, value in ipairs(first) do
******0       if type(value) ~= "string" then
******0         error(("expected 'string' but got '%s' at index %d"):format(type(value), i), 2)
              end
******0       lst[i] = value
******0       enum[value] = value
            end
            -- add key-ed part
******0     for key, value in utils.kpairs(first) do
******0       if type(key) ~= "string" then
******0         error(("expected key to be 'string' but got '%s'"):format(type(key)), 2)
              end
******0       if enum[key] then
******0         error(("duplicate entry in array and hash part: '%s'"):format(key), 2)
              end
******0       enum[key] = value
******0       lst[#lst+1] = key
            end
          end

******0   if not lst[1] then
******0     error("expected at least 1 entry", 2)
          end

******0   local valid = "(expected one of: '" .. concat(lst, "', '") .. "')"
******0   setmetatable(enum, {
            __index = function(self, key)
******0       error(("'%s' is not a valid value %s"):format(tostring(key), valid), 2)
            end,
            __newindex = function(self, key, value)
******0       error("the Enum object is read-only", 2)
            end,
            __call = function(self, key)
******0       if type(key) == "string" then
******0         local v = rawget(self, key)
******0         if v ~= nil then
******0           return v
                end
              end
******0       return nil, ("'%s' is not a valid value %s"):format(tostring(key), valid)
            end
          })

******0   return enum
        end


        --- process a function argument.
        -- This is used throughout Penlight and defines what is meant by a function:
        -- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
        -- such as '>' or '#'. If a function factory has been registered for the type, it will
        -- be called to get the function.
        -- @param idx argument index
        -- @param f a function, operator string, or callable object
        -- @param msg optional error message
        -- @return a callable
        -- @raise if idx is not a number or if f is not callable
******0 function utils.function_arg (idx,f,msg)
     10     utils.assert_arg(1,idx,'number')
     10     local tp = type(f)
     10     if tp == 'function' then return f end  -- no worries!
            -- ok, a string can correspond to an operator (like '==')
******0     if tp == 'string' then
******0         if not operators then operators = require 'pl.operator'.optable end
******0         local fn = operators[f]
******0         if fn then return fn end
******0         local fn, err = utils.string_lambda(f)
******0         if not fn then error(err..': '..f) end
******0         return fn
******0     elseif tp == 'table' or tp == 'userdata' then
******0         local mt = getmetatable(f)
******0         if not mt then error('not a callable object',2) end
******0         local ff = _function_factories[mt]
******0         if not ff then
******0             if not mt.__call then error('not a callable object',2) end
******0             return f
                else
******0             return ff(f) -- we have a function factory for this type!
                end
            end
******0     if not msg then msg = " must be callable" end
******0     if idx > 0 then
******0         error("argument "..idx..": "..msg,2)
            else
******0         error(msg,2)
            end
        end


        --- assert the common case that the argument is a string.
        -- @param n argument index
        -- @param val a value that must be a string
        -- @return the validated value
        -- @raise val must be a string
        -- @usage
        -- local val = 42
        -- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'
******0 function utils.assert_string (n, val)
   9485     return utils.assert_arg(n,val,'string',nil,nil,3)
        end

        --- control the error strategy used by Penlight.
        -- This is a global setting that controls how `utils.raise` behaves:
        --
        -- - 'default': return `nil + error` (this is the default)
        -- - 'error': throw a Lua error
        -- - 'quit': exit the program
        --
        -- @param mode either 'default', 'quit'  or 'error'
        -- @see utils.raise
******0 function utils.on_error (mode)
******0     mode = tostring(mode)
******0     if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
******0       err_mode = mode
            else
              -- fail loudly
******0       local err = "Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'"
******0       if err_mode == 'default' then
******0         error(err, 2)  -- even in 'default' mode fail loud in this case
              end
******0       raise(err)
            end
        end

        --- used by Penlight functions to return errors. Its global behaviour is controlled
        -- by `utils.on_error`.
        -- To use this function you MUST use it in conjunction with `return`, since it might
        -- return `nil + error`.
        -- @param err the error string.
        -- @see utils.on_error
        -- @usage
        -- if some_condition then
        --   return utils.raise("some condition was not met")  -- MUST use 'return'!
        -- end
******0 function utils.raise (err)
******0     if err_mode == 'default' then
******0         return nil, err
******0     elseif err_mode == 'quit' then
******0         return utils.quit(err)
            else
******0         error(err, 2)
            end
        end
******0 raise = utils.raise



        --- File handling
        -- @section files

        --- return the contents of a file as a string
        -- @param filename The file path
        -- @param is_bin open in binary mode
        -- @return file contents
******0 function utils.readfile(filename,is_bin)
******0     local mode = is_bin and 'b' or ''
******0     utils.assert_string(1,filename)
******0     local f,open_err = io.open(filename,'r'..mode)
******0     if not f then return raise (open_err) end
******0     local res,read_err = f:read('*a')
******0     f:close()
******0     if not res then
                -- Errors in io.open have "filename: " prefix,
                -- error in file:read don't, add it.
******0         return raise (filename..": "..read_err)
            end
******0     return res
        end

        --- write a string to a file
        -- @param filename The file path
        -- @param str The string
        -- @param is_bin open in binary mode
        -- @return true or nil
        -- @return error message
        -- @raise error if filename or str aren't strings
******0 function utils.writefile(filename,str,is_bin)
******0     local mode = is_bin and 'b' or ''
******0     utils.assert_string(1,filename)
******0     utils.assert_string(2,str)
******0     local f,err = io.open(filename,'w'..mode)
******0     if not f then return raise(err) end
******0     local ok, write_err = f:write(str)
******0     f:close()
******0     if not ok then
                -- Errors in io.open have "filename: " prefix,
                -- error in file:write don't, add it.
******0         return raise (filename..": "..write_err)
            end
******0     return true
        end

        --- return the contents of a file as a list of lines
        -- @param filename The file path
        -- @return file contents as a table
        -- @raise error if filename is not a string
******0 function utils.readlines(filename)
******0     utils.assert_string(1,filename)
******0     local f,err = io.open(filename,'r')
******0     if not f then return raise(err) end
******0     local res = {}
******0     for line in f:lines() do
******0         append(res,line)
            end
******0     f:close()
******0     return res
        end

        --- OS functions
        -- @section OS-functions

        --- Execute a shell command.
        -- This function is a copy of `compat.execute`.
        -- @class function
        -- @name utils.execute

        --- execute a shell command and return the output.
        -- This function redirects the output to tempfiles and returns the content of those files.
        -- @param cmd a shell command
        -- @param bin boolean, if true, read output as binary file
        -- @return true if successful
        -- @return actual return code
        -- @return stdout output (string)
        -- @return errout output (string)
******0 function utils.executeex(cmd, bin)
******0     local outfile = os.tmpname()
******0     local errfile = os.tmpname()

******0     if is_windows and not outfile:find(':') then
******0         outfile = os.getenv('TEMP')..outfile
******0         errfile = os.getenv('TEMP')..errfile
            end
******0     cmd = cmd .. " > " .. utils.quote_arg(outfile) .. " 2> " .. utils.quote_arg(errfile)

******0     local success, retcode = utils.execute(cmd)
******0     local outcontent = utils.readfile(outfile, bin)
******0     local errcontent = utils.readfile(errfile, bin)
******0     os.remove(outfile)
******0     os.remove(errfile)
******0     return success, retcode, (outcontent or ""), (errcontent or "")
        end

        --- Quote and escape an argument of a command.
        -- Quotes a single (or list of) argument(s) of a command to be passed
        -- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.
        -- @param argument (string or table/list) the argument to quote. If a list then
        -- all arguments in the list will be returned as a single string quoted.
        -- @return quoted and escaped argument.
        -- @usage
        -- local options = utils.quote_arg {
        --     "-lluacov",
        --     "-e",
        --     "utils = print(require('pl.utils')._VERSION",
        -- }
        -- -- returns: -lluacov -e 'utils = print(require('\''pl.utils'\'')._VERSION'
******0 function utils.quote_arg(argument)
******0     if type(argument) == "table" then
                -- encode an entire table
******0         local r = {}
******0         for i, arg in ipairs(argument) do
******0             r[i] = utils.quote_arg(arg)
                end

******0         return concat(r, " ")
            end
            -- only a single argument
******0     if is_windows then
******0         if argument == "" or argument:find('[ \f\t\v]') then
                    -- Need to quote the argument.
                    -- Quotes need to be escaped with backslashes;
                    -- additionally, backslashes before a quote, escaped or not,
                    -- need to be doubled.
                    -- See documentation for CommandLineToArgvW Windows function.
******0             argument = '"' .. argument:gsub([[(\*)"]], [[%1%1\"]]):gsub([[\+$]], "%0%0") .. '"'
                end

                -- os.execute() uses system() C function, which on Windows passes command
                -- to cmd.exe. Escape its special characters.
******0         return (argument:gsub('["^<>!|&%%]', "^%0"))
            else
******0         if argument == "" or argument:find('[^a-zA-Z0-9_@%+=:,./-]') then
                    -- To quote arguments on posix-like systems use single quotes.
                    -- To represent an embedded single quote close quoted string ('),
                    -- add escaped quote (\'), open quoted string again (').
******0             argument = "'" .. argument:gsub("'", [['\'']]) .. "'"
                end

******0         return argument
            end
        end

        --- error out of this program gracefully.
        -- @param[opt] code The exit code, defaults to -`1` if omitted
        -- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)
        -- @param ... extra arguments for message's format'
        -- @see utils.fprintf
        -- @usage utils.quit(-1, "Error '%s' happened", "42")
        -- -- is equivalent to
        -- utils.quit("Error '%s' happened", "42")  --> Error '42' happened
******0 function utils.quit(code, msg, ...)
******0     if type(code) == 'string' then
******0         utils.fprintf(io.stderr, code, msg, ...)
******0         io.stderr:write('\n')
******0         code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code
******0     elseif msg then
******0         utils.fprintf(io.stderr, msg, ...)
******0         io.stderr:write('\n')
            end
******0     os.exit(code, true)
        end


        --- String functions
        -- @section string-functions

        --- escape any Lua 'magic' characters in a string
        -- @param s The input string
******0 function utils.escape(s)
    495     utils.assert_string(1,s)
    495     return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
        end

        --- split a string into a list of strings separated by a delimiter.
        -- @param s The input string
        -- @param re optional A Lua string pattern; defaults to '%s+'
        -- @param plain optional If truthy don't use Lua patterns
        -- @param n optional maximum number of elements (if there are more, the last will remain un-split)
        -- @return a list-like table
        -- @raise error if s is not a string
        -- @see splitv
******0 function utils.split(s,re,plain,n)
******0     utils.assert_string(1,s)
******0     local i1,ls = 1,{}
******0     if not re then re = '%s+' end
******0     if re == '' then return {s} end
            while true do
******0         local i2,i3 = find(s,re,i1,plain)
******0         if not i2 then
******0             local last = sub(s,i1)
******0             if last ~= '' then append(ls,last) end
******0             if #ls == 1 and ls[1] == '' then
******0                 return {}
                    else
******0                 return ls
                    end
                end
******0         append(ls,sub(s,i1,i2-1))
******0         if n and #ls == n then
******0             ls[#ls] = sub(s,i1)
******0             return ls
                end
******0         i1 = i3+1
            end
        end

        --- split a string into a number of return values.
        -- Identical to `split` but returns multiple sub-strings instead of
        -- a single list of sub-strings.
        -- @param s the string
        -- @param re A Lua string pattern; defaults to '%s+'
        -- @param plain don't use Lua patterns
        -- @param n optional maximum number of splits
        -- @return n values
        -- @usage first,next = splitv('user=jane=doe','=', false, 2)
        -- assert(first == "user")
        -- assert(next == "jane=doe")
        -- @see split
******0 function utils.splitv (s,re, plain, n)
******0     return _unpack(utils.split(s,re, plain, n))
        end


        --- Functional
        -- @section functional


        --- 'memoize' a function (cache returned value for next call).
        -- This is useful if you have a function which is relatively expensive,
        -- but you don't know in advance what values will be required, so
        -- building a table upfront is wasteful/impossible.
        -- @param func a function that takes exactly one argument (which later serves as the cache key) and returns a single value
        -- @return a function taking one argument and returning a single value either from the cache or by running the original input function
******0 function utils.memoize(func)
******0     local cache = {}
            return function(k)
******0         local res = cache[k]
******0         if res == nil then
******0             res = func(k)
******0             cache[k] = res
                end
******0         return res
            end
        end


        --- associate a function factory with a type.
        -- A function factory takes an object of the given type and
        -- returns a function for evaluating it
        -- @tab mt metatable
        -- @func fun a callable that returns a function
******0 function utils.add_function_factory (mt,fun)
******0     _function_factories[mt] = fun
        end

        local function _string_lambda(f)
******0     if f:find '^|' or f:find '_' then
******0         local args,body = f:match '|([^|]*)|(.+)'
******0         if f:find '_' then
******0             args = '_'
******0             body = f
                else
******0             if not args then return raise 'bad string lambda' end
                end
******0         local fstr = 'return function('..args..') return '..body..' end'
******0         local fn,err = utils.load(fstr)
******0         if not fn then return raise(err) end
******0         fn = fn()
******0         return fn
            else
******0         return raise 'not a string lambda'
            end
        end


        --- an anonymous function as a string. This string is either of the form
        -- '|args| expression' or is a function of one argument, '_'
        -- @param lf function as a string
        -- @return a function
        -- @function utils.string_lambda
        -- @usage
        -- string_lambda '|x|x+1' (2) == 3
        -- string_lambda '_+1' (2) == 3
******0 utils.string_lambda = utils.memoize(_string_lambda)


        --- bind the first argument of the function to a value.
        -- @param fn a function of at least two values (may be an operator string)
        -- @param p a value
        -- @return a function such that f(x) is fn(p,x)
        -- @raise same as @{function_arg}
        -- @see func.bind1
        -- @usage local function f(msg, name)
        --   print(msg .. " " .. name)
        -- end
        --
        -- local hello = utils.bind1(f, "Hello")
        --
        -- print(hello("world"))     --> "Hello world"
        -- print(hello("sunshine"))  --> "Hello sunshine"
******0 function utils.bind1 (fn,p)
******0     fn = utils.function_arg(1,fn)
******0     return function(...) return fn(p,...) end
        end


        --- bind the second argument of the function to a value.
        -- @param fn a function of at least two values (may be an operator string)
        -- @param p a value
        -- @return a function such that f(x) is fn(x,p)
        -- @raise same as @{function_arg}
        -- @usage local function f(a, b, c)
        --   print(a .. " " .. b .. " " .. c)
        -- end
        --
        -- local hello = utils.bind1(f, "world")
        --
        -- print(hello("Hello", "!"))  --> "Hello world !"
        -- print(hello("Bye", "?"))    --> "Bye world ?"
******0 function utils.bind2 (fn,p)
******0     fn = utils.function_arg(1,fn)
******0     return function(x,...) return fn(x,p,...) end
        end




        --- Deprecation
        -- @section deprecation

        do
          -- the default implementation
          local deprecation_func = function(msg, trace)
******0     if trace then
******0       warn(msg, "\n", trace)  -- luacheck: ignore
            else
******0       warn(msg)  -- luacheck: ignore
            end
          end

          --- Sets a deprecation warning function.
          -- An application can override this function to support proper output of
          -- deprecation warnings. The warnings can be generated from libraries or
          -- functions by calling `utils.raise_deprecation`. The default function
          -- will write to the 'warn' system (introduced in Lua 5.4, or the compatibility
          -- function from the `compat` module for earlier versions).
          --
          -- Note: only applications should set/change this function, libraries should not.
          -- @param func a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional.
          -- @see utils.raise_deprecation
          -- @usage
          -- -- write to the Nginx logs with OpenResty
          -- utils.set_deprecation_func(function(msg, trace)
          --   ngx.log(ngx.WARN, msg, (trace and (" " .. trace) or nil))
          -- end)
          --
          -- -- disable deprecation warnings
          -- utils.set_deprecation_func()
******0   function utils.set_deprecation_func(func)
******0     if func == nil then
******0       deprecation_func = function() end
            else
******0       utils.assert_arg(1, func, "function")
******0       deprecation_func = func
            end
          end

          --- raises a deprecation warning.
          -- For options see the usage example below.
          --
          -- Note: the `opts.deprecated_after` field is the last version in which
          -- a feature or option was NOT YET deprecated! Because when writing the code it
          -- is quite often not known in what version the code will land. But the last
          -- released version is usually known.
          -- @param opts options table
          -- @see utils.set_deprecation_func
          -- @usage
          -- warn("@on")   -- enable Lua warnings, they are usually off by default
          --
          -- function stringx.islower(str)
          --   raise_deprecation {
          --     source = "Penlight " .. utils._VERSION,                   -- optional
          --     message = "function 'islower' was renamed to 'is_lower'", -- required
          --     version_removed = "2.0.0",                                -- optional
          --     deprecated_after = "1.2.3",                               -- optional
          --     no_trace = true,                                          -- optional
          --   }
          --   return stringx.is_lower(str)
          -- end
          -- -- output: "[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)"
******0   function utils.raise_deprecation(opts)
******0     utils.assert_arg(1, opts, "table")
******0     if type(opts.message) ~= "string" then
******0       error("field 'message' of the options table must be a string", 2)
            end
            local trace
******0     if not opts.no_trace then
******0       trace = debug.traceback("", 2):match("[\n%s]*(.-)$")
            end
            local msg
******0     if opts.deprecated_after and opts.version_removed then
******0       msg = (" (deprecated after %s, scheduled for removal in %s)"):format(
******0         tostring(opts.deprecated_after), tostring(opts.version_removed))
******0     elseif opts.deprecated_after then
******0       msg = (" (deprecated after %s)"):format(tostring(opts.deprecated_after))
******0     elseif opts.version_removed then
******0       msg = (" (scheduled for removal in %s)"):format(tostring(opts.version_removed))
            else
******0       msg = ""
            end

******0     msg = opts.message .. msg

******0     if opts.source then
******0       msg = "[" .. opts.source .."] " .. msg
            else
******0       if msg:sub(1,1) == "@" then
                -- in Lua 5.4 "@" prefixed messages are control messages to the warn system
******0         error("message cannot start with '@'", 2)
              end
            end

******0     deprecation_func(msg, trace)
          end

        end


******0 return utils



==============================================================================
/opt/homebrew/share/lua/5.4/say/init.lua
==============================================================================
******0 local unpack = table.unpack or unpack

******0 local registry = { }
        local current_namespace
        local fallback_namespace

******0 local s = {

          _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
          _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
          _VERSION     = "Say 1.3",

          set_namespace = function(self, namespace)
      6     current_namespace = namespace
      6     if not registry[current_namespace] then
******0       registry[current_namespace] = {}
            end
          end,

          set_fallback = function(self, namespace)
******0     fallback_namespace = namespace
******0     if not registry[fallback_namespace] then
******0       registry[fallback_namespace] = {}
            end
          end,

          set = function(self, key, value)
    114     registry[current_namespace][key] = value
          end
        }

******0 local __meta = {
          __call = function(self, key, vars)
    708     if vars ~= nil and type(vars) ~= "table" then
******0       error(("expected parameter table to be a table, got '%s'"):format(type(vars)), 2)
            end
    708     vars = vars or {}
    708     vars.n = math.max((vars.n or 0), #vars)

    708     local str = registry[current_namespace][key] or registry[fallback_namespace][key]

    708     if str == nil then
******0       return nil
            end
    708     str = tostring(str)
    708     local strings = {}

   2616     for i = 1, vars.n or #vars do
   1908       table.insert(strings, tostring(vars[i]))
            end

    708     return #strings > 0 and str:format(unpack(strings)) or str
          end,

          __index = function(self, key)
******0     return registry[key]
          end
        }

******0 s:set_fallback('en')
******0 s:set_namespace('en')

******0 s._registry = registry

******0 return setmetatable(s, __meta)

==============================================================================
lua/go-unfucked/error-dim.lua
==============================================================================
    360 local M = {}

    360 local ns = vim.api.nvim_create_namespace("go_error_dim")

    360 M.config = {
    360 	enabled = false,
    360 	dim_simple_return = false,
    360 	dim_wrapped_return = false,
    360 	dim_percent = 40,
    360 	dim_target = nil,
    360 }

    360 local dimmed_groups = {}
    360 local target_color = nil

        local function get_bg_color()
    270 	local normal = vim.api.nvim_get_hl(0, { name = "Normal" })
    270 	if normal.bg then
     30 		return string.format("#%06x", normal.bg)
        	end
    240 	return "#000000"
        end

        local function blend_colors(fg_hex, bg_hex, percent)
        	local function hex_to_rgb(hex)
    372 		hex = hex:gsub("#", "")
    372 		return tonumber(hex:sub(1, 2), 16), tonumber(hex:sub(3, 4), 16), tonumber(hex:sub(5, 6), 16)
        	end

    186 	local fr, fg, fb = hex_to_rgb(fg_hex)
    186 	local br, bg_val, bb = hex_to_rgb(bg_hex)

    186 	local t = percent / 100
    186 	local nr = math.floor(fr * (1 - t) + br * t)
    186 	local ng = math.floor(fg * (1 - t) + bg_val * t)
    186 	local nb = math.floor(fb * (1 - t) + bb * t)

    372 	return string.format(
    186 		"#%02x%02x%02x",
    186 		math.max(0, math.min(255, nr)),
    186 		math.max(0, math.min(255, ng)),
    186 		math.max(0, math.min(255, nb))
        	)
        end

        local function get_dimmed_group(original_group)
    114 	if dimmed_groups[original_group] then
      6 		return dimmed_groups[original_group]
        	end

    108 	local dimmed_name = "GoDim_" .. original_group:gsub("@", ""):gsub("%.", "_")

    108 	local hl = vim.api.nvim_get_hl(0, { name = original_group, link = false })

    108 	if hl.fg then
    102 		local fg_hex = string.format("#%06x", hl.fg)
    102 		local dimmed_fg = blend_colors(fg_hex, target_color, M.config.dim_percent)
    204 		vim.api.nvim_set_hl(0, dimmed_name, {
    102 			fg = dimmed_fg,
    102 			bg = hl.bg,
    102 			bold = hl.bold,
    102 			italic = hl.italic,
    102 			underline = hl.underline,
    102 		})
        	else
      6 		local default_fg = "#cccccc"
      6 		local dimmed_fg = blend_colors(default_fg, target_color, M.config.dim_percent)
      6 		vim.api.nvim_set_hl(0, dimmed_name, { fg = dimmed_fg })
        	end

    108 	dimmed_groups[original_group] = dimmed_name
    108 	return dimmed_name
        end

        local function clear_cache()
    150 	dimmed_groups = {}
    150 	target_color = M.config.dim_target or get_bg_color()
        end

        local function analyze_if_err_block(bufnr, block_node)
******0 	local dominated_statements = 0
******0 	local has_side_effects = false
******0 	local is_wrapped = false

******0 	local stmt_list = block_node:named_child(0)
******0 	if not stmt_list or stmt_list:type() ~= "statement_list" then
******0 		return { has_side_effects = true, is_wrapped = false, is_simple_return = false }
        	end

******0 	for i = 0, stmt_list:named_child_count() - 1 do
******0 		local child = stmt_list:named_child(i)
******0 		local child_type = child:type()

******0 		if child_type == "return_statement" then
******0 			local return_text = vim.treesitter.get_node_text(child, bufnr)

        			if
******0 				return_text:match("fmt%.Errorf")
******0 				or return_text:match("errors%.Wrap")
******0 				or return_text:match("errors%.New")
******0 				or return_text:match("%.Wrapf?%(")
        			then
******0 				is_wrapped = true
        			end

******0 			dominated_statements = dominated_statements + 1
        		else
******0 			has_side_effects = true
        			break
        		end
        	end

******0 	return {
        		has_side_effects = has_side_effects,
        		is_wrapped = is_wrapped,
        		is_simple_return = dominated_statements == 1 and not has_side_effects,
        	}
        end

        local function is_err_nil_check(bufnr, condition_node)
******0 	local text = vim.treesitter.get_node_text(condition_node, bufnr)
******0 	return text:match("err%s*!=%s*nil") or text:match("err%s*==%s*nil")
        end

        local function dim_region(bufnr, start_row, start_col, end_row, end_col)
******0 	for row = start_row, end_row do
******0 		local line = vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false)[1]
******0 		if not line then
        			goto continue
        		end

******0 		local col_start = (row == start_row) and start_col or 0
******0 		local col_end = (row == end_row) and end_col or #line

******0 		for col = col_start, col_end - 1 do
******0 			local captures = vim.treesitter.get_captures_at_pos(bufnr, row, col)

******0 			if #captures > 0 then
******0 				local capture = captures[#captures]
******0 				local hl_group = "@" .. capture.capture
******0 				local dimmed = get_dimmed_group(hl_group)

******0 				vim.api.nvim_buf_set_extmark(bufnr, ns, row, col, {
        					end_col = col + 1,
        					hl_group = dimmed,
        					priority = 200,
        				})
        			end
        		end

        		::continue::
        	end
        end

    360 function M.update_dims(bufnr)
     36 	bufnr = bufnr or vim.api.nvim_get_current_buf()

     36 	vim.api.nvim_buf_clear_namespace(bufnr, ns, 0, -1)

     36 	if not M.config.enabled then
     12 		return
        	end
     24 	if vim.bo[bufnr].filetype ~= "go" then
      6 		return
        	end

     18 	if not M.config.dim_simple_return and not M.config.dim_wrapped_return then
     12 		return
        	end

      6 	local parser = vim.treesitter.get_parser(bufnr, "go")
      6 	if not parser then
      6 		return
        	end

******0 	local tree = parser:parse()[1]
******0 	local root = tree:root()

******0 	local query = vim.treesitter.query.parse(
        		"go",
******0 		[[
                (if_statement
                    condition: (_) @condition
                    consequence: (block) @block)
******0     ]]
        	)

******0 	for id, node, _ in query:iter_captures(root, bufnr) do
******0 		local name = query.captures[id]

******0 		if name == "condition" then
******0 			if is_err_nil_check(bufnr, node) then
******0 				local if_node = node:parent()
******0 				local block_node = if_node:field("consequence")[1]

******0 				if block_node then
******0 					local analysis = analyze_if_err_block(bufnr, block_node)

******0 					local should_dim = false

******0 					if analysis.has_side_effects then
******0 						should_dim = false
******0 					elseif analysis.is_wrapped and M.config.dim_wrapped_return then
******0 						should_dim = true
******0 					elseif analysis.is_simple_return and not analysis.is_wrapped and M.config.dim_simple_return then
******0 						should_dim = true
        					end

******0 					if should_dim then
******0 						local start_row, start_col, end_row, end_col = if_node:range()
******0 						dim_region(bufnr, start_row, start_col, end_row, end_col)
        					end
        				end
        			end
        		end
        	end
        end

    360 local timer = nil

        local function debounced_update(bufnr)
******0 	if timer then
******0 		timer:stop()
******0 		timer:close()
        	end
******0 	timer = vim.loop.new_timer()
******0 	timer:start(
        		150,
        		0,
******0 		vim.schedule_wrap(function()
******0 			if vim.api.nvim_buf_is_valid(bufnr) then
******0 				M.update_dims(bufnr)
        			end
******0 			timer:stop()
******0 			timer:close()
******0 			timer = nil
        		end)
        	)
        end

    360 function M.setup(opts)
    120 	opts = opts or {}

    120 	M.config = vim.tbl_deep_extend("force", M.config, opts)

    120 	target_color = M.config.dim_target or get_bg_color()

    120 	local group = vim.api.nvim_create_augroup("GoErrorDim", { clear = true })

    240 	vim.api.nvim_create_autocmd("ColorScheme", {
    120 		group = group,
        		callback = function()
      6 			clear_cache()
     12 			for _, buf in ipairs(vim.api.nvim_list_bufs()) do
      6 				if vim.bo[buf].filetype == "go" then
      6 					M.update_dims(buf)
        				end
        			end
        		end,
        	})

    240 	vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost" }, {
    120 		group = group,
    120 		pattern = "*.go",
        		callback = function(ev)
******0 			M.update_dims(ev.buf)
        		end,
        	})

    240 	vim.api.nvim_create_autocmd({ "TextChanged", "TextChangedI" }, {
    120 		group = group,
    120 		pattern = "*.go",
        		callback = function(ev)
******0 			debounced_update(ev.buf)
        		end,
        	})

    240 	vim.api.nvim_create_autocmd("InsertLeave", {
    120 		group = group,
    120 		pattern = "*.go",
        		callback = function(ev)
******0 			M.update_dims(ev.buf)
        		end,
        	})

    240 	vim.api.nvim_create_user_command("GoErrorDimToggle", function()
******0 		M.config.enabled = not M.config.enabled
******0 		M.update_dims()
******0 		print("Go error dim: " .. (M.config.enabled and "enabled" or "disabled"))
    120 	end, {})

    240 	vim.api.nvim_create_user_command("GoErrorDimStatus", function()
******0 		print(string.format(
        			"Go error dim: %s | simple_return: %s | wrapped_return: %s | percent: %d",
******0 			M.config.enabled and "ON" or "OFF",
******0 			M.config.dim_simple_return and "dim" or "normal",
******0 			M.config.dim_wrapped_return and "dim" or "normal",
******0 			M.config.dim_percent
        		))
    120 	end, {})
        end

    360 M._internal = {
    360 	blend_colors = blend_colors,
    360 	get_bg_color = get_bg_color,
        	get_dimmed_group = function(original_group)
    114 		return get_dimmed_group(original_group)
        	end,
        	clear_cache = function()
    144 		clear_cache()
        	end,
        	get_cache = function()
     24 		return dimmed_groups
        	end,
        	get_target_color = function()
     24 		return target_color
        	end,
        	set_target_color = function(color)
    108 		target_color = color
        	end,
    360 }

    360 return M

==============================================================================
lua/go-unfucked/import-hints.lua
==============================================================================
    156 local M = {}

    156 local ns = vim.api.nvim_create_namespace("go_import_hints")
    156 M.enabled = true

        local function get_imports(bufnr)
     30 	local imports = {}
     30 	local parser = vim.treesitter.get_parser(bufnr, "go")
     30 	if not parser then
     30 		return imports
        	end

******0 	local tree = parser:parse()[1]
******0 	local root = tree:root()

******0 	local query = vim.treesitter.query.parse(
        		"go",
******0 		[[
                (import_declaration
                    (import_spec
                        name: (package_identifier)? @alias
                        path: (interpreted_string_literal) @path)) @import
                (import_declaration
                    (import_spec_list
                        (import_spec
                            name: (package_identifier)? @alias
                            path: (interpreted_string_literal) @path))) @import
******0     ]]
        	)

******0 	for id, node, _ in query:iter_captures(root, bufnr) do
******0 		local name = query.captures[id]
******0 		if name == "path" then
******0 			local path = vim.treesitter.get_node_text(node, bufnr)
******0 			path = path:gsub('"', "")

******0 			local row, col = node:range()
******0 			local pkg_name = path:match("([^/]+)$")

******0 			local parent = node:parent()
******0 			local alias_node = parent and parent:field("name")[1]
******0 			local alias = alias_node and vim.treesitter.get_node_text(alias_node, bufnr) or pkg_name

******0 			table.insert(imports, {
        				path = path,
        				alias = alias,
        				pkg_name = pkg_name,
        				line = row,
        				col = col,
        			})
        		end
        	end

******0 	return imports
        end

        local function find_package_usages(bufnr, pkg_alias)
      6 	local usages = {}
      6 	local seen = {}

      6 	local parser = vim.treesitter.get_parser(bufnr, "go")
      6 	if not parser then
      6 		return usages
        	end

******0 	local tree = parser:parse()[1]
******0 	local root = tree:root()

******0 	local query = vim.treesitter.query.parse(
        		"go",
******0 		[[
                (selector_expression
                    operand: (identifier) @pkg
                    field: (field_identifier) @field)
******0     ]]
        	)

******0 	for id, node, _ in query:iter_captures(root, bufnr) do
******0 		local name = query.captures[id]
******0 		if name == "pkg" then
******0 			local pkg = vim.treesitter.get_node_text(node, bufnr)
******0 			if pkg == pkg_alias then
******0 				local parent = node:parent()
******0 				local field_node = parent:field("field")[1]
******0 				if field_node then
******0 					local symbol = vim.treesitter.get_node_text(field_node, bufnr)
******0 					if not seen[symbol] then
******0 						seen[symbol] = true
******0 						table.insert(usages, symbol)
        					end
        				end
        			end
        		end
        	end

******0 	table.sort(usages)
******0 	return usages
        end

    156 function M.update_hints(bufnr)
     42 	bufnr = bufnr or vim.api.nvim_get_current_buf()

     42 	vim.api.nvim_buf_clear_namespace(bufnr, ns, 0, -1)

     42 	if not M.enabled then
      6 		return
        	end
     36 	if vim.bo[bufnr].filetype ~= "go" then
     12 		return
        	end

     24 	local imports = get_imports(bufnr)

     24 	for _, imp in ipairs(imports) do
******0 		local usages = find_package_usages(bufnr, imp.alias)

******0 		if #usages > 0 then
******0 			local hint_text = " " .. table.concat(usages, ", ")

******0 			if #hint_text > 60 then
******0 				hint_text = hint_text:sub(1, 57) .. "..."
        			end

******0 			vim.api.nvim_buf_set_extmark(bufnr, ns, imp.line, 0, {
        				virt_text = { { hint_text, "Comment" } },
        				virt_text_pos = "eol",
        			})
        		else
******0 			vim.api.nvim_buf_set_extmark(bufnr, ns, imp.line, 0, {
        				virt_text = { { " unused", "DiagnosticWarn" } },
        				virt_text_pos = "eol",
        			})
        		end
        	end
        end

    156 function M.setup(opts)
    102 	opts = opts or {}
    102 	M.enabled = opts.enabled ~= false

    102 	local group = vim.api.nvim_create_augroup("GoImportHints", { clear = true })

    204 	vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost" }, {
    102 		group = group,
    102 		pattern = "*.go",
        		callback = function(ev)
******0 			vim.defer_fn(function()
******0 				M.update_hints(ev.buf)
******0 			end, 100)
        		end,
        	})

    204 	vim.api.nvim_create_autocmd({ "TextChanged", "TextChangedI" }, {
    102 		group = group,
    102 		pattern = "*.go",
        		callback = function(ev)
******0 			vim.defer_fn(function()
******0 				M.update_hints(ev.buf)
******0 			end, 500)
        		end,
        	})

    204 	vim.api.nvim_create_user_command("GoImportHints", function()
******0 		M.update_hints()
    102 	end, {})

    204 	vim.api.nvim_create_user_command("GoImportHintsToggle", function()
******0 		M.enabled = not M.enabled
******0 		if M.enabled then
******0 			M.update_hints()
        		else
******0 			vim.api.nvim_buf_clear_namespace(0, ns, 0, -1)
        		end
******0 		print("Go import hints: " .. (M.enabled and "enabled" or "disabled"))
    102 	end, {})
        end

    156 M._internal = {
    156 	get_imports = get_imports,
    156 	find_package_usages = find_package_usages,
        	get_namespace = function()
      6 		return ns
        	end,
    156 }

    156 return M

==============================================================================
lua/go-unfucked/init.lua
==============================================================================
      6 local M = {}

      6 function M.setup(opts)
     12 	opts = opts or {}

     12 	require("go-unfucked.import-hints").setup(opts.import_hints or {})
     12 	require("go-unfucked.receiver-highlight").setup(opts.receiver_highlight or {})
     12 	require("go-unfucked.error-dim").setup(opts.error_dim or {})
     12 	require("go-unfucked.shortnames").setup(opts.shortnames or {})
        end

      6 return M

==============================================================================
lua/go-unfucked/receiver-highlight.lua
==============================================================================
    194 local M = {}

    194 local ns = vim.api.nvim_create_namespace("go_receiver_hl")
    194 local saved_color = nil

        local function set_hl()
    256 	vim.api.nvim_set_hl(0, "GoReceiver", {
    128 		fg = saved_color or "#a855f7",
    128 		italic = true,
    128 		bold = true,
        	})
        end

    194 function M.highlight_identifier_usages(bufnr, node, name)
******0 	for child in node:iter_children() do
******0 		if child:type() == "identifier" then
******0 			local text = vim.treesitter.get_node_text(child, bufnr)
******0 			if text == name then
******0 				local row, col, _, end_col = child:range()
******0 				vim.api.nvim_buf_add_highlight(bufnr, ns, "GoReceiver", row, col, end_col)
        			end
        		end
******0 		M.highlight_identifier_usages(bufnr, child, name)
        	end
        end

    194 function M.highlight_receivers(bufnr)
     36 	bufnr = bufnr or vim.api.nvim_get_current_buf()
     36 	vim.api.nvim_buf_clear_namespace(bufnr, ns, 0, -1)

     36 	if vim.bo[bufnr].filetype ~= "go" then
     12 		return
        	end

     24 	local parser = vim.treesitter.get_parser(bufnr, "go")
     24 	if not parser then
     24 		return
        	end

******0 	local tree = parser:parse()[1]
******0 	local root = tree:root()

******0 	local query = vim.treesitter.query.parse(
        		"go",
******0 		[[
                (method_declaration
                    receiver: (parameter_list
                        (parameter_declaration
                            name: (identifier) @recv_name
                            type: (_) @recv_type))
                    body: (block) @body) @method
******0     ]]
        	)

******0 	for id, node, _ in query:iter_captures(root, bufnr) do
******0 		local name = query.captures[id]

******0 		if name == "recv_name" then
******0 			local recv_name = vim.treesitter.get_node_text(node, bufnr)
******0 			local row, col, _, end_col = node:range()

******0 			vim.api.nvim_buf_add_highlight(bufnr, ns, "GoReceiver", row, col, end_col)

******0 			local method_node = node:parent():parent():parent()
******0 			local body_node = method_node:field("body")[1]

******0 			if body_node then
******0 				M.highlight_identifier_usages(bufnr, body_node, recv_name)
        			end
        		end
        	end
        end

    194 function M.setup(opts)
     96 	opts = opts or {}
     96 	saved_color = opts.color

     96 	set_hl()

     96 	local group = vim.api.nvim_create_augroup("GoReceiverHighlight", { clear = true })

    192 	vim.api.nvim_create_autocmd("ColorScheme", {
     96 		group = group,
     96 		callback = set_hl,
        	})

    192 	vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost", "TextChanged", "TextChangedI", "InsertLeave" }, {
     96 		group = group,
     96 		pattern = "*.go",
        		callback = function(ev)
******0 			vim.defer_fn(function()
******0 				M.highlight_receivers(ev.buf)
******0 			end, 100)
        		end,
        	})
        end

    194 M._internal = {
    194 	set_hl = set_hl,
        	get_saved_color = function()
     18 		return saved_color
        	end,
        	set_saved_color = function(color)
     20 		saved_color = color
        	end,
        	get_namespace = function()
     12 		return ns
        	end,
    194 }

    194 return M

==============================================================================
lua/go-unfucked/shortnames.lua
==============================================================================
    341 local M = {}

    341 local ns = vim.api.nvim_create_namespace("go_shortnames")

    341 M.config = {
    341 	enabled = false,
    341 	binary = nil,
    341 }

        local function find_binary()
     61 	local candidates = {
     61 		vim.fn.exepath("shortnames-linter"),
     61 		vim.fn.expand("~/go/bin/shortnames-linter"),
     61 		vim.fn.expand("$GOPATH/bin/shortnames-linter"),
     61 		vim.fn.expand("$HOME/go/bin/shortnames-linter"),
     61 	}

    103 	for _, path in ipairs(candidates) do
     97 		if path ~= "" and vim.fn.executable(path) == 1 then
     55 			return path
        		end
        	end

      6 	return nil
        end

        local function find_go_mod(start_path)
     38 	local path = start_path
    118 	while path ~= "/" do
     98 		if vim.fn.filereadable(path .. "/go.mod") == 1 then
     18 			return path
        		end
     80 		path = vim.fn.fnamemodify(path, ":h")
        	end
     20 	return nil
        end

        local function parse_output(output, bufnr)
     64 	local diagnostics = {}
     64 	local filename = vim.api.nvim_buf_get_name(bufnr)

    146 	for line in output:gmatch("[^\r\n]+") do
     82 		local file, lnum, col, msg = line:match("^(.+):(%d+):(%d+): (.+)$")
     82 		if file and file == filename then
     86 			table.insert(diagnostics, {
     43 				bufnr = bufnr,
     43 				lnum = tonumber(lnum) - 1,
     43 				col = tonumber(col) - 1,
     43 				message = msg,
     43 				severity = vim.diagnostic.severity.WARN,
     43 				source = "shortnames",
        			})
        		end
        	end

     64 	return diagnostics
        end

    341 function M.run(bufnr)
     24 	bufnr = bufnr or vim.api.nvim_get_current_buf()

     24 	if not M.config.enabled then
******0 		return
        	end

     24 	if vim.bo[bufnr].filetype ~= "go" then
     12 		return
        	end

     12 	local filename = vim.api.nvim_buf_get_name(bufnr)
     12 	if filename == "" then
      4 		return
        	end

      8 	local filedir = vim.fn.fnamemodify(filename, ":h")
      8 	local go_mod_dir = find_go_mod(filedir)

      8 	if not go_mod_dir then
      8 		return
        	end

******0 	local binary = M.config.binary or find_binary()
******0 	if not binary then
******0 		return
        	end

******0 	local rel_dir = filedir:sub(#go_mod_dir + 2)
******0 	local pkg_path = "./" .. rel_dir

******0 	vim.fn.jobstart({ binary, pkg_path }, {
        		cwd = go_mod_dir,
        		stdout_buffered = true,
        		stderr_buffered = true,
        		on_stdout = function(_, data)
******0 			if data then
******0 				local output = table.concat(data, "\n")
******0 				local diagnostics = parse_output(output, bufnr)
******0 				vim.diagnostic.set(ns, bufnr, diagnostics)
        			end
        		end,
        		on_stderr = function(_, data)
******0 			if data then
******0 				local output = table.concat(data, "\n")
******0 				local diagnostics = parse_output(output, bufnr)
******0 				vim.diagnostic.set(ns, bufnr, diagnostics)
        			end
        		end,
        		on_exit = function(_, code)
******0 			if code == 0 then
******0 				vim.diagnostic.set(ns, bufnr, {})
        			end
        		end,
        	})
        end

    341 function M.clear(bufnr)
     24 	bufnr = bufnr or vim.api.nvim_get_current_buf()
     24 	vim.diagnostic.set(ns, bufnr, {})
        end

    341 function M.setup(opts)
     78 	opts = opts or {}
     78 	M.config = vim.tbl_deep_extend("force", M.config, opts)

     78 	if not M.config.enabled then
     18 		return
        	end

     60 	local binary = M.config.binary or find_binary()
     60 	if not binary then
******0 		vim.notify(
        			"shortnames-linter not found. Install: go install github.com/akaptelinin/shortnames-linter@latest",
******0 			vim.log.levels.WARN
        		)
******0 		return
        	end

     60 	M.config.binary = binary

     60 	local group = vim.api.nvim_create_augroup("GoShortnames", { clear = true })

    120 	vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost" }, {
     60 		group = group,
     60 		pattern = "*.go",
        		callback = function(ev)
******0 			M.run(ev.buf)
        		end,
        	})

    120 	vim.api.nvim_create_user_command("GoShortnamesRun", function()
******0 		M.run()
     60 	end, {})

    120 	vim.api.nvim_create_user_command("GoShortnamsClear", function()
******0 		M.clear()
     60 	end, {})

    120 	vim.api.nvim_create_user_command("GoShortnamesToggle", function()
******0 		M.config.enabled = not M.config.enabled
******0 		if M.config.enabled then
******0 			M.run()
******0 			print("Shortnames linter: enabled")
        		else
******0 			M.clear()
******0 			print("Shortnames linter: disabled")
        		end
     60 	end, {})
        end

    341 M._internal = {
    341 	find_binary = find_binary,
    341 	find_go_mod = find_go_mod,
    341 	parse_output = parse_output,
        	get_namespace = function()
      6 		return ns
        	end,
    341 }

    341 return M

==============================================================================
tests/deps/nvim-test-core/lua/nvim-test-core/init.lua
==============================================================================
        -- Test setup for busted
        -- Based on https://github.com/coder/claudecode.nvim

        -- Create mock vim API if we're running tests outside of Neovim
      6 if not _G.vim then
      6   _G.vim = require("nvim-test-core.vim_mock")
        end

        -- Ensure vim global is accessible
      6 _G.vim = _G.vim or {}

        -- Setup test globals
      6 _G.assert = require("luassert")

        -- Helper function to verify expectations
      6 _G.expect = function(value)
   1398   return {
            to_be = function(expected)
    580       assert.are.equal(expected, value)
            end,
            to_be_nil = function()
     48       assert.is_nil(value)
            end,
            to_be_true = function()
    264       assert.is_true(value)
            end,
            to_be_false = function()
     48       assert.is_false(value)
            end,
            to_be_table = function()
     84       assert.is_table(value)
            end,
            to_be_string = function()
******0       assert.is_string(value)
            end,
            to_be_function = function()
    174       assert.is_function(value)
            end,
            to_be_boolean = function()
******0       assert.is_boolean(value)
            end,
            to_be_at_least = function(expected)
******0       assert.is_true(value >= expected)
            end,
            to_have_key = function(key)
******0       assert.is_table(value)
******0       assert.not_nil(value[key])
            end,
            -- to_contain was here, moved to _G.assert_contains
            not_to_be_nil = function()
    194       assert.is_not_nil(value)
            end,
            -- not_to_contain was here, moved to _G.assert_not_contains
            to_be_truthy = function()
******0       assert.is_truthy(value)
            end,
            to_match = function(pattern)
      6       assert.is_string(value)
     12       assert.is_true(
      6         string.find(value, pattern, 1, true) ~= nil,
      6         "Expected string '" .. value .. "' to match pattern '" .. pattern .. "'"
              )
            end,
   1398   }
        end

      6 _G.assert_contains = function(actual_value, expected_pattern)
******0   if type(actual_value) == "string" then
******0     if type(expected_pattern) ~= "string" then
******0       error(
                "assert_contains expected a string pattern for a string actual_value, but expected_pattern was type: "
******0           .. type(expected_pattern)
              )
            end
******0     assert.is_true(
******0       string.find(actual_value, expected_pattern, 1, true) ~= nil,
******0       "Expected string '" .. actual_value .. "' to contain '" .. expected_pattern .. "'"
            )
******0   elseif type(actual_value) == "table" then
******0     local found = false
******0     for _, v in ipairs(actual_value) do
******0       if v == expected_pattern then
******0         found = true
                break
              end
            end
******0     assert.is_true(found, "Expected table to contain value: " .. tostring(expected_pattern))
          else
******0     error("assert_contains can only be used with string or table actual_values, got type: " .. type(actual_value))
          end
        end

      6 _G.assert_not_contains = function(actual_value, expected_pattern)
******0   if type(actual_value) == "string" then
******0     if type(expected_pattern) ~= "string" then
******0       error(
                "assert_not_contains expected a string pattern for a string actual_value, but expected_pattern was type: "
******0           .. type(expected_pattern)
              )
            end
******0     assert.is_true(
******0       string.find(actual_value, expected_pattern, 1, true) == nil,
******0       "Expected string '" .. actual_value .. "' NOT to contain '" .. expected_pattern .. "'"
            )
******0   elseif type(actual_value) == "table" then
******0     local found = false
******0     for _, v in ipairs(actual_value) do
******0       if v == expected_pattern then
******0         found = true
                break
              end
            end
******0     assert.is_false(found, "Expected table NOT to contain value: " .. tostring(expected_pattern))
          else
******0     error("assert_not_contains can only be used with string or table actual_values, got type: " .. type(actual_value))
          end
        end

        -- JSON encoding/decoding helpers for tests
      6 _G.json_encode = function(data)
******0   if type(data) == "table" then
******0     local parts = {}
******0     local is_array = true

            -- Check if it's an array (all numeric, positive keys) or an object
******0     for k, _ in pairs(data) do
******0       if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
******0         is_array = false
                break
              end
            end

******0     if is_array then
******0       table.insert(parts, "[")
******0       for i, v in ipairs(data) do
******0         if i > 1 then
******0           table.insert(parts, ",")
                end
******0         table.insert(parts, _G.json_encode(v))
              end
******0       table.insert(parts, "]")
            else
******0       table.insert(parts, "{")
******0       local first = true
******0       for k, v in pairs(data) do
******0         if not first then
******0           table.insert(parts, ",")
                end
******0         first = false
                -- Handle special Lua keywords as object keys
******0         local key_str = tostring(k)
******0         if key_str == "end" then
******0           table.insert(parts, '["end"]:')
                else
******0           table.insert(parts, '"' .. key_str .. '":')
                end
******0         table.insert(parts, _G.json_encode(v))
              end
******0       table.insert(parts, "}")
            end

******0     return table.concat(parts)
******0   elseif type(data) == "string" then
            -- Handle escape sequences properly
******0     local escaped = data
******0       :gsub("\\", "\\\\") -- Escape backslashes first
******0       :gsub('"', '\\"') -- Escape quotes
******0       :gsub("\n", "\\n") -- Escape newlines
******0       :gsub("\r", "\\r") -- Escape carriage returns
******0       :gsub("\t", "\\t") -- Escape tabs
******0     return '"' .. escaped .. '"'
******0   elseif type(data) == "boolean" then
******0     return data and "true" or "false"
******0   elseif type(data) == "number" then
******0     return tostring(data)
          else
******0     return "null"
          end
        end

        -- Simple JSON decoder for test purposes
      6 _G.json_decode = function(str)
******0   if not str or str == "" then
******0     return nil
          end

******0   local pos = 1

          local function skip_whitespace()
******0     while pos <= #str and str:sub(pos, pos):match("%s") do
******0       pos = pos + 1
            end
          end

          local function parse_value()
******0     skip_whitespace()
******0     if pos > #str then
******0       return nil
            end

******0     local char = str:sub(pos, pos)

******0     if char == '"' then
              -- Parse string
******0       pos = pos + 1
******0       local start = pos
******0       while pos <= #str and str:sub(pos, pos) ~= '"' do
******0         if str:sub(pos, pos) == "\\" then
******0           pos = pos + 1
                end
******0         pos = pos + 1
              end
******0       local value = str
******0         :sub(start, pos - 1)
******0         :gsub('\\"', '"') -- Unescape quotes
******0         :gsub("\\\\", "\\") -- Unescape backslashes
******0         :gsub("\\n", "\n") -- Unescape newlines
******0         :gsub("\\r", "\r") -- Unescape carriage returns
******0         :gsub("\\t", "\t") -- Unescape tabs
******0       pos = pos + 1
******0       return value
******0     elseif char == "{" then
              -- Parse object
******0       pos = pos + 1
******0       local obj = {}
******0       skip_whitespace()

******0       if pos <= #str and str:sub(pos, pos) == "}" then
******0         pos = pos + 1
******0         return obj
              end

              while true do
******0         skip_whitespace()

                -- Parse key
******0         if str:sub(pos, pos) ~= '"' and str:sub(pos, pos) ~= "[" then
                  break
                end

                local key
******0         if str:sub(pos, pos) == '"' then
******0           key = parse_value()
******0         elseif str:sub(pos, pos) == "[" then
                  -- Handle bracket notation like ["end"]
******0           pos = pos + 2 -- skip ["
******0           local start = pos
******0           while pos <= #str and str:sub(pos, pos) ~= '"' do
******0             pos = pos + 1
                  end
******0           key = str:sub(start, pos - 1)
******0           pos = pos + 2 -- skip "]
                else
                  break
                end

******0         skip_whitespace()
******0         if pos > #str or str:sub(pos, pos) ~= ":" then
                  break
                end
******0         pos = pos + 1

                -- Parse value
******0         local value = parse_value()
******0         obj[key] = value

******0         skip_whitespace()
******0         if pos > #str then
                  break
                end

******0         if str:sub(pos, pos) == "}" then
******0           pos = pos + 1
                  break
******0         elseif str:sub(pos, pos) == "," then
******0           pos = pos + 1
                else
                  break
                end
              end

******0       return obj
******0     elseif char == "[" then
              -- Parse array
******0       pos = pos + 1
******0       local arr = {}
******0       skip_whitespace()

******0       if pos <= #str and str:sub(pos, pos) == "]" then
******0         pos = pos + 1
******0         return arr
              end

              while true do
******0         table.insert(arr, parse_value())
******0         skip_whitespace()

******0         if pos > #str then
                  break
                end

******0         if str:sub(pos, pos) == "]" then
******0           pos = pos + 1
                  break
******0         elseif str:sub(pos, pos) == "," then
******0           pos = pos + 1
                else
                  break
                end
              end

******0       return arr
******0     elseif char:match("%d") or char == "-" then
              -- Parse number
******0       local start = pos
******0       if char == "-" then
******0         pos = pos + 1
              end
******0       while pos <= #str and str:sub(pos, pos):match("%d") do
******0         pos = pos + 1
              end
******0       if pos <= #str and str:sub(pos, pos) == "." then
******0         pos = pos + 1
******0         while pos <= #str and str:sub(pos, pos):match("%d") do
******0           pos = pos + 1
                end
              end
******0       return tonumber(str:sub(start, pos - 1))
******0     elseif str:sub(pos, pos + 3) == "true" then
******0       pos = pos + 4
******0       return true
******0     elseif str:sub(pos, pos + 4) == "false" then
******0       pos = pos + 5
******0       return false
******0     elseif str:sub(pos, pos + 3) == "null" then
******0       pos = pos + 4
******0       return nil
            else
******0       return nil
            end
          end

******0   return parse_value()
        end

        -- Return true to indicate setup was successful
      6 return {
      6   json_encode = _G.json_encode,
      6   json_decode = _G.json_decode,
      6 }

==============================================================================
tests/deps/nvim-test-core/lua/nvim-test-core/vim_mock.lua
==============================================================================
        --- Mock implementation of the Neovim API for tests.

        --- Spy functionality for testing.
        --- Provides a `spy.on` method to wrap functions and track their calls.
      6 if _G.spy == nil then
      6   _G.spy = {
            on = function(table, method_name)
******0       local original = table[method_name]
******0       local calls = {}

              table[method_name] = function(...)
******0         table.insert(calls, { vals = { ... } })
******0         if original then
******0           return original(...)
                end
              end

******0       table[method_name].calls = calls
******0       table[method_name].spy = function()
******0         return {
                  was_called = function(n)
******0             assert(#calls == n, "Expected " .. n .. " calls, got " .. #calls)
******0             return true
                  end,
                  was_not_called = function()
******0             assert(#calls == 0, "Expected 0 calls, got " .. #calls)
******0             return true
                  end,
                  was_called_with = function(...)
******0             local expected = { ... }
******0             assert(#calls > 0, "Function was never called")

******0             local last_call = calls[#calls].vals
******0             for i, v in ipairs(expected) do
******0               if type(v) == "table" and v._type == "match" then
                        -- Use custom matcher (simplified for this mock)
******0                 if v._match == "is_table" and type(last_call[i]) ~= "table" then
******0                   assert(false, "Expected table at arg " .. i)
                        end
                      else
******0                 assert(last_call[i] == v, "Argument mismatch at position " .. i)
                      end
                    end
******0             return true
                  end,
                }
              end

******0       return table[method_name]
            end,
      6   }

          --- Simple table matcher for spy assertions.
          --- Allows checking if an argument was a table.
      6   _G.match = {
            is_table = function()
******0       return { _type = "match", _match = "is_table" }
            end,
      6   }
        end

      6 local vim = {
      6   _buffers = {},
      6   _windows = { [1000] = { buf = 1, width = 80 } }, -- winid -> { buf, width, cursor, config }
      6   _win_tab = { [1000] = 1 }, -- winid -> tabpage
      6   _tab_windows = { [1] = { 1000 } }, -- tabpage -> { winids }
      6   _next_winid = 1001,
      6   _commands = {},
      6   _autocmds = {},
      6   _vars = {},
      6   _options = {},
      6   _current_window = 1000,
      6   _tabs = { [1] = true },
      6   _current_tabpage = 1,
      6   _namespaces = {},
      6   _next_ns_id = 1,
      6   _augroups = {},
      6   _augroup_names = {},
      6   _next_augroup_id = 1,
      6   _extmarks = {},
      6   _highlights = {},
      6   _hl_groups = {},
      6   _diagnostics = {},
      6   _executables = {},
      6   _readable_files = {},
      6   _jobs = {},
      6   _next_job_id = 1,

      6   api = {
            nvim_create_namespace = function(name)
   1065       if vim._namespaces[name] then
      2         return vim._namespaces[name]
              end
   1063       local id = vim._next_ns_id
   1063       vim._next_ns_id = vim._next_ns_id + 1
   1063       vim._namespaces[name] = id
   1063       return id
            end,

            nvim_buf_set_extmark = function(bufnr, ns_id, line, col, opts)
      4       vim._extmarks[ns_id] = vim._extmarks[ns_id] or {}
      4       local mark_id = #vim._extmarks[ns_id] + 1
      4       vim._extmarks[ns_id][mark_id] = {
      4         bufnr = bufnr,
      4         line = line,
      4         col = col,
      4         opts = opts,
      4       }
      4       return mark_id
            end,

            nvim_buf_clear_namespace = function(bufnr, ns_id, line_start, line_end)
    116       if vim._extmarks[ns_id] then
      2         vim._extmarks[ns_id] = {}
              end
    116       if vim._highlights[ns_id] then
******0         vim._highlights[ns_id] = {}
              end
            end,

            nvim_buf_add_highlight = function(bufnr, ns_id, hl_group, line, col_start, col_end)
      2       vim._highlights[ns_id] = vim._highlights[ns_id] or {}
      4       table.insert(vim._highlights[ns_id], {
      2         bufnr = bufnr,
      2         hl_group = hl_group,
      2         line = line,
      2         col_start = col_start,
      2         col_end = col_end,
              })
      2       return ns_id
            end,

            nvim_set_hl = function(ns_id, name, opts)
    380       vim._hl_groups[name] = opts
            end,

            nvim_get_hl = function(ns_id, opts)
    384       opts = opts or {}
    384       local name = opts.name
    384       if not name then
******0         return {}
              end
    384       local hl = vim._hl_groups[name]
    384       if not hl then
    242         return {}
              end
    142       if opts.link == false then
    110         return hl
              end
     32       return hl
            end,

            nvim_create_user_command = function(name, callback, opts)
    626       vim._commands[name] = {
    626         callback = callback,
    626         opts = opts,
    626       }
            end,

            nvim_create_augroup = function(name, opts)
    384       if vim._augroups[name] then
     30         if opts and opts.clear then
     30           vim._autocmds[name] = { opts = opts, events = {} }
                end
     30         return vim._augroups[name]
              end
    354       local id = vim._next_augroup_id
    354       vim._next_augroup_id = vim._next_augroup_id + 1
    354       vim._augroups[name] = id
    354       vim._augroup_names[id] = name
    354       vim._autocmds[name] = {
    354         opts = opts,
    354         events = {},
    354       }
    354       return id
            end,

            nvim_create_autocmd = function(events, opts)
    940       local group = opts.group or "default"
    940       if type(group) == "number" then
    940         group = vim._augroup_names[group] or "default"
              end
    940       if not vim._autocmds[group] then
******0         vim._autocmds[group] = {
                  opts = {},
                  events = {},
                }
              end

    940       local id = #vim._autocmds[group].events + 1
    940       vim._autocmds[group].events[id] = {
    940         events = events,
    940         opts = opts,
    940       }

    940       return id
            end,

            nvim_clear_autocmds = function(opts)
******0       if opts.group then
******0         vim._autocmds[opts.group] = nil
              end
            end,

            nvim_get_current_buf = function()
      2       return 1
            end,

            nvim_buf_get_name = function(bufnr)
     54       return vim._buffers[bufnr] and vim._buffers[bufnr].name or ""
            end,

            nvim_win_get_cursor = function(winid)
      4       return vim._windows[winid] and vim._windows[winid].cursor or { 1, 0 }
            end,

            nvim_win_set_cursor = function(winid, pos)
      2       if vim._windows[winid] then
      2         vim._windows[winid].cursor = pos
              end
            end,

            nvim_buf_get_lines = function(bufnr, start, end_line, strict)
      2       if not vim._buffers[bufnr] then
******0         return {}
              end

      2       local lines = vim._buffers[bufnr].lines or {}
      2       local result = {}

      2       for i = start + 1, end_line do
******0         table.insert(result, lines[i] or "")
              end

      2       return result
            end,

            nvim_buf_get_option = function(bufnr, name)
******0       if not vim._buffers[bufnr] then
******0         return nil
              end

******0       return vim._buffers[bufnr].options and vim._buffers[bufnr].options[name] or nil
            end,

            nvim_buf_delete = function(bufnr, opts)
******0       vim._buffers[bufnr] = nil
            end,

            nvim_echo = function(chunks, history, opts)
              -- Store the last echo message for test assertions.
******0       vim._last_echo = {
                chunks = chunks,
                history = history,
                opts = opts,
              }
            end,

            nvim_err_writeln = function(msg)
******0       vim._last_error = msg
            end,
            nvim_buf_set_name = function(bufnr, name)
******0       if vim._buffers[bufnr] then
******0         vim._buffers[bufnr].name = name
              else
                -- TODO: Consider if error handling for 'buffer not found' is needed for tests.
              end
            end,
            nvim_set_option_value = function(name, value, opts)
              -- Note: This mock simplifies 'scope = "local"' handling.
              -- In a real nvim_set_option_value, 'local' scope would apply to a specific
              -- buffer or window. Here, it's stored in a general options table if not
              -- a buffer-local option, or in the buffer's options table if `opts.buf` is provided.
              -- A more complex mock might be needed for intricate scope-related tests.
******0       if opts and opts.buf then
******0         if vim._buffers[opts.buf] then
******0           if not vim._buffers[opts.buf].options then
******0             vim._buffers[opts.buf].options = {}
                  end
******0           vim._buffers[opts.buf].options[name] = value
                else
                  -- TODO: Consider if error handling for 'buffer not found' is needed for tests.
                end
              else
******0         vim._options[name] = value
              end
            end,

            -- Add missing API functions for diff tests
            nvim_create_buf = function(listed, scratch)
******0       local bufnr = #vim._buffers + 1
******0       vim._buffers[bufnr] = {
                name = "",
                lines = {},
                options = {},
                listed = listed,
                scratch = scratch,
              }
******0       return bufnr
            end,

            nvim_buf_set_lines = function(bufnr, start, end_line, strict_indexing, replacement)
******0       if not vim._buffers[bufnr] then
******0         vim._buffers[bufnr] = { lines = {}, options = {} }
              end
******0       vim._buffers[bufnr].lines = replacement or {}
            end,

            nvim_buf_set_option = function(bufnr, name, value)
******0       if not vim._buffers[bufnr] then
******0         vim._buffers[bufnr] = { lines = {}, options = {} }
              end
******0       if not vim._buffers[bufnr].options then
******0         vim._buffers[bufnr].options = {}
              end
******0       vim._buffers[bufnr].options[name] = value
            end,

            nvim_buf_is_valid = function(bufnr)
******0       return vim._buffers[bufnr] ~= nil
            end,

            nvim_buf_is_loaded = function(bufnr)
              -- In our mock, all valid buffers are considered loaded
******0       return vim._buffers[bufnr] ~= nil
            end,

            nvim_list_bufs = function()
              -- Return a list of buffer IDs
     10       local bufs = {}
     20       for bufnr, _ in pairs(vim._buffers) do
     10         table.insert(bufs, bufnr)
              end
     10       return bufs
            end,

            nvim_buf_call = function(bufnr, callback)
              -- Mock implementation - just call the callback
******0       if vim._buffers[bufnr] then
******0         return callback()
              end
******0       error("Invalid buffer id: " .. tostring(bufnr))
            end,

            nvim_get_autocmds = function(opts)
******0       if opts and opts.group then
******0         local group = vim._autocmds[opts.group]
******0         if group and group.events then
******0           local result = {}
******0           for id, event in pairs(group.events) do
******0             table.insert(result, {
                      id = id,
                      group = opts.group,
                      event = event.events,
                      pattern = event.opts.pattern,
                      callback = event.opts.callback,
                    })
                  end
******0           return result
                end
              end
******0       return {}
            end,

            nvim_del_autocmd = function(id)
              -- Find and remove autocmd by id
******0       for group_name, group in pairs(vim._autocmds) do
******0         if group.events and group.events[id] then
******0           group.events[id] = nil
******0           return
                end
              end
            end,

            nvim_get_current_win = function()
      2       return vim._current_window
            end,

            nvim_set_current_win = function(winid)
              -- Mock implementation - just track that it was called
******0       vim._current_window = winid
******0       return true
            end,

            nvim_list_wins = function()
              -- Return a list of window IDs for the current tab
******0       local wins = {}
******0       local list = vim._tab_windows[vim._current_tabpage] or {}
******0       for _, winid in ipairs(list) do
******0         if vim._windows[winid] then
******0           table.insert(wins, winid)
                end
              end
******0       if #wins == 0 then
                -- Always have at least one window
******0         table.insert(wins, vim._current_window)
              end
******0       return wins
            end,

            nvim_win_set_buf = function(winid, bufnr)
******0       if not vim._windows[winid] then
******0         vim._windows[winid] = {}
              end
******0       local old_buf = vim._windows[winid].buf
******0       vim._windows[winid].buf = bufnr
              -- If old buffer is no longer displayed in any window, and has bufhidden=wipe, delete it
******0       if old_buf and vim._buffers[old_buf] then
******0         local still_visible = false
******0         for _, w in pairs(vim._windows) do
******0           if w.buf == old_buf then
******0             still_visible = true
                    break
                  end
                end
******0         if not still_visible then
******0           local opts = vim._buffers[old_buf].options or {}
******0           if opts.bufhidden == "wipe" then
******0             vim._buffers[old_buf] = nil
                  end
                end
              end
            end,

            nvim_win_get_buf = function(winid)
      2       if vim._windows[winid] then
      2         return vim._windows[winid].buf or 1
              end
******0       return 1 -- Default buffer
            end,

            nvim_win_is_valid = function(winid)
******0       return vim._windows[winid] ~= nil
            end,

            nvim_win_close = function(winid, force)
******0       local old_buf = vim._windows[winid] and vim._windows[winid].buf
******0       vim._windows[winid] = nil
              -- remove from tab mapping
******0       local tab = vim._win_tab[winid]
******0       if tab and vim._tab_windows[tab] then
******0         local new_list = {}
******0         for _, w in ipairs(vim._tab_windows[tab]) do
******0           if w ~= winid then
******0             table.insert(new_list, w)
                  end
                end
******0         vim._tab_windows[tab] = new_list
              end
******0       vim._win_tab[winid] = nil
              -- Apply bufhidden=wipe if now hidden
******0       if old_buf and vim._buffers[old_buf] then
******0         local still_visible = false
******0         for _, w in pairs(vim._windows) do
******0           if w.buf == old_buf then
******0             still_visible = true
                    break
                  end
                end
******0         if not still_visible then
******0           local opts = vim._buffers[old_buf].options or {}
******0           if opts.bufhidden == "wipe" then
******0             vim._buffers[old_buf] = nil
                  end
                end
              end
            end,

            nvim_win_call = function(winid, callback)
              -- Mock implementation - just call the callback
******0       if vim._windows[winid] then
******0         return callback()
              end
******0       error("Invalid window id: " .. tostring(winid))
            end,

            nvim_win_get_config = function(winid)
              -- Mock implementation - return empty config for non-floating windows
******0       if vim._windows[winid] then
******0         return vim._windows[winid].config or {}
              end
******0       return {}
            end,

            nvim_win_set_width = function(winid, width)
******0       if vim._windows[winid] then
******0         vim._windows[winid].width = width
              end
            end,

            nvim_win_get_width = function(winid)
******0       return (vim._windows[winid] and vim._windows[winid].width) or 80
            end,

            nvim_get_current_tabpage = function()
******0       return vim._current_tabpage
            end,

            nvim_set_current_tabpage = function(tab)
******0       if vim._tabs[tab] then
******0         vim._current_tabpage = tab
              end
            end,

            nvim_tabpage_is_valid = function(tab)
******0       return vim._tabs[tab] == true
            end,

            nvim_tabpage_get_number = function(tab)
******0       return tab
            end,

            nvim_tabpage_set_var = function(tabpage, name, value)
              -- Mock tabpage variable setting
            end,

            nvim_win_get_tabpage = function(winid)
******0       return vim._win_tab[winid] or vim._current_tabpage
            end,

            nvim_buf_line_count = function(bufnr)
      2       local b = vim._buffers[bufnr]
      2       if not b or not b.lines then
******0         return 0
              end
      2       return #b.lines
            end,
      6   },

      6   fn = {
            getpid = function()
******0       return 12345
            end,

            expand = function(path)
     38       return path:gsub("~", "/home/user")
            end,

            filereadable = function(path)
              -- Check mock readable files first
    124       if vim._readable_files[path] then
     30         return 1
              end
              -- Fallback to actual file check
     94       local file = io.open(path, "r")
     94       if file then
******0         file:close()
******0         return 1
              end
     94       return 0
            end,

            executable = function(path)
     79       return vim._executables[path] and 1 or 0
            end,

            exepath = function(cmd)
              -- Check if command is in executables mock
******0       for path, _ in pairs(vim._executables) do
******0         if path:match(cmd .. "$") then
******0           return path
                end
              end
******0       return ""
            end,

            jobstart = function(cmd, opts)
******0       local job_id = vim._next_job_id
******0       vim._next_job_id = vim._next_job_id + 1
******0       vim._jobs[job_id] = {
                cmd = cmd,
                opts = opts,
                running = true,
              }
              -- Immediately call on_exit with success for testing
******0       if opts and opts.on_exit then
******0         vim.schedule(function()
******0           opts.on_exit(job_id, 0, "exit")
                end)
              end
******0       return job_id
            end,

            bufnr = function(name)
******0       for bufnr, buf in pairs(vim._buffers) do
******0         if buf.name == name then
******0           return bufnr
                end
              end
******0       return -1
            end,

            buflisted = function(bufnr)
******0       return vim._buffers[bufnr] and vim._buffers[bufnr].listed and 1 or 0
            end,

            mkdir = function(path, flags)
******0       return 1
            end,

            getpos = function(mark)
******0       if mark == "'<" then
******0         return { 0, 1, 1, 0 }
******0       elseif mark == "'>" then
******0         return { 0, 1, 10, 0 }
              end
******0       return { 0, 0, 0, 0 }
            end,

            mode = function()
******0       return "n"
            end,

            fnameescape = function(name)
******0       return name:gsub(" ", "\\ ")
            end,

            getcwd = function()
      2       return "/home/user/project"
            end,

            fnamemodify = function(path, modifier)
    100       if modifier == ":t" then
******0         return path:match("([^/]+)$") or path
    100       elseif modifier == ":h" then
    100         return path:match("(.+)/[^/]*$") or "/"
******0       elseif modifier == ":p" then
******0         return path
******0       elseif modifier == ":e" then
******0         return path:match("%.([^./]+)$") or ""
******0       elseif modifier == ":r" then
******0         return path:match("(.+)%.[^./]+$") or path
              end
******0       return path
            end,

            has = function(feature)
******0       if feature == "nvim-0.8.0" then
******0         return 1
              end
******0       return 0
            end,
            stdpath = function(type)
******0       if type == "cache" then
******0         return "/tmp/nvim_mock_cache"
******0       elseif type == "config" then
******0         return "/tmp/nvim_mock_config"
******0       elseif type == "data" then
******0         return "/tmp/nvim_mock_data"
******0       elseif type == "temp" then
******0         return "/tmp"
              else
******0         return "/tmp/nvim_mock_stdpath_" .. type
              end
            end,
            tempname = function()
              -- Return a somewhat predictable temporary name for testing.
              -- The random number ensures some uniqueness if called multiple times.
******0       return "/tmp/nvim_mock_tempfile_" .. math.random(1, 100000)
            end,

            writefile = function(lines, filename, flags)
              -- Mock implementation - just record that it was called
******0       vim._written_files = vim._written_files or {}
******0       vim._written_files[filename] = lines
******0       return 0
            end,

            localtime = function()
******0       return os.time()
            end,
      6   },

          cmd = function(command)
            -- Store the last command for test assertions.
******0     vim._last_command = command
            -- Implement minimal behavior for essential commands
******0     if command == "tabnew" then
              -- Create new tab with a new window and an unnamed buffer
******0       local new_tab = 1
******0       for k, _ in pairs(vim._tabs) do
******0         if k >= new_tab then
******0           new_tab = k + 1
                end
              end
******0       vim._tabs[new_tab] = true
******0       vim._current_tabpage = new_tab

              -- Create a new unnamed buffer
******0       local bufnr = vim.api.nvim_create_buf(false, true)
******0       vim._buffers[bufnr].name = ""
******0       vim._buffers[bufnr].options = vim._buffers[bufnr].options or {}
******0       vim._buffers[bufnr].options.modified = false
******0       vim._buffers[bufnr].lines = { "" }

              -- Create a new window for this tab
******0       local winid = vim._next_winid
******0       vim._next_winid = vim._next_winid + 1
******0       vim._windows[winid] = { buf = bufnr, width = 80 }
******0       vim._win_tab[winid] = new_tab
******0       vim._tab_windows[new_tab] = { winid }
******0       vim._current_window = winid
******0     elseif command:match("vsplit") then
              -- Split current window vertically; new window shows same buffer
******0       local cur = vim._current_window
******0       local curtab = vim._current_tabpage
******0       local bufnr = vim._windows[cur] and vim._windows[cur].buf or 1
******0       local winid = vim._next_winid
******0       vim._next_winid = vim._next_winid + 1
******0       vim._windows[winid] = { buf = bufnr, width = 80 }
******0       vim._win_tab[winid] = curtab
******0       local list = vim._tab_windows[curtab] or {}
******0       table.insert(list, winid)
******0       vim._tab_windows[curtab] = list
******0       vim._current_window = winid
******0     elseif command:match("[^%w]split$") or command == "split" then
              -- Horizontal split: model similarly by creating a new window entry
******0       local cur = vim._current_window
******0       local curtab = vim._current_tabpage
******0       local bufnr = vim._windows[cur] and vim._windows[cur].buf or 1
******0       local winid = vim._next_winid
******0       vim._next_winid = vim._next_winid + 1
******0       vim._windows[winid] = { buf = bufnr, width = 80 }
******0       vim._win_tab[winid] = curtab
******0       local list = vim._tab_windows[curtab] or {}
******0       table.insert(list, winid)
******0       vim._tab_windows[curtab] = list
******0       vim._current_window = winid
******0     elseif command:match("^edit ") then
******0       local path = command:sub(6)
              -- Remove surrounding quotes if any
******0       path = path:gsub("^'", ""):gsub("'$", "")
              -- Find or create buffer for this path
******0       local bufnr = -1
******0       for id, b in pairs(vim._buffers) do
******0         if b.name == path then
******0           bufnr = id
                  break
                end
              end
******0       if bufnr == -1 then
******0         bufnr = vim.api.nvim_create_buf(true, false)
******0         vim._buffers[bufnr].name = path
                -- Try to read file content if exists
******0         local f = io.open(path, "r")
******0         if f then
                  -- Only read if the handle supports :read (avoid tests that stub io.open for writing only)
******0           local ok_read = (type(f) == "userdata") or (type(f) == "table" and type(f.read) == "function")
******0           if ok_read then
******0             local content = f:read("*a") or ""
******0             if type(f.close) == "function" then
******0               pcall(f.close, f)
                    end
******0             vim._buffers[bufnr].lines = {}
******0             for line in (content .. "\n"):gmatch("(.-)\n") do
******0               table.insert(vim._buffers[bufnr].lines, line)
                    end
                  else
                    -- Gracefully ignore non-readable stubs
                  end
                end
              end
******0       vim.api.nvim_win_set_buf(vim._current_window, bufnr)
******0     elseif command:match("^tabclose") then
              -- Close current tab: remove all its windows and switch to the lowest-numbered remaining tab
******0       local curtab = vim._current_tabpage
******0       local wins = vim._tab_windows[curtab] or {}
******0       for _, w in ipairs(wins) do
******0         if vim._windows[w] then
******0           vim.api.nvim_win_close(w, true)
                end
              end
******0       vim._tab_windows[curtab] = nil
******0       vim._tabs[curtab] = nil
              -- switch to lowest-numbered existing tab
              local new_cur = nil
******0       for t, _ in pairs(vim._tabs) do
******0         if not new_cur or t < new_cur then
******0           new_cur = t
                end
              end
******0       if not new_cur then
                -- recreate a default tab and window
******0         vim._tabs[1] = true
******0         local bufnr = vim.api.nvim_create_buf(true, false)
******0         vim._buffers[bufnr].name = "/home/user/project/test.lua"
******0         local winid = vim._next_winid
******0         vim._next_winid = vim._next_winid + 1
******0         vim._windows[winid] = { buf = bufnr, width = 80 }
******0         vim._win_tab[winid] = 1
******0         vim._tab_windows[1] = { winid }
******0         vim._current_window = winid
******0         vim._current_tabpage = 1
              else
******0         vim._current_tabpage = new_cur
******0         local list = vim._tab_windows[new_cur]
******0         if list and #list > 0 then
******0           vim._current_window = list[1]
                end
              end
            else
              -- other commands (wincmd etc.) are recorded but not simulated
            end
          end,

      6   json = {
            encode = function(data)
              -- Extremely simplified JSON encoding, sufficient for basic test cases.
              -- Does not handle all JSON types or edge cases.
******0       if type(data) == "table" then
******0         local parts = {}
******0         for k, v in pairs(data) do
                  local val
******0           if type(v) == "string" then
******0             val = '"' .. v .. '"'
******0           elseif type(v) == "table" then
******0             val = vim.json.encode(v)
                  else
******0             val = tostring(v)
                  end

******0           if type(k) == "number" then
******0             table.insert(parts, val)
                  else
******0             table.insert(parts, '"' .. k .. '":' .. val)
                  end
                end

******0         if #parts > 0 and type(next(data)) == "number" then
******0           return "[" .. table.concat(parts, ",") .. "]"
                else
******0           return "{" .. table.concat(parts, ",") .. "}"
                end
******0       elseif type(data) == "string" then
******0         return '"' .. data .. '"'
              else
******0         return tostring(data)
              end
            end,

            decode = function(json_str)
              -- This is a non-functional stub for `vim.json.decode`.
              -- If tests require actual JSON decoding, a proper library or a more
              -- sophisticated mock implementation would be necessary.
******0       return {}
            end,
      6   },

          -- Additional missing vim functions
          wait = function(timeout, condition, interval, fast_only)
            -- Optimized mock implementation for faster test execution
******0     local start_time = os.clock()
******0     interval = interval or 10 -- Reduced from 200ms to 10ms for faster polling
******0     timeout = timeout or 1000

******0     while (os.clock() - start_time) * 1000 < timeout do
******0       if condition and condition() then
******0         return true
              end
              -- Add a small sleep to prevent busy-waiting and reduce CPU usage
******0       os.execute("sleep 0.001") -- 1ms sleep
            end

******0     return false
          end,

      6   keymap = {
            set = function(mode, lhs, rhs, opts)
              -- Mock keymap setting
******0       vim._keymaps = vim._keymaps or {}
******0       vim._keymaps[mode] = vim._keymaps[mode] or {}
******0       vim._keymaps[mode][lhs] = { rhs = rhs, opts = opts }
            end,
      6   },

          split = function(str, sep)
******0     local result = {}
******0     local pattern = "([^" .. sep .. "]+)"
******0     for match in str:gmatch(pattern) do
******0       table.insert(result, match)
            end
******0     return result
          end,

          -- Add tbl_extend function for compatibility
          tbl_extend = function(behavior, ...)
******0     local tables = { ... }
******0     local result = {}

******0     for _, tbl in ipairs(tables) do
******0       for k, v in pairs(tbl) do
******0         if behavior == "force" or result[k] == nil then
******0           result[k] = v
                end
              end
            end

******0     return result
          end,

     12   g = setmetatable({}, {
            __index = function(_, key)
******0       return vim._vars[key]
            end,
            __newindex = function(_, key, value)
******0       vim._vars[key] = value
            end,
      6   }),

     12   b = setmetatable({}, {
            __index = function(_, bufnr)
              -- Return buffer-local variables for the given buffer
******0       if vim._buffers[bufnr] then
******0         if not vim._buffers[bufnr].b_vars then
******0           vim._buffers[bufnr].b_vars = {}
                end
******0         return vim._buffers[bufnr].b_vars
              end
******0       return {}
            end,
            __newindex = function(_, bufnr, vars)
              -- Set buffer-local variables for the given buffer
******0       if vim._buffers[bufnr] then
******0         vim._buffers[bufnr].b_vars = vars
              end
            end,
      6   }),

          deepcopy = function(tbl)
******0     if type(tbl) ~= "table" then
******0       return tbl
            end

******0     local copy = {}
******0     for k, v in pairs(tbl) do
******0       if type(v) == "table" then
******0         copy[k] = vim.deepcopy(v)
              else
******0         copy[k] = v
              end
            end

******0     return copy
          end,

          tbl_deep_extend = function(behavior, ...)
    198     local result = {}
    198     local tables = { ... }

    594     for _, tbl in ipairs(tables) do
   1152       for k, v in pairs(tbl) do
    756         if type(v) == "table" and type(result[k]) == "table" then
******0           result[k] = vim.tbl_deep_extend(behavior, result[k], v)
                else
    756           result[k] = v
                end
              end
            end

    198     return result
          end,

          inspect = function(obj) -- Keep the mock inspect for controlled output
******0     if type(obj) == "string" then
******0       return '"' .. obj .. '"'
******0     elseif type(obj) == "table" then
******0       local items = {}
******0       local is_array = true
******0       local i = 1
******0       for k, _ in pairs(obj) do
******0         if k ~= i then
******0           is_array = false
                  break
                end
******0         i = i + 1
              end

******0       if is_array then
******0         for _, v_arr in ipairs(obj) do
******0           table.insert(items, vim.inspect(v_arr))
                end
******0         return "{" .. table.concat(items, ", ") .. "}" -- Lua tables are 1-indexed, show as {el1, el2}
              else -- map-like table
******0         for k_map, v_map in pairs(obj) do
                  local key_str
******0           if type(k_map) == "string" then
******0             key_str = k_map
                  else
******0             key_str = "[" .. vim.inspect(k_map) .. "]"
                  end
******0           table.insert(items, key_str .. " = " .. vim.inspect(v_map))
                end
******0         return "{" .. table.concat(items, ", ") .. "}"
              end
******0     elseif type(obj) == "boolean" then
******0       return tostring(obj)
******0     elseif type(obj) == "number" then
******0       return tostring(obj)
******0     elseif obj == nil then
******0       return "nil"
            else
******0       return type(obj) .. ": " .. tostring(obj) -- Fallback for other types
            end
          end,

          --- Stub for the `vim.loop` module.
          --- Provides minimal implementations for TCP and timer functionalities
          --- required by some plugin tests.
      6   loop = {
            new_tcp = function()
******0       return {
                bind = function(self, host, port)
******0           return true
                end,
                listen = function(self, backlog, callback)
******0           return true
                end,
                accept = function(self, client)
******0           return true
                end,
                read_start = function(self, callback)
******0           return true
                end,
                write = function(self, data, callback)
******0           if callback then
******0             callback()
                  end
******0           return true
                end,
                close = function(self)
******0           return true
                end,
                is_closing = function(self)
******0           return false
                end,
              }
            end,
            new_timer = function()
******0       return {
                start = function(self, timeout, repeat_interval, callback)
******0           return true
                end,
                stop = function(self)
******0           return true
                end,
                close = function(self)
******0           return true
                end,
              }
            end,
            now = function()
******0       return os.time() * 1000
            end,
            timer_stop = function(timer)
******0       return true
            end,
      6   },

          schedule = function(callback)
******0     callback()
          end,

          defer_fn = function(fn, timeout)
            -- For testing purposes, this mock executes the deferred function immediately
            -- instead of after a timeout.
******0     fn()
          end,

          notify = function(msg, level, opts)
            -- Store the last notification for test assertions.
******0     vim._last_notify = {
              msg = msg,
              level = level,
              opts = opts,
            }
            -- Return a mock notification ID, as some code might expect a return value.
******0     return 1
          end,

      6   log = {
      6     levels = {
      6       TRACE = 0,
      6       DEBUG = 1,
      6       ERROR = 2,
      6       WARN = 3,
      6       INFO = 4,
      6     },
            -- Provides log level constants, similar to `vim.log.levels`.
            -- The actual logging functions (trace, debug, etc.) are no-ops in this mock.
            -- These are primarily for `vim.notify` level compatibility if used.
      6     trace = function(...) end,
      6     debug = function(...) end,
      6     info = function(...) end,
      6     warn = function(...) end,
      6     error = function(...) end,
      6   },

      6   diagnostic = {
      6     severity = {
      6       ERROR = 1,
      6       WARN = 2,
      6       INFO = 3,
      6       HINT = 4,
      6     },
            set = function(ns_id, bufnr, diagnostics, opts)
     24       vim._diagnostics[ns_id] = vim._diagnostics[ns_id] or {}
     24       vim._diagnostics[ns_id][bufnr] = diagnostics
            end,
            get = function(bufnr, opts)
******0       local result = {}
******0       local ns_id = opts and opts.namespace
******0       if ns_id then
******0         if vim._diagnostics[ns_id] and vim._diagnostics[ns_id][bufnr] then
******0           return vim._diagnostics[ns_id][bufnr]
                end
              else
******0         for _, ns_diags in pairs(vim._diagnostics) do
******0           if ns_diags[bufnr] then
******0             for _, d in ipairs(ns_diags[bufnr]) do
******0               table.insert(result, d)
                    end
                  end
                end
              end
******0       return result
            end,
            reset = function(ns_id, bufnr)
******0       if vim._diagnostics[ns_id] then
******0         if bufnr then
******0           vim._diagnostics[ns_id][bufnr] = nil
                else
******0           vim._diagnostics[ns_id] = {}
                end
              end
            end,
      6   },
        }

        -- Helper function to split lines
        local function split_lines(str)
   1175   local lines = {}
   2364   for line in str:gmatch("([^\n]*)\n?") do
   1189     table.insert(lines, line)
          end
   1175   return lines
        end

        --- Internal helper functions for tests to manipulate the mock's state.
        --- These are not part of the Neovim API but are useful for setting up
        --- specific scenarios for testing plugins.
      6 vim._mock = {
          add_buffer = function(bufnr, name, content, opts)
   1175     vim._buffers[bufnr] = {
   1175       name = name,
   1175       lines = type(content) == "string" and split_lines(content) or content,
   1175       options = opts or {},
   1175       listed = true,
   1175     }
          end,

      6   split_lines = split_lines,

          add_window = function(winid, bufnr, cursor)
   1041     vim._windows[winid] = {
   1041       buf = bufnr,
   1041       cursor = cursor or { 1, 0 },
   1041       width = 80,
   1041     }
          end,

          reset = function()
   1093     vim._buffers = {}
   1093     vim._windows = {}
   1093     vim._win_tab = {}
   1093     vim._tab_windows = {}
   1093     vim._next_winid = 1000
   1093     vim._commands = {}
   1093     vim._autocmds = {}
   1093     vim._vars = {}
   1093     vim._options = {}
   1093     vim._last_command = nil
   1093     vim._last_echo = nil
   1093     vim._last_error = nil
   1093     vim._namespaces = {}
   1093     vim._next_ns_id = 1
   1093     vim._augroups = {}
   1093     vim._augroup_names = {}
   1093     vim._next_augroup_id = 1
   1093     vim._extmarks = {}
   1093     vim._highlights = {}
   1093     vim._hl_groups = {}
   1093     vim._diagnostics = {}
   1093     vim._executables = {}
   1093     vim._readable_files = {}
   1093     vim._jobs = {}
   1093     vim._next_job_id = 1
          end,

          set_executable = function(path, value)
     80     vim._executables[path] = value and true or nil
          end,

          set_file_readable = function(path, value)
     30     vim._readable_files[path] = value and true or nil
          end,

          stub = function(path, fn)
     10     local parts = {}
     34     for part in path:gmatch("[^.]+") do
     24       table.insert(parts, part)
            end

     10     local target = vim
     24     for i = 1, #parts - 1 do
     14       if target[parts[i]] == nil then
     10         target[parts[i]] = {}
              end
     14       target = target[parts[i]]
            end
     10     target[parts[#parts]] = fn
          end,
      6 }

      6 if _G.vim == nil then
      6   _G.vim = vim
        end
      6 vim._mock.add_buffer(1, "/home/user/project/test.lua", "local test = {}\nreturn test")
      6 vim._mock.add_window(1000, 1, { 1, 0 })
      6 vim._win_tab[1000] = 1
      6 vim._tab_windows[1] = { 1000 }
      6 vim._current_window = 1000

        -- Global options table (minimal)
     12 vim.o = setmetatable({ columns = 120, lines = 40 }, {
          __index = function(_, k)
******0     return vim._options[k]
          end,
          __newindex = function(_, k, v)
******0     vim._options[k] = v
          end,
      6 })

        -- Buffer options (vim.bo[bufnr].option)
     12 vim.bo = setmetatable({}, {
          __index = function(_, bufnr)
    260     return setmetatable({}, {
              __index = function(_, opt)
    130         if vim._buffers[bufnr] and vim._buffers[bufnr].options then
    112           return vim._buffers[bufnr].options[opt]
                end
     18         return nil
              end,
              __newindex = function(_, opt, val)
******0         if vim._buffers[bufnr] then
******0           vim._buffers[bufnr].options = vim._buffers[bufnr].options or {}
******0           vim._buffers[bufnr].options[opt] = val
                end
              end,
            })
          end,
      6 })

        -- Window options (vim.wo[winid].option)
     12 vim.wo = setmetatable({}, {
          __index = function(_, winid)
      4     return setmetatable({}, {
              __index = function(_, opt)
******0         if vim._windows[winid] and vim._windows[winid].options then
******0           return vim._windows[winid].options[opt]
                end
******0         return nil
              end,
              __newindex = function(_, opt, val)
******0         if vim._windows[winid] then
******0           vim._windows[winid].options = vim._windows[winid].options or {}
******0           vim._windows[winid].options[opt] = val
                end
              end,
            })
          end,
      6 })

        -- Treesitter stub (returns nil parser to skip treesitter-dependent code in tests)
      6 vim.treesitter = {
          get_parser = function(bufnr, lang)
     68     return nil
          end,
      6   query = {
            parse = function(lang, query_str)
******0       return {
                iter_captures = function(self, root, bufnr)
******0           return function() return nil end
                end,
              }
            end,
      6   },
          get_node_text = function(node, bufnr)
******0     return ""
          end,
      6 }

      6 return vim

==============================================================================
tests/deps/nvim-test-core/tests/vim_mock_spec.lua
==============================================================================
      2 package.path = package.path .. ";./lua/?.lua;./lua/?/init.lua"

      2 require("nvim-test-core")

      4 describe("vim_mock", function()
      4 	before_each(function()
     70 		vim._mock.reset()
        	end)

      4 	describe("buffers", function()
      4 		it("creates buffer with add_buffer", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "package main", { filetype = "go" })
      2 			assert.equals("go", vim.bo[1].filetype)
        		end)

      4 		it("nvim_buf_get_name returns buffer path", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			assert.equals("/test/file.go", vim.api.nvim_buf_get_name(1))
        		end)

      4 		it("nvim_buf_get_lines returns buffer lines", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "line1\nline2\nline3")
      2 			local lines = vim.api.nvim_buf_get_lines(1, 0, -1, false)
      2 			assert.is_table(lines)
        		end)

      4 		it("nvim_buf_line_count returns number", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "a\nb\nc")
      2 			local count = vim.api.nvim_buf_line_count(1)
      2 			assert.is_number(count)
        		end)

      4 		it("nvim_get_current_buf returns current buffer", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 1, 0 })
      2 			assert.equals(1, vim.api.nvim_get_current_buf())
        		end)

      4 		it("nvim_list_bufs returns all buffers", function()
      2 			vim._mock.add_buffer(1, "/test/a.go", "a")
      2 			vim._mock.add_buffer(2, "/test/b.go", "b")
      2 			local bufs = vim.api.nvim_list_bufs()
      2 			assert.equals(2, #bufs)
        		end)
        	end)

      4 	describe("windows", function()
      4 		it("creates window with add_window", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 5, 10 })
      2 			assert.equals(1000, vim.api.nvim_get_current_win())
        		end)

      4 		it("nvim_win_get_buf returns window buffer", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 1, 0 })
      2 			assert.equals(1, vim.api.nvim_win_get_buf(1000))
        		end)

      4 		it("nvim_win_get_cursor returns cursor position", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 5, 10 })
      2 			local cursor = vim.api.nvim_win_get_cursor(1000)
      2 			assert.equals(5, cursor[1])
      2 			assert.equals(10, cursor[2])
        		end)

      4 		it("nvim_win_set_cursor updates position", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 1, 0 })
      2 			vim.api.nvim_win_set_cursor(1000, { 10, 5 })
      2 			local cursor = vim.api.nvim_win_get_cursor(1000)
      2 			assert.equals(10, cursor[1])
      2 			assert.equals(5, cursor[2])
        		end)
        	end)

      4 	describe("namespaces", function()
      4 		it("nvim_create_namespace returns unique id", function()
      2 			local ns1 = vim.api.nvim_create_namespace("test1")
      2 			local ns2 = vim.api.nvim_create_namespace("test2")
      2 			assert.is_number(ns1)
      2 			assert.is_number(ns2)
      2 			assert.not_equals(ns1, ns2)
        		end)

      4 		it("nvim_create_namespace returns same id for same name", function()
      2 			local ns1 = vim.api.nvim_create_namespace("same")
      2 			local ns2 = vim.api.nvim_create_namespace("same")
      2 			assert.equals(ns1, ns2)
        		end)
        	end)

      4 	describe("extmarks", function()
      4 		it("nvim_buf_set_extmark creates extmark", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			local ns = vim.api.nvim_create_namespace("test")
      2 			local id = vim.api.nvim_buf_set_extmark(1, ns, 0, 0, {})
      2 			assert.is_number(id)
        		end)

      4 		it("nvim_buf_clear_namespace clears extmarks", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			local ns = vim.api.nvim_create_namespace("test")
      2 			vim.api.nvim_buf_set_extmark(1, ns, 0, 0, {})
      2 			vim.api.nvim_buf_clear_namespace(1, ns, 0, -1)
        		end)
        	end)

      4 	describe("highlights", function()
      4 		it("nvim_set_hl sets highlight group", function()
      2 			vim.api.nvim_set_hl(0, "TestGroup", { fg = "#ff0000" })
        		end)

      4 		it("nvim_get_hl returns highlight group", function()
      2 			vim.api.nvim_set_hl(0, "TestGetHl", { fg = "#00ff00", bold = true })
      2 			local hl = vim.api.nvim_get_hl(0, { name = "TestGetHl" })
      2 			assert.are.equal("#00ff00", hl.fg)
      2 			assert.is_true(hl.bold)
        		end)

      4 		it("nvim_get_hl returns empty for unknown group", function()
      2 			local hl = vim.api.nvim_get_hl(0, { name = "NonExistentGroup" })
      2 			assert.is_nil(hl.fg)
        		end)

      4 		it("nvim_get_hl with link=false returns same result", function()
      2 			vim.api.nvim_set_hl(0, "TestLinkFalse", { fg = "#0000ff" })
      2 			local hl = vim.api.nvim_get_hl(0, { name = "TestLinkFalse", link = false })
      2 			assert.are.equal("#0000ff", hl.fg)
        		end)

      4 		it("nvim_buf_add_highlight adds highlight", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			local id = vim.api.nvim_buf_add_highlight(1, 0, "TestGroup", 0, 0, 5)
      2 			assert.is_number(id)
        		end)
        	end)

      4 	describe("autocommands", function()
      4 		it("nvim_create_augroup creates group", function()
      2 			local id = vim.api.nvim_create_augroup("TestGroup", { clear = true })
      2 			assert.is_number(id)
        		end)

      4 		it("nvim_create_autocmd creates autocmd", function()
      2 			local group = vim.api.nvim_create_augroup("TestGroup", { clear = true })
      4 			local id = vim.api.nvim_create_autocmd("BufEnter", {
      2 				group = group,
      2 				pattern = "*.go",
      2 				callback = function() end,
        			})
      2 			assert.is_number(id)
        		end)

      4 		it("nvim_create_autocmd with group ID stores in correct group", function()
      2 			local group_id = vim.api.nvim_create_augroup("MyGroup", { clear = true })
      4 			vim.api.nvim_create_autocmd("ColorScheme", {
      2 				group = group_id,
      2 				callback = function() end,
        			})
      2 			local group_data = vim._autocmds["MyGroup"]
      2 			assert.is_table(group_data)
      2 			assert.is_table(group_data.events)
      2 			assert.equals(1, #group_data.events)
      2 			assert.equals("ColorScheme", group_data.events[1].events)
        		end)
        	end)

      4 	describe("user commands", function()
      4 		it("nvim_create_user_command creates command", function()
      2 			vim.api.nvim_create_user_command("TestCmd", function() end, {})
        		end)
        	end)

      4 	describe("options", function()
      4 		it("vim.bo returns buffer options", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content", { filetype = "go" })
      2 			assert.equals("go", vim.bo[1].filetype)
        		end)

      4 		it("vim.wo returns window options", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 1, 0 })
      2 			assert.is_table(vim.wo[1000])
        		end)
        	end)

      4 	describe("vim.fn", function()
      4 		it("expand returns path", function()
      2 			local result = vim.fn.expand("%:p")
      2 			assert.is_string(result)
        		end)

      4 		it("filereadable returns number", function()
      2 			local result = vim.fn.filereadable("/some/path")
      2 			assert.is_number(result)
        		end)

      4 		it("getcwd returns string", function()
      2 			local result = vim.fn.getcwd()
      2 			assert.is_string(result)
        		end)
        	end)

      4 	describe("vim.treesitter", function()
      4 		it("get_parser returns nil (stub)", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			local parser = vim.treesitter.get_parser(1, "go")
      2 			assert.is_nil(parser)
        		end)
        	end)

      4 	describe("reset", function()
      4 		it("clears all state", function()
      2 			vim._mock.add_buffer(1, "/test/file.go", "content")
      2 			vim._mock.add_window(1000, 1, { 1, 0 })
      2 			vim.api.nvim_create_namespace("test")

      2 			vim._mock.reset()

      2 			local bufs = vim.api.nvim_list_bufs()
      2 			assert.equals(0, #bufs)
        		end)
        	end)

      4 	describe("stub", function()
      4 		it("overrides api function", function()
      4 			vim._mock.stub("api.nvim_buf_get_name", function(bufnr)
     28 				return "/stubbed/path.go"
        			end)
      2 			assert.equals("/stubbed/path.go", vim.api.nvim_buf_get_name(1))
      2 			assert.equals("/stubbed/path.go", vim.api.nvim_buf_get_name(999))
        		end)

      4 		it("overrides fn function", function()
      4 			vim._mock.stub("fn.getcwd", function()
      2 				return "/my/custom/dir"
        			end)
      2 			assert.equals("/my/custom/dir", vim.fn.getcwd())
        		end)

      4 		it("overrides deeply nested path", function()
      4 			vim._mock.stub("lsp.buf.format", function()
      2 				return "formatted"
        			end)
      2 			assert.equals("formatted", vim.lsp.buf.format())
        		end)

      4 		it("creates intermediate tables if needed", function()
      4 			vim._mock.stub("custom.nested.deep.func", function()
      2 				return 42
        			end)
      2 			assert.equals(42, vim.custom.nested.deep.func())
        		end)

      4 		it("overrides single level", function()
      4 			vim._mock.stub("notify", function(msg)
      2 				return "notified: " .. msg
        			end)
      2 			assert.equals("notified: hello", vim.notify("hello"))
        		end)
        	end)
        end)

==============================================================================
tests/go-unfucked_spec.lua
==============================================================================
     12 describe("go-unfucked", function()
     12 	before_each(function()
   1021 		vim._mock.reset()
   1021 		vim._mock.add_buffer(1, "/test/main.go", "package main", { filetype = "go" })
   1021 		vim._mock.add_window(1000, 1, { 1, 0 })
   1021 		package.loaded["go-unfucked.import-hints"] = nil
   1021 		package.loaded["go-unfucked.receiver-highlight"] = nil
   1021 		package.loaded["go-unfucked.error-dim"] = nil
   1021 		package.loaded["go-unfucked.shortnames"] = nil
        	end)

     12 	describe("import-hints", function()
        		local import_hints

     12 		before_each(function()
    144 			import_hints = require("go-unfucked.import-hints")
        		end)

     12 		it("should be a table", function()
      6 			expect(import_hints).to_be_table()
        		end)

     12 		it("should have setup function", function()
      6 			expect(import_hints.setup).to_be_function()
        		end)

     12 		it("should have update_hints function", function()
      6 			expect(import_hints.update_hints).to_be_function()
        		end)

     12 		it("should track enabled state", function()
      6 			import_hints.setup({ enabled = true })
      6 			expect(import_hints.enabled).to_be_true()

      6 			import_hints.setup({ enabled = false })
      6 			expect(import_hints.enabled).to_be_false()
        		end)

     12 		it("should create namespace on first call", function()
      6 			import_hints.update_hints(1)
      6 			expect(vim._namespaces["go_import_hints"]).not_to_be_nil()
        		end)

     12 		it("should register autocmds on setup", function()
      6 			import_hints.setup({})
      6 			expect(vim._autocmds["GoImportHints"]).not_to_be_nil()
      6 			expect(vim._autocmds["GoImportHints"].events).to_be_table()
        		end)

     12 		it("should register user commands on setup", function()
      6 			import_hints.setup({})
      6 			expect(vim._commands["GoImportHints"]).not_to_be_nil()
      6 			expect(vim._commands["GoImportHintsToggle"]).not_to_be_nil()
        		end)

     12 		it("should handle nil treesitter parser gracefully", function()
     12 			local success = pcall(function()
      6 				import_hints.update_hints(1)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should skip non-go filetypes", function()
      6 			vim._mock.add_buffer(2, "/test/main.lua", "local x = 1", { filetype = "lua" })
      6 			import_hints.setup({ enabled = true })
      6 			import_hints.update_hints(2)
      6 			local ns_id = vim._namespaces["go_import_hints"]
      6 			local extmarks = vim._extmarks[ns_id] or {}
      6 			expect(#extmarks).to_be(0)
        		end)

     12 		it("should clear extmarks when disabled", function()
      6 			import_hints.setup({ enabled = true })
      6 			import_hints.update_hints(1)
      6 			import_hints.enabled = false
      6 			import_hints.update_hints(1)
      6 			local ns_id = vim._namespaces["go_import_hints"]
      6 			local extmarks = vim._extmarks[ns_id] or {}
      6 			expect(#extmarks).to_be(0)
        		end)

     12 		it("should default to enabled = true", function()
      6 			local fresh = require("go-unfucked.import-hints")
      6 			expect(fresh.enabled).to_be_true()
        		end)

     12 		it("should expose _internal for testing", function()
      6 			expect(import_hints._internal).to_be_table()
      6 			expect(import_hints._internal.get_imports).to_be_function()
      6 			expect(import_hints._internal.find_package_usages).to_be_function()
      6 			expect(import_hints._internal.get_namespace).to_be_function()
        		end)

     12 		it("should return namespace id from _internal.get_namespace", function()
      6 			import_hints.update_hints(1)
      6 			local ns = import_hints._internal.get_namespace()
      6 			expect(ns).to_be(vim._namespaces["go_import_hints"])
        		end)

     12 		it("should return empty imports without treesitter", function()
      6 			local imports = import_hints._internal.get_imports(1)
      6 			expect(imports).to_be_table()
      6 			expect(#imports).to_be(0)
        		end)

     12 		it("should return empty usages without treesitter", function()
      6 			local usages = import_hints._internal.find_package_usages(1, "fmt")
      6 			expect(usages).to_be_table()
      6 			expect(#usages).to_be(0)
        		end)

     12 		it("should register BufEnter autocmd", function()
      6 			import_hints.setup({})
      6 			local group = vim._autocmds["GoImportHints"]
      6 			local has_buf_enter = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     24 						if ev == "BufEnter" then has_buf_enter = true end
        					end
        				end
        			end
      6 			expect(has_buf_enter).to_be_true()
        		end)

     12 		it("should register BufWritePost autocmd", function()
      6 			import_hints.setup({})
      6 			local group = vim._autocmds["GoImportHints"]
      6 			local has_buf_write_post = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     24 						if ev == "BufWritePost" then has_buf_write_post = true end
        					end
        				end
        			end
      6 			expect(has_buf_write_post).to_be_true()
        		end)

     12 		it("should register TextChanged autocmd", function()
      6 			import_hints.setup({})
      6 			local group = vim._autocmds["GoImportHints"]
      6 			local has_text_changed = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     24 						if ev == "TextChanged" then has_text_changed = true end
        					end
        				end
        			end
      6 			expect(has_text_changed).to_be_true()
        		end)

     12 		it("should register TextChangedI autocmd", function()
      6 			import_hints.setup({})
      6 			local group = vim._autocmds["GoImportHints"]
      6 			local has_text_changed_i = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     24 						if ev == "TextChangedI" then has_text_changed_i = true end
        					end
        				end
        			end
      6 			expect(has_text_changed_i).to_be_true()
        		end)

     12 		it("should use *.go pattern for autocmds", function()
      6 			import_hints.setup({})
      6 			local group = vim._autocmds["GoImportHints"]
      6 			local has_go_pattern = false
      6 			for _, ac in pairs(group.events or {}) do
      6 				if ac.opts and ac.opts.pattern == "*.go" then
      6 					has_go_pattern = true
      6 					break
        				end
        			end
      6 			expect(has_go_pattern).to_be_true()
        		end)

     12 		it("should clear augroup on repeated setup", function()
      6 			import_hints.setup({})
      6 			local first_count = 0
     18 			for _ in pairs(vim._autocmds["GoImportHints"].events or {}) do
     12 				first_count = first_count + 1
        			end
      6 			import_hints.setup({})
      6 			local second_count = 0
     18 			for _ in pairs(vim._autocmds["GoImportHints"].events or {}) do
     12 				second_count = second_count + 1
        			end
      6 			expect(first_count).to_be(second_count)
        		end)

     12 		it("should handle missing buffer gracefully", function()
     12 			local success = pcall(function()
      6 				import_hints.update_hints(9999)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should set enabled false when explicitly disabled", function()
      6 			import_hints.setup({ enabled = false })
      6 			expect(import_hints.enabled).to_be_false()
        		end)

     12 		it("should keep enabled true when setup called without enabled option", function()
      6 			import_hints.enabled = true
      6 			import_hints.setup({})
      6 			expect(import_hints.enabled).to_be_true()
        		end)
        	end)

     12 	describe("receiver-highlight", function()
        		local receiver_highlight

     12 		before_each(function()
    182 			receiver_highlight = require("go-unfucked.receiver-highlight")
        		end)

     12 		it("should be a table", function()
      6 			expect(receiver_highlight).to_be_table()
        		end)

     12 		it("should have setup function", function()
      6 			expect(receiver_highlight.setup).to_be_function()
        		end)

     12 		it("should have highlight_receivers function", function()
      6 			expect(receiver_highlight.highlight_receivers).to_be_function()
        		end)

     12 		it("should create namespace on first call", function()
      6 			receiver_highlight.highlight_receivers(1)
      6 			expect(vim._namespaces["go_receiver_hl"]).not_to_be_nil()
        		end)

     12 		it("should register highlight group on setup", function()
      6 			receiver_highlight.setup({})
      6 			expect(vim._hl_groups["GoReceiver"]).not_to_be_nil()
        		end)

     12 		it("should use custom color from config", function()
      6 			receiver_highlight.setup({ color = "#ff0000" })
      6 			expect(vim._hl_groups["GoReceiver"].fg).to_be("#ff0000")
        		end)

     12 		it("should use default color when not specified", function()
      6 			receiver_highlight.setup({})
      6 			expect(vim._hl_groups["GoReceiver"].fg).to_be("#a855f7")
        		end)

     12 		it("should register autocmds on setup", function()
      6 			receiver_highlight.setup({})
      6 			expect(vim._autocmds["GoReceiverHighlight"]).not_to_be_nil()
        		end)

     12 		it("should handle nil treesitter parser gracefully", function()
     12 			local success = pcall(function()
      6 				receiver_highlight.highlight_receivers(1)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should skip non-go filetypes", function()
      6 			vim._mock.add_buffer(2, "/test/main.lua", "local x = 1", { filetype = "lua" })
      6 			receiver_highlight.highlight_receivers(2)
      6 			local ns_id = vim._namespaces["go_receiver_hl"]
      6 			local highlights = vim._highlights[ns_id] or {}
      6 			expect(#highlights).to_be(0)
        		end)

     12 		it("should register ColorScheme autocmd", function()
      6 			receiver_highlight.setup({ color = "#ff757f" })
      6 			local group = vim._autocmds["GoReceiverHighlight"]
      6 			expect(group).not_to_be_nil()
      6 			local has_colorscheme = false
      6 			for _, ac in pairs(group.events or {}) do
      6 				if ac.events == "ColorScheme" then
      6 					has_colorscheme = true
      6 					break
        				end
        			end
      6 			expect(has_colorscheme).to_be_true()
        		end)

     12 		it("should restore color after ColorScheme event", function()
      6 			receiver_highlight.setup({ color = "#ff757f" })
      6 			vim._hl_groups["GoReceiver"] = nil
      6 			local group = vim._autocmds["GoReceiverHighlight"]
      6 			for _, ac in pairs(group.events or {}) do
      6 				if ac.events == "ColorScheme" and ac.opts.callback then
      6 					ac.opts.callback()
      6 					break
        				end
        			end
      6 			expect(vim._hl_groups["GoReceiver"]).not_to_be_nil()
      6 			expect(vim._hl_groups["GoReceiver"].fg).to_be("#ff757f")
        		end)

     12 		it("should register InsertLeave and TextChangedI autocmds", function()
      6 			receiver_highlight.setup({})
      6 			local group = vim._autocmds["GoReceiverHighlight"]
      6 			expect(group).not_to_be_nil()
      6 			local has_insert_leave = false
      6 			local has_text_changed_i = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     30 						if ev == "InsertLeave" then has_insert_leave = true end
     30 						if ev == "TextChangedI" then has_text_changed_i = true end
        					end
        				end
        			end
      6 			expect(has_insert_leave).to_be_true()
      6 			expect(has_text_changed_i).to_be_true()
        		end)

     12 		it("should expose _internal for testing", function()
      6 			expect(receiver_highlight._internal).to_be_table()
      6 			expect(receiver_highlight._internal.set_hl).to_be_function()
      6 			expect(receiver_highlight._internal.get_saved_color).to_be_function()
      6 			expect(receiver_highlight._internal.set_saved_color).to_be_function()
      6 			expect(receiver_highlight._internal.get_namespace).to_be_function()
        		end)

     12 		it("should return namespace id from _internal.get_namespace", function()
      6 			receiver_highlight.highlight_receivers(1)
      6 			local ns = receiver_highlight._internal.get_namespace()
      6 			expect(ns).to_be(vim._namespaces["go_receiver_hl"])
        		end)

     12 		it("should store saved_color via _internal", function()
      6 			receiver_highlight._internal.set_saved_color("#abcdef")
      6 			expect(receiver_highlight._internal.get_saved_color()).to_be("#abcdef")
        		end)

     12 		it("should return nil for saved_color initially", function()
      6 			expect(receiver_highlight._internal.get_saved_color()).to_be_nil()
        		end)

     12 		it("should set_hl create GoReceiver highlight group", function()
      6 			receiver_highlight._internal.set_saved_color("#123456")
      6 			receiver_highlight._internal.set_hl()
      6 			expect(vim._hl_groups["GoReceiver"]).not_to_be_nil()
      6 			expect(vim._hl_groups["GoReceiver"].fg).to_be("#123456")
        		end)

     12 		it("should set_hl use default color when saved_color is nil", function()
      6 			receiver_highlight._internal.set_saved_color(nil)
      6 			receiver_highlight._internal.set_hl()
      6 			expect(vim._hl_groups["GoReceiver"].fg).to_be("#a855f7")
        		end)

     12 		it("should set_hl include italic attribute", function()
      6 			receiver_highlight._internal.set_hl()
      6 			expect(vim._hl_groups["GoReceiver"].italic).to_be_true()
        		end)

     12 		it("should set_hl include bold attribute", function()
      6 			receiver_highlight._internal.set_hl()
      6 			expect(vim._hl_groups["GoReceiver"].bold).to_be_true()
        		end)

     12 		it("should handle invalid color format gracefully", function()
      6 			receiver_highlight._internal.set_saved_color("not-a-color")
      6 			receiver_highlight._internal.set_hl()
      6 			expect(vim._hl_groups["GoReceiver"]).not_to_be_nil()
     16 			expect(vim._hl_groups["GoReceiver"].fg).to_be("not-a-color")
        		end)

     27 		it("should handle empty string color", function()
      6 			receiver_highlight._internal.set_saved_color("")
      1 			receiver_highlight._internal.set_hl()
      6 			expect(vim._hl_groups["GoReceiver"]).not_to_be_nil()
      6 			expect(vim._hl_groups["GoReceiver"].fg).to_be("")
        		end)

     12 		it("should register BufEnter autocmd", function()
      6 			receiver_highlight.setup({})
      6 			local group = vim._autocmds["GoReceiverHighlight"]
      6 			local has_buf_enter = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     30 						if ev == "BufEnter" then has_buf_enter = true end
        					end
        				end
        			end
      6 			expect(has_buf_enter).to_be_true()
        		end)

     12 		it("should register BufWritePost autocmd", function()
      6 			receiver_highlight.setup({})
      6 			local group = vim._autocmds["GoReceiverHighlight"]
      6 			local has_buf_write_post = false
     18 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     36 					for _, ev in ipairs(ac.events) do
     30 						if ev == "BufWritePost" then has_buf_write_post = true end
        					end
        				end
        			end
      6 			expect(has_buf_write_post).to_be_true()
        		end)

     12 		it("should register TextChanged autocmd", function()
      6 			receiver_highlight.setup({})
      6 			local group = vim._autocmds["GoReceiverHighlight"]
      6 			local has_text_changed = false
     13 			for _, ac in pairs(group.events or {}) do
     12 				if type(ac.events) == "table" then
     11 					for _, ev in ipairs(ac.events) do
     10 						if ev == "TextChanged" then has_text_changed = true end
        					end
        				end
        			end
     11 			expect(has_text_changed).to_be_true()
        		end)

      7 		it("should use *.go pattern for autocmds", function()
      6 			receiver_highlight.setup({})
     16 			local group = vim._autocmds["GoReceiverHighlight"]
     11 			local has_go_pattern = false
      7 			for _, ac in pairs(group.events or {}) do
      7 				if ac.opts and ac.opts.pattern == "*.go" then
      6 					has_go_pattern = true
     16 					break
        				end
        			end
      6 			expect(has_go_pattern).to_be_true()
        		end)

     12 		it("should clear augroup on repeated setup", function()
     11 			receiver_highlight.setup({})
      6 			local first_count = 0
     13 			for _ in pairs(vim._autocmds["GoReceiverHighlight"].events or {}) do
      7 				first_count = first_count + 1
        			end
      1 			receiver_highlight.setup({})
     11 			local second_count = 0
      8 			for _ in pairs(vim._autocmds["GoReceiverHighlight"].events or {}) do
      7 				second_count = second_count + 1
        			end
      1 			expect(first_count).to_be(second_count)
        		end)

     12 		it("should handle missing buffer gracefully", function()
      2 			local success = pcall(function()
     11 				receiver_highlight.highlight_receivers(9999)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should setup store color in saved_color", function()
      1 			receiver_highlight.setup({ color = "#ff00ff" })
     11 			expect(receiver_highlight._internal.get_saved_color()).to_be("#ff00ff")
        		end)

     12 		it("should have highlight_identifier_usages function", function()
    291 			expect(receiver_highlight.highlight_identifier_usages).to_be_function()
        		end)

     12 		it("should clear namespace on highlight_receivers call", function()
      6 			receiver_highlight.highlight_receivers(1)
     11 			local ns = receiver_highlight._internal.get_namespace()
      1 			expect(ns).not_to_be_nil()
        		end)
        	end)

      2 	describe("error-dim", function()
        		local error_dim

     12 		before_each(function()
     58 			error_dim = require("go-unfucked.error-dim")
        		end)

      7 		it("should be a table", function()
      6 			expect(error_dim).to_be_table()
        		end)

     12 		it("should have setup function", function()
      1 			expect(error_dim.setup).to_be_function()
        		end)

      7 		it("should have update_dims function", function()
      6 			expect(error_dim.update_dims).to_be_function()
        		end)

      7 		it("should have default config", function()
      6 			expect(error_dim.config).to_be_table()
     11 			expect(error_dim.config.enabled).to_be_false()
      1 			expect(error_dim.config.dim_simple_return).to_be_false()
     11 			expect(error_dim.config.dim_wrapped_return).to_be_false()
      6 			expect(error_dim.config.dim_percent).to_be(40)
        		end)

     12 		it("should merge config on setup", function()
      2 			error_dim.setup({
     11 				enabled = true,
      6 				dim_simple_return = true,
      5 			})
     11 			expect(error_dim.config.enabled).to_be_true()
      1 			expect(error_dim.config.dim_simple_return).to_be_true()
     11 			expect(error_dim.config.dim_wrapped_return).to_be_false()
        		end)

     12 		it("should create namespace on first call", function()
      1 			error_dim.setup({ enabled = true })
     11 			error_dim.update_dims(1)
      6 			expect(vim._namespaces["go_error_dim"]).not_to_be_nil()
        		end)

      2 		it("should accept dim_percent config", function()
     11 			error_dim.setup({ dim_percent = 60 })
      6 			expect(error_dim.config.dim_percent).to_be(60)
        		end)

     12 		it("should accept dim_target config", function()
      1 			error_dim.setup({ dim_target = "#1a1a1a" })
     11 			expect(error_dim.config.dim_target).to_be("#1a1a1a")
        		end)

      7 		it("should register autocmds on setup", function()
      6 			error_dim.setup({})
      6 			expect(vim._autocmds["GoErrorDim"]).not_to_be_nil()
        		end)

     12 		it("should register user commands on setup", function()
     11 			error_dim.setup({})
      6 			expect(vim._commands["GoErrorDimToggle"]).not_to_be_nil()
      6 			expect(vim._commands["GoErrorDimStatus"]).not_to_be_nil()
        		end)

      7 		it("should not create highlights when disabled", function()
      6 			error_dim.setup({ enabled = false })
      6 			error_dim.update_dims(1)
      6 			local ns_id = vim._namespaces["go_error_dim"]
     11 			local highlights = vim._highlights[ns_id] or {}
      1 			expect(#highlights).to_be(0)
        		end)

     12 		it("should not create highlights when no dim options enabled", function()
      7 			error_dim.setup({
     11 				enabled = true,
      6 				dim_simple_return = false,
     11 				dim_wrapped_return = false,
        			})
     11 			error_dim.update_dims(1)
      6 			local ns_id = vim._namespaces["go_error_dim"]
      6 			local highlights = vim._highlights[ns_id] or {}
      6 			expect(#highlights).to_be(0)
        		end)

      7 		it("should handle nil treesitter parser gracefully", function()
     11 			error_dim.setup({ enabled = true, dim_simple_return = true })
      2 			local success = pcall(function()
     11 				error_dim.update_dims(1)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should skip non-go filetypes", function()
      1 			vim._mock.add_buffer(2, "/test/main.lua", "local x = 1", { filetype = "lua" })
     11 			error_dim.setup({ enabled = true, dim_simple_return = true })
      6 			error_dim.update_dims(2)
      6 			local ns_id = vim._namespaces["go_error_dim"]
      6 			local highlights = vim._highlights[ns_id] or {}
      6 			expect(#highlights).to_be(0)
        		end)

      7 		it("should preserve unrelated config options on merge", function()
      6 			error_dim.setup({ enabled = true })
      1 			error_dim.setup({ dim_simple_return = true })
      6 			expect(error_dim.config.enabled).to_be_true()
      6 			expect(error_dim.config.dim_simple_return).to_be_true()
        		end)

     12 		it("should register ColorScheme autocmd", function()
      6 			error_dim.setup({})
      6 			local group = vim._autocmds["GoErrorDim"]
      6 			expect(group).not_to_be_nil()
      6 			local has_colorscheme = false
      6 			for _, ac in pairs(group.events or {}) do
      6 				if ac.events == "ColorScheme" then
      6 					has_colorscheme = true
      1 					break
        				end
        			end
     11 			expect(has_colorscheme).to_be_true()
        		end)

      7 		it("should register ColorScheme autocmd for cache clearing", function()
      6 			error_dim.setup({})
      6 			local group = vim._autocmds["GoErrorDim"]
      6 			local has_colorscheme = false
     21 			for _, ac in pairs(group.events or {}) do
     21 				if ac.events == "ColorScheme" and ac.opts.callback then
      6 					has_colorscheme = true
      6 					break
        				end
        			end
      6 			expect(has_colorscheme).to_be_true()
        		end)

     12 		it("should register InsertLeave autocmd", function()
      6 			error_dim.setup({})
      6 			local group = vim._autocmds["GoErrorDim"]
      6 			expect(group).not_to_be_nil()
      6 			local has_insert_leave = false
      9 			for _, ac in pairs(group.events or {}) do
      9 				if ac.events == "InsertLeave" then
      6 					has_insert_leave = true
      6 					break
        				end
        			end
     11 			expect(has_insert_leave).to_be_true()
        		end)

      7 		it("should expose _internal for testing", function()
     11 			expect(error_dim._internal).to_be_table()
      1 			expect(error_dim._internal.blend_colors).to_be_function()
     11 			expect(error_dim._internal.get_bg_color).to_be_function()
      6 			expect(error_dim._internal.get_dimmed_group).to_be_function()
      6 			expect(error_dim._internal.clear_cache).to_be_function()
     11 			expect(error_dim._internal.get_cache).to_be_function()
      1 			expect(error_dim._internal.get_target_color).to_be_function()
     11 			expect(error_dim._internal.set_target_color).to_be_function()
        		end)

     12 		describe("blend_colors", function()
      2 			it("should return original color at 0%", function()
     11 				local result = error_dim._internal.blend_colors("#ff0000", "#000000", 0)
      6 				expect(result).to_be("#ff0000")
        			end)

      2 			it("should return target color at 100%", function()
     11 				local result = error_dim._internal.blend_colors("#ff0000", "#000000", 100)
      6 				expect(result).to_be("#000000")
        			end)

      2 			it("should blend 50% correctly", function()
     11 				local result = error_dim._internal.blend_colors("#ff0000", "#000000", 50)
      6 				expect(result).to_be("#7f0000")
        			end)

      2 			it("should blend white to black at 50%", function()
     11 				local result = error_dim._internal.blend_colors("#ffffff", "#000000", 50)
      6 				expect(result).to_be("#7f7f7f")
        			end)

      2 			it("should blend black to white at 50%", function()
     11 				local result = error_dim._internal.blend_colors("#000000", "#ffffff", 50)
      6 				expect(result).to_be("#7f7f7f")
        			end)

      2 			it("should handle colors without hash", function()
     11 				local result = error_dim._internal.blend_colors("ff0000", "000000", 50)
      6 				expect(result).to_be("#7f0000")
        			end)

      2 			it("should blend green channel correctly", function()
     11 				local result = error_dim._internal.blend_colors("#00ff00", "#000000", 50)
      6 				expect(result).to_be("#007f00")
        			end)

      2 			it("should blend blue channel correctly", function()
     11 				local result = error_dim._internal.blend_colors("#0000ff", "#000000", 50)
      6 				expect(result).to_be("#00007f")
        			end)

      2 			it("should blend all channels independently", function()
     11 				local result = error_dim._internal.blend_colors("#ff8040", "#000000", 50)
      6 				expect(result).to_be("#7f4020")
        			end)

      2 			it("should handle 25% blend", function()
     11 				local result = error_dim._internal.blend_colors("#ff0000", "#000000", 25)
      6 				expect(result).to_be("#bf0000")
        			end)

     12 			it("should handle 75% blend", function()
      1 				local result = error_dim._internal.blend_colors("#ff0000", "#000000", 75)
     11 				expect(result).to_be("#3f0000")
        			end)

      7 			it("should blend to non-black target", function()
     11 				local result = error_dim._internal.blend_colors("#ff0000", "#0000ff", 50)
      1 				expect(result).to_be("#7f007f")
        			end)

      7 			it("should handle real-world dim scenario", function()
      6 				local result = error_dim._internal.blend_colors("#a855f7", "#1a1a1a", 40)
     11 				expect(result).to_match("#")
        			end)
        		end)

      7 		describe("get_bg_color", function()
      7 			it("should return #000000 when Normal has no bg", function()
     11 				local result = error_dim._internal.get_bg_color()
      1 				expect(result).to_be("#000000")
        			end)

      7 			it("should return Normal bg when set", function()
      6 				vim.api.nvim_set_hl(0, "Normal", { bg = 0x1a1a1a })
     11 				local result = error_dim._internal.get_bg_color()
     11 				expect(result).to_be("#1a1a1a")
        			end)

     12 			it("should format bg as 6-digit hex", function()
     46 				vim.api.nvim_set_hl(0, "Normal", { bg = 0x000001 })
     46 				local result = error_dim._internal.get_bg_color()
     46 				expect(result).to_be("#000001")
        			end)

     12 			it("should handle white background", function()
      6 				vim.api.nvim_set_hl(0, "Normal", { bg = 0xffffff })
      6 				local result = error_dim._internal.get_bg_color()
      6 				expect(result).to_be("#ffffff")
        			end)
        		end)

     12 		describe("get_dimmed_group", function()
      7 			before_each(function()
     14 				error_dim._internal.clear_cache()
     14 				error_dim._internal.set_target_color("#000000")
     14 				error_dim.config.dim_percent = 40
        			end)

     12 			it("should create dimmed highlight group", function()
      6 				vim.api.nvim_set_hl(0, "@keyword", { fg = 0xff0000 })
      6 				local dimmed = error_dim._internal.get_dimmed_group("@keyword")
      6 				expect(dimmed).to_be("GoDim_keyword")
     11 				expect(vim._hl_groups["GoDim_keyword"]).not_to_be_nil()
        			end)

      7 			it("should cache dimmed groups", function()
      6 				vim.api.nvim_set_hl(0, "@string", { fg = 0x00ff00 })
      6 				local first = error_dim._internal.get_dimmed_group("@string")
     11 				local second = error_dim._internal.get_dimmed_group("@string")
      1 				expect(first).to_be(second)
        			end)

      7 			it("should sanitize group name with dots", function()
      6 				vim.api.nvim_set_hl(0, "@lsp.type.function", { fg = 0x0000ff })
     11 				local dimmed = error_dim._internal.get_dimmed_group("@lsp.type.function")
      1 				expect(dimmed).to_be("GoDim_lsp_type_function")
        			end)

      7 			it("should preserve bold attribute", function()
      6 				vim.api.nvim_set_hl(0, "@bold.test", { fg = 0xff0000, bold = true })
     11 				error_dim._internal.get_dimmed_group("@bold.test")
      1 				expect(vim._hl_groups["GoDim_bold_test"].bold).to_be_true()
        			end)

      7 			it("should preserve italic attribute", function()
      6 				vim.api.nvim_set_hl(0, "@italic.test", { fg = 0xff0000, italic = true })
      6 				error_dim._internal.get_dimmed_group("@italic.test")
     11 				expect(vim._hl_groups["GoDim_italic_test"].italic).to_be_true()
        			end)

      7 			it("should preserve underline attribute", function()
      6 				vim.api.nvim_set_hl(0, "@underline.test", { fg = 0xff0000, underline = true })
      6 				error_dim._internal.get_dimmed_group("@underline.test")
      6 				expect(vim._hl_groups["GoDim_underline_test"].underline).to_be_true()
        			end)

      2 			it("should use default fg for groups without fg", function()
     11 				vim.api.nvim_set_hl(0, "@nofg", {})
      6 				error_dim._internal.get_dimmed_group("@nofg")
      6 				expect(vim._hl_groups["GoDim_nofg"]).not_to_be_nil()
      6 				expect(vim._hl_groups["GoDim_nofg"].fg).not_to_be_nil()
        			end)

      7 			it("should apply dim_percent from config", function()
     11 				vim.api.nvim_set_hl(0, "@test.percent", { fg = 0xff0000 })
     11 				error_dim.config.dim_percent = 50
      1 				error_dim._internal.clear_cache()
     11 				error_dim._internal.get_dimmed_group("@test.percent")
     11 				expect(vim._hl_groups["GoDim_test_percent"].fg).to_be("#7f0000")
        			end)

      7 			it("should use target_color for dimming", function()
      6 				vim.api.nvim_set_hl(0, "@test.target", { fg = 0xff0000 })
      1 				error_dim.config.dim_percent = 50
      6 				error_dim.config.dim_target = "#0000ff"
      6 				error_dim._internal.clear_cache()
     11 				error_dim._internal.get_dimmed_group("@test.target")
      1 				expect(vim._hl_groups["GoDim_test_target"].fg).to_be("#7f007f")
        			end)
        		end)

      7 		describe("clear_cache", function()
     12 			it("should clear dimmed groups cache", function()
      1 				vim.api.nvim_set_hl(0, "@cached", { fg = 0xff0000 })
     11 				error_dim._internal.set_target_color("#000000")
      6 				error_dim._internal.get_dimmed_group("@cached")
      6 				expect(error_dim._internal.get_cache()["@cached"]).not_to_be_nil()

      6 				error_dim._internal.clear_cache()
     11 				expect(error_dim._internal.get_cache()["@cached"]).to_be_nil()
        			end)

     12 			it("should update target_color from config", function()
     11 				error_dim.config.dim_target = "#123456"
      6 				error_dim._internal.clear_cache()
      6 				expect(error_dim._internal.get_target_color()).to_be("#123456")
        			end)

      7 			it("should use get_bg_color when dim_target is nil", function()
      1 				vim.api.nvim_set_hl(0, "Normal", { bg = 0xaabbcc })
      6 				error_dim.config.dim_target = nil
      6 				error_dim._internal.clear_cache()
      6 				expect(error_dim._internal.get_target_color()).to_be("#aabbcc")
        			end)
        		end)

      7 		describe("ColorScheme callback", function()
      2 			it("should clear cache on ColorScheme event", function()
      6 				vim.api.nvim_set_hl(0, "@colorscheme.test", { fg = 0xff0000 })
     11 				error_dim._internal.set_target_color("#000000")
     11 				error_dim.setup({})
      1 				error_dim._internal.get_dimmed_group("@colorscheme.test")
     11 				expect(error_dim._internal.get_cache()["@colorscheme.test"]).not_to_be_nil()

     21 				local group = vim._autocmds["GoErrorDim"]
     21 				for _, ac in pairs(group.events or {}) do
     26 					if ac.events == "ColorScheme" and ac.opts.callback then
      1 						ac.opts.callback()
     11 						break
        					end
        				end

      6 				expect(error_dim._internal.get_cache()["@colorscheme.test"]).to_be_nil()
        			end)
        		end)

      7 		describe("dim_percent edge cases", function()
      7 			before_each(function()
      9 				error_dim._internal.clear_cache()
      9 				error_dim._internal.set_target_color("#000000")
        			end)

      2 			it("should handle dim_percent = 0 (no dimming)", function()
     11 				vim.api.nvim_set_hl(0, "@zero.percent", { fg = 0xff0000 })
      6 				error_dim.config.dim_percent = 0
      6 				error_dim._internal.get_dimmed_group("@zero.percent")
      6 				expect(vim._hl_groups["GoDim_zero_percent"].fg).to_be("#ff0000")
        			end)

     12 			it("should handle dim_percent = 100 (full dim)", function()
      1 				vim.api.nvim_set_hl(0, "@full.percent", { fg = 0xff0000 })
     11 				error_dim.config.dim_percent = 100
      6 				error_dim._internal.clear_cache()
      6 				error_dim._internal.get_dimmed_group("@full.percent")
      6 				expect(vim._hl_groups["GoDim_full_percent"].fg).to_be("#000000")
        			end)

     12 			it("should handle dim_percent = 1 (minimal dimming)", function()
     11 				vim.api.nvim_set_hl(0, "@one.percent", { fg = 0xff0000 })
      1 				error_dim.config.dim_percent = 1
     11 				error_dim._internal.clear_cache()
     11 				error_dim._internal.get_dimmed_group("@one.percent")
     16 				expect(vim._hl_groups["GoDim_one_percent"].fg).to_be("#fc0000")
        			end)

      2 			it("should handle dim_percent = 99 (almost full dim)", function()
     11 				vim.api.nvim_set_hl(0, "@ninetynine.percent", { fg = 0xff0000 })
      6 				error_dim.config.dim_percent = 99
      6 				error_dim._internal.clear_cache()
      6 				error_dim._internal.get_dimmed_group("@ninetynine.percent")
      6 				expect(vim._hl_groups["GoDim_ninetynine_percent"].fg).to_be("#020000")
        			end)
        		end)

      7 		describe("target color scenarios", function()
      7 			before_each(function()
      8 				error_dim._internal.clear_cache()
      8 				error_dim.config.dim_percent = 50
        			end)

     12 			it("should dim to white background", function()
      6 				vim.api.nvim_set_hl(0, "@white.bg", { fg = 0x000000 })
      6 				error_dim._internal.set_target_color("#ffffff")
      6 				error_dim._internal.get_dimmed_group("@white.bg")
      6 				expect(vim._hl_groups["GoDim_white_bg"].fg).to_be("#7f7f7f")
        			end)

      2 			it("should dim to gray background", function()
     11 				vim.api.nvim_set_hl(0, "@gray.bg", { fg = 0xff0000 })
     11 				error_dim._internal.set_target_color("#808080")
      6 				error_dim._internal.get_dimmed_group("@gray.bg")
      6 				expect(vim._hl_groups["GoDim_gray_bg"].fg).to_be("#bf4040")
        			end)

     12 			it("should dim to colored background", function()
      6 				vim.api.nvim_set_hl(0, "@colored.bg", { fg = 0xff0000 })
      6 				error_dim._internal.set_target_color("#00ff00")
      6 				error_dim._internal.get_dimmed_group("@colored.bg")
     11 				expect(vim._hl_groups["GoDim_colored_bg"].fg).to_be("#7f7f00")
        			end)
        		end)

     12 		describe("setup target_color initialization", function()
      7 			it("should set target_color from config on setup", function()
      1 				error_dim.setup({ dim_target = "#abcdef" })
     11 				expect(error_dim._internal.get_target_color()).to_be("#abcdef")
        			end)

      2 			it("should use Normal bg when dim_target not specified", function()
     11 				vim.api.nvim_set_hl(0, "Normal", { bg = 0x112233 })
      6 				error_dim.setup({ dim_target = nil })
     11 				expect(error_dim._internal.get_target_color()).to_be("#112233")
        			end)
        		end)
        	end)

      2 	describe("shortnames", function()
        		local shortnames

     12 		before_each(function()
     59 			shortnames = require("go-unfucked.shortnames")
        		end)

     12 		it("should be a table", function()
      1 			expect(shortnames).to_be_table()
        		end)

      7 		it("should have setup function", function()
      6 			expect(shortnames.setup).to_be_function()
        		end)

     12 		it("should have run function", function()
      6 			expect(shortnames.run).to_be_function()
        		end)

     12 		it("should have clear function", function()
      6 			expect(shortnames.clear).to_be_function()
        		end)

      7 		it("should have default config", function()
      6 			expect(shortnames.config).to_be_table()
     11 			expect(shortnames.config.enabled).to_be_false()
      1 			expect(shortnames.config.binary).to_be_nil()
        		end)

      7 		it("should merge config on setup", function()
     11 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
      1 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end

      7 			shortnames.setup({
     11 				enabled = true,
      1 				binary = "/custom/path/shortnames-linter",
      5 			})
      6 			expect(shortnames.config.enabled).to_be_true()
     11 			expect(shortnames.config.binary).to_be("/custom/path/shortnames-linter")
        		end)

      7 		it("should create namespace on first call", function()
      6 			shortnames.clear(1)
     11 			expect(vim._namespaces["go_shortnames"]).not_to_be_nil()
        		end)

      7 		it("should register autocmds on setup when binary found", function()
     11 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
      2 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end

      6 			shortnames.setup({ enabled = true })
      6 			expect(vim._autocmds["GoShortnames"]).not_to_be_nil()
        		end)

     12 		it("should not register autocmds when disabled", function()
      6 			shortnames.setup({ enabled = false })
      6 			expect(vim._autocmds["GoShortnames"]).to_be_nil()
        		end)

      7 		it("should register user commands on setup when binary found", function()
      6 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
     12 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end

     11 			shortnames.setup({ enabled = true })
      6 			expect(vim._commands["GoShortnamesRun"]).not_to_be_nil()
      6 			expect(vim._commands["GoShortnamesToggle"]).not_to_be_nil()
        		end)

      2 		it("should skip non-go filetypes", function()
     11 			vim._mock.add_buffer(2, "/test/main.lua", "local x = 1", { filetype = "lua" })
     11 			shortnames.config.enabled = true
      6 			shortnames.run(2)
      6 			local ns_id = vim._namespaces["go_shortnames"]
     11 			local diagnostics = vim._diagnostics[ns_id] or {}
      6 			expect(#diagnostics).to_be(0)
        		end)

      7 		it("should clear diagnostics", function()
      6 			shortnames.clear(1)
      6 			local ns_id = vim._namespaces["go_shortnames"]
      1 			expect(ns_id).not_to_be_nil()
        		end)

      7 		describe("parse_output", function()
      7 			it("should parse single line", function()
      6 				local output = '/test/main.go:10:5: variable "x" is too short'
      6 				local diagnostics = {}
     12 				for line in output:gmatch("[^\r\n]+") do
      1 					local file, lnum, col, msg = line:match("^(.+):(%d+):(%d+): (.+)$")
     11 					if file and file == "/test/main.go" then
      7 						table.insert(diagnostics, {
      6 							lnum = tonumber(lnum) - 1,
     16 							col = tonumber(col) - 1,
     11 							message = msg,
     10 						})
        					end
        				end
     11 				expect(#diagnostics).to_be(1)
     11 				expect(diagnostics[1].lnum).to_be(9)
      1 				expect(diagnostics[1].col).to_be(4)
      1 				expect(diagnostics[1].message).to_be('variable "x" is too short')
        			end)

     12 			it("should parse multiple lines", function()
      1 				local output = "/test/main.go:10:5: first\n/test/main.go:20:10: second"
     11 				local diagnostics = {}
      8 				for line in output:gmatch("[^\r\n]+") do
      7 					local file, lnum, col, msg = line:match("^(.+):(%d+):(%d+): (.+)$")
     17 					if file and file == "/test/main.go" then
     14 						table.insert(diagnostics, {
     12 							lnum = tonumber(lnum) - 1,
      7 							col = tonumber(col) - 1,
      2 							message = msg,
      5 						})
        					end
        				end
     11 				expect(#diagnostics).to_be(2)
        			end)

      7 			it("should filter by filename", function()
      6 				local output = "/test/main.go:10:5: in file\n/test/other.go:20:10: in other"
     21 				local diagnostics = {}
     18 				for line in output:gmatch("[^\r\n]+") do
     17 					local file, lnum, col, msg = line:match("^(.+):(%d+):(%d+): (.+)$")
      7 					if file and file == "/test/main.go" then
      1 						table.insert(diagnostics, { message = msg })
        					end
        				end
     11 				expect(#diagnostics).to_be(1)
     11 				expect(diagnostics[1].message).to_be("in file")
        			end)

     12 			it("should ignore malformed lines", function()
      6 				local output = "not valid\n/test/main.go:10:5: valid\nshortnames: skipped"
      6 				local diagnostics = {}
      9 				for line in output:gmatch("[^\r\n]+") do
      8 					local file, lnum, col, msg = line:match("^(.+):(%d+):(%d+): (.+)$")
      3 					if file and file == "/test/main.go" then
      1 						table.insert(diagnostics, { message = msg })
        					end
        				end
      6 				expect(#diagnostics).to_be(1)
        			end)
        		end)

      7 		describe("find_go_mod", function()
      7 			it("should find go.mod in current dir", function()
     16 				vim._mock.set_file_readable("/project/go.mod", true)
     16 				local path = "/project"
      1 				while path ~= "/" do
      1 					if vim.fn.filereadable(path .. "/go.mod") == 1 then
     10 						break
        					end
      5 					path = vim.fn.fnamemodify(path, ":h")
        				end
     11 				expect(path).to_be("/project")
        			end)

     12 			it("should find go.mod in parent dir", function()
      6 				vim._mock.set_file_readable("/project/go.mod", true)
      6 				local path = "/project/pkg/handler"
      8 				while path ~= "/" do
      8 					if vim.fn.filereadable(path .. "/go.mod") == 1 then
      5 						break
        					end
     12 					path = vim.fn.fnamemodify(path, ":h")
        				end
     11 				expect(path).to_be("/project")
        			end)
        		end)

      7 		describe("package path calculation", function()
      7 			it("should calculate relative path", function()
      6 				local go_mod_dir = "/home/user/project"
     11 				local filedir = "/home/user/project/pkg/handler"
      1 				local rel_dir = filedir:sub(#go_mod_dir + 2)
     11 				local pkg_path = "./" .. rel_dir
      6 				expect(rel_dir).to_be("pkg/handler")
      6 				expect(pkg_path).to_be("./pkg/handler")
        			end)

     12 			it("should handle root package", function()
     11 				local go_mod_dir = "/home/user/project"
      1 				local filedir = "/home/user/project"
     11 				local rel_dir = filedir:sub(#go_mod_dir + 2)
     11 				local pkg_path = "./" .. rel_dir
      6 				expect(rel_dir).to_be("")
      6 				expect(pkg_path).to_be("./")
        			end)

      2 			it("should handle deeply nested packages", function()
      6 				local go_mod_dir = "/home/user/project"
      6 				local filedir = "/home/user/project/internal/pkg/v2/handler"
      1 				local rel_dir = filedir:sub(#go_mod_dir + 2)
      6 				expect(rel_dir).to_be("internal/pkg/v2/handler")
        			end)
        		end)

     12 		describe("find_binary", function()
      7 			it("should find binary in PATH", function()
      6 				vim.fn.exepath = function(cmd)
      6 					if cmd == "shortnames-linter" then
      6 						return "/usr/local/bin/shortnames-linter"
        					end
******0 					return ""
        				end
      6 				vim._mock.set_executable("/usr/local/bin/shortnames-linter", true)

      6 				local result = vim.fn.exepath("shortnames-linter")
      6 				expect(result).to_be("/usr/local/bin/shortnames-linter")
        			end)

      2 			it("should find binary in go/bin", function()
     11 				vim.fn.exepath = function() return "" end
      6 				vim.fn.expand = function(path)
      6 					if path == "~/go/bin/shortnames-linter" then
      6 						return "/home/user/go/bin/shortnames-linter"
        					end
      5 					return path
        				end
      1 				vim._mock.set_executable("/home/user/go/bin/shortnames-linter", true)

      6 				local expanded = vim.fn.expand("~/go/bin/shortnames-linter")
      6 				expect(expanded).to_be("/home/user/go/bin/shortnames-linter")
        			end)
        		end)

     12 		it("should expose _internal for testing", function()
     11 			expect(shortnames._internal).to_be_table()
     11 			expect(shortnames._internal.find_binary).to_be_function()
     36 			expect(shortnames._internal.find_go_mod).to_be_function()
      6 			expect(shortnames._internal.parse_output).to_be_function()
      1 			expect(shortnames._internal.get_namespace).to_be_function()
        		end)

     12 		it("should return namespace id from _internal.get_namespace", function()
      1 			shortnames.clear(1)
     11 			local ns = shortnames._internal.get_namespace()
      6 			expect(ns).to_be(vim._namespaces["go_shortnames"])
        		end)

      2 		describe("_internal.find_binary", function()
      2 			it("should return nil when no binary found", function()
      7 				vim.fn.exepath = function() return "" end
     12 				vim.fn.expand = function(path) return path end
      1 				vim._mock.set_executable("shortnames-linter", false)

      6 				local result = shortnames._internal.find_binary()
     11 				expect(result).to_be_nil()
        			end)

     12 			it("should return path from exepath first", function()
      6 				vim.fn.exepath = function(cmd)
     16 					if cmd == "shortnames-linter" then
      6 						return "/usr/bin/shortnames-linter"
        					end
     10 					return ""
        				end
      6 				vim._mock.set_executable("/usr/bin/shortnames-linter", true)

      6 				local result = shortnames._internal.find_binary()
      6 				expect(result).to_be("/usr/bin/shortnames-linter")
        			end)

     12 			it("should check ~/go/bin as fallback", function()
     12 				vim.fn.exepath = function() return "" end
      6 				vim.fn.expand = function(path)
     78 					if path == "~/go/bin/shortnames-linter" then
     26 						return "/home/user/go/bin/shortnames-linter"
        					end
     52 					return path
        				end
      6 				vim._mock.set_executable("/home/user/go/bin/shortnames-linter", true)

      6 				local result = shortnames._internal.find_binary()
      6 				expect(result).to_be("/home/user/go/bin/shortnames-linter")
        			end)

      2 			it("should check $GOPATH/bin as fallback", function()
     12 				vim.fn.exepath = function() return "" end
     11 				vim.fn.expand = function(path)
      8 					if path == "$GOPATH/bin/shortnames-linter" then
      6 						return "/custom/gopath/bin/shortnames-linter"
        					end
      2 					return path
        				end
      6 				vim._mock.set_executable("/custom/gopath/bin/shortnames-linter", true)

      6 				local result = shortnames._internal.find_binary()
     11 				expect(result).to_be("/custom/gopath/bin/shortnames-linter")
        			end)

      7 			it("should prefer exepath over ~/go/bin when both exist", function()
      6 				vim.fn.exepath = function(cmd)
      6 					if cmd == "shortnames-linter" then
     11 						return "/usr/local/bin/shortnames-linter"
        					end
     10 					return ""
        				end
      6 				vim.fn.expand = function(path)
     20 					if path == "~/go/bin/shortnames-linter" then
     15 						return "/home/user/go/bin/shortnames-linter"
        					end
     20 					return path
        				end
      6 				vim._mock.set_executable("/usr/local/bin/shortnames-linter", true)
     11 				vim._mock.set_executable("/home/user/go/bin/shortnames-linter", true)

      1 				local result = shortnames._internal.find_binary()
     11 				expect(result).to_be("/usr/local/bin/shortnames-linter")
        			end)
        		end)

      2 		describe("_internal.find_go_mod", function()
     12 			it("should return nil when no go.mod found", function()
      6 				local result = shortnames._internal.find_go_mod("/some/random/path")
      6 				expect(result).to_be_nil()
        			end)

      2 			it("should find go.mod in start path", function()
     11 				vim._mock.set_file_readable("/project/go.mod", true)
      6 				local result = shortnames._internal.find_go_mod("/project")
      6 				expect(result).to_be("/project")
        			end)

      5 			it("should find go.mod in parent directory", function()
      9 				vim._mock.set_file_readable("/project/go.mod", true)
      1 				local result = shortnames._internal.find_go_mod("/project/cmd/app")
     11 				expect(result).to_be("/project")
        			end)

      7 			it("should find go.mod in grandparent directory", function()
      4 				vim._mock.set_file_readable("/project/go.mod", true)
      4 				local result = shortnames._internal.find_go_mod("/project/internal/pkg/service")
      9 				expect(result).to_be("/project")
        			end)

      7 			it("should stop at root", function()
      6 				local result = shortnames._internal.find_go_mod("/nonexistent/deeply/nested/path")
      6 				expect(result).to_be_nil()
        			end)
        		end)

      2 		describe("_internal.parse_output", function()
     12 			before_each(function()
     19 				vim._mock.add_buffer(1, "/test/main.go", "package main", { filetype = "go" })
        			end)

     10 			it("should return empty table for empty output", function()
      1 				local result = shortnames._internal.parse_output("", 1)
     11 				expect(result).to_be_table()
      6 				expect(#result).to_be(0)
        			end)

      2 			it("should parse single diagnostic", function()
     11 				local result = shortnames._internal.parse_output('/test/main.go:10:5: variable "x" is too short', 1)
      6 				expect(#result).to_be(1)
      6 				expect(result[1].lnum).to_be(9)
      9 				expect(result[1].col).to_be(4)
      1 				expect(result[1].message).to_be('variable "x" is too short')
        			end)

      7 			it("should parse multiple diagnostics", function()
      9 				local output = "/test/main.go:10:5: first\n/test/main.go:20:15: second"
      1 				local result = shortnames._internal.parse_output(output, 1)
     11 				expect(#result).to_be(2)
      6 				expect(result[1].message).to_be("first")
      6 				expect(result[2].message).to_be("second")
        			end)

     10 			it("should filter diagnostics by buffer filename", function()
      1 				vim._mock.add_buffer(2, "/other/file.go", "package other", { filetype = "go" })
     11 				local output = "/test/main.go:10:5: in main\n/other/file.go:20:10: in other"
      6 				local result = shortnames._internal.parse_output(output, 1)
      6 				expect(#result).to_be(1)
      6 				expect(result[1].message).to_be("in main")
        			end)

     12 			it("should ignore malformed lines", function()
      1 				local output = "some random output\n/test/main.go:10:5: valid\ninvalid line"
     11 				local result = shortnames._internal.parse_output(output, 1)
      6 				expect(#result).to_be(1)
        			end)

     12 			it("should set severity to WARN", function()
      6 				local result = shortnames._internal.parse_output("/test/main.go:10:5: msg", 1)
     11 				expect(result[1].severity).to_be(vim.diagnostic.severity.WARN)
        			end)

      2 			it("should set source to shortnames", function()
     11 				local result = shortnames._internal.parse_output("/test/main.go:10:5: msg", 1)
      6 				expect(result[1].source).to_be("shortnames")
        			end)

      7 			it("should set bufnr correctly", function()
     11 				local result = shortnames._internal.parse_output("/test/main.go:10:5: msg", 1)
      6 				expect(result[1].bufnr).to_be(1)
        			end)

     12 			it("should handle Windows-style paths", function()
      6 				vim._mock.add_buffer(3, "C:\\project\\main.go", "package main", { filetype = "go" })
     11 				local output = "C:\\project\\main.go:10:5: error msg"
      6 				local result = shortnames._internal.parse_output(output, 3)
      6 				expect(#result).to_be(1)
        			end)

     12 			it("should handle paths with spaces", function()
      6 				vim._mock.add_buffer(4, "/my project/main.go", "package main", { filetype = "go" })
      6 				local output = "/my project/main.go:10:5: error msg"
     11 				local result = shortnames._internal.parse_output(output, 4)
      1 				expect(#result).to_be(1)
        			end)

      7 			it("should handle message with colons", function()
      6 				local output = "/test/main.go:10:5: error: something: else: here"
      6 				local result = shortnames._internal.parse_output(output, 1)
     11 				expect(#result).to_be(1)
      1 				expect(result[1].message).to_be("error: something: else: here")
        			end)

     12 			it("should handle line number 0", function()
      6 				local output = "/test/main.go:0:5: msg"
     11 				local result = shortnames._internal.parse_output(output, 1)
      6 				expect(#result).to_be(1)
     11 				expect(result[1].lnum).to_be(-1)
        			end)

     12 			it("should handle col number 0", function()
      6 				local output = "/test/main.go:10:0: msg"
     11 				local result = shortnames._internal.parse_output(output, 1)
      6 				expect(#result).to_be(1)
     11 				expect(result[1].col).to_be(-1)
        			end)

      7 			it("should ignore lines with empty message", function()
     11 				local output = "/test/main.go:10:5: "
      6 				local result = shortnames._internal.parse_output(output, 1)
      6 				expect(#result).to_be(0)
        			end)
        		end)

     17 		it("should not run when buffer has no name", function()
     11 			vim._mock.add_buffer(5, "", "package main", { filetype = "go" })
      6 			shortnames.config.enabled = true
      1 			shortnames.config.binary = "/usr/bin/shortnames-linter"
      7 			local success = pcall(function()
      6 				shortnames.run(5)
        			end)
      1 			expect(success).to_be_true()
        		end)

     12 		it("should not run when go.mod not found", function()
      6 			shortnames.config.enabled = true
      6 			shortnames.config.binary = "/usr/bin/shortnames-linter"
      7 			local success = pcall(function()
     11 				shortnames.run(1)
        			end)
     16 			expect(success).to_be_true()
        		end)

      2 		it("should register GoShortnamsClear command", function()
      6 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
      7 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end
     11 			shortnames.setup({ enabled = true })
      1 			expect(vim._commands["GoShortnamsClear"]).not_to_be_nil()
        		end)

     12 		it("should use custom binary path from config", function()
      6 			shortnames.setup({ enabled = true, binary = "/custom/path/linter" })
      6 			expect(shortnames.config.binary).to_be("/custom/path/linter")
        		end)

      7 		it("should preserve enabled state after config merge", function()
      6 			shortnames.setup({ enabled = true, binary = "/bin/linter" })
      6 			expect(shortnames.config.enabled).to_be_true()
      1 			shortnames.setup({ binary = "/other/linter" })
      6 			expect(shortnames.config.enabled).to_be_true()
        		end)

     12 		it("should handle missing buffer gracefully in run", function()
      1 			shortnames.config.enabled = true
     12 			local success = pcall(function()
     11 				shortnames.run(9999)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should handle missing buffer gracefully in clear", function()
      7 			local success = pcall(function()
      6 				shortnames.clear(9999)
        			end)
      6 			expect(success).to_be_true()
        		end)

     12 		it("should register BufEnter autocmd when enabled", function()
      1 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
     12 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end
      6 			shortnames.setup({ enabled = true })
     11 			local group = vim._autocmds["GoShortnames"]
      6 			local has_buf_enter = false
      7 			for _, ac in pairs(group.events or {}) do
      6 				if type(ac.events) == "table" then
      3 					for _, ev in ipairs(ac.events) do
      2 						if ev == "BufEnter" then has_buf_enter = true end
        					end
        				end
        			end
      1 			expect(has_buf_enter).to_be_true()
        		end)

      7 		it("should register BufWritePost autocmd when enabled", function()
      6 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
     12 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end
     11 			shortnames.setup({ enabled = true })
     16 			local group = vim._autocmds["GoShortnames"]
      1 			local has_buf_write_post = false
      2 			for _, ac in pairs(group.events or {}) do
      1 				if type(ac.events) == "table" then
      3 					for _, ev in ipairs(ac.events) do
      2 						if ev == "BufWritePost" then has_buf_write_post = true end
        					end
        				end
        			end
      1 			expect(has_buf_write_post).to_be_true()
        		end)

      2 		it("should use *.go pattern for autocmds", function()
      1 			vim._mock.set_executable("/usr/bin/shortnames-linter", true)
      2 			vim.fn.exepath = function() return "/usr/bin/shortnames-linter" end
      1 			shortnames.setup({ enabled = true })
      1 			local group = vim._autocmds["GoShortnames"]
      1 			local has_go_pattern = false
      1 			for _, ac in pairs(group.events or {}) do
      1 				if ac.opts and ac.opts.pattern == "*.go" then
      1 					has_go_pattern = true
      1 					break
        				end
        			end
      1 			expect(has_go_pattern).to_be_true()
        		end)
        	end)

      2 	describe("init module", function()
      2 		it("should export setup function", function()
      1 			local go_unfucked = require("go-unfucked")
      1 			expect(go_unfucked.setup).to_be_function()
        		end)

      2 		it("should call all submodule setup functions", function()
      1 			local go_unfucked = require("go-unfucked")
      1 			go_unfucked.setup({})
      1 			expect(vim._autocmds["GoImportHints"]).not_to_be_nil()
      1 			expect(vim._autocmds["GoReceiverHighlight"]).not_to_be_nil()
      1 			expect(vim._autocmds["GoErrorDim"]).not_to_be_nil()
        			-- shortnames autocmd only created if binary found, so we don't check it here
        		end)

      2 		it("should pass config to submodules", function()
      1 			local go_unfucked = require("go-unfucked")
      2 			go_unfucked.setup({
      1 				import_hints = { enabled = false },
      1 				receiver_highlight = { color = "#00ff00" },
      1 				error_dim = { enabled = true, dim_simple_return = true },
        			})

      1 			local import_hints = require("go-unfucked.import-hints")
      1 			local receiver_highlight = require("go-unfucked.receiver-highlight")
      1 			local error_dim = require("go-unfucked.error-dim")

      1 			expect(import_hints.enabled).to_be_false()
      1 			expect(vim._hl_groups["GoReceiver"].fg).to_be("#00ff00")
      1 			expect(error_dim.config.enabled).to_be_true()
      1 			expect(error_dim.config.dim_simple_return).to_be_true()
        		end)
        	end)
        end)

==============================================================================
tests/minimal_init.lua
==============================================================================
      6 package.path = package.path .. ";./tests/deps/nvim-test-core/lua/?.lua"
      6 package.path = package.path .. ";./tests/deps/nvim-test-core/lua/?/init.lua"
      6 package.path = package.path .. ";./lua/?.lua"
      6 package.path = package.path .. ";./lua/?/init.lua"

      6 require("nvim-test-core")
      6 require("go-unfucked")

==============================================================================
Summary
==============================================================================

File                                                                 Hits Missed Coverage
-----------------------------------------------------------------------------------------
/opt/homebrew/share/lua/5.4/busted/block.lua                         69   26     72.63%
/opt/homebrew/share/lua/5.4/busted/compatibility.lua                 20   14     58.82%
/opt/homebrew/share/lua/5.4/busted/context.lua                       48   35     57.83%
/opt/homebrew/share/lua/5.4/busted/core.lua                          109  88     55.33%
/opt/homebrew/share/lua/5.4/busted/environment.lua                   6    15     28.57%
/opt/homebrew/share/lua/5.4/busted/execute.lua                       19   21     47.50%
/opt/homebrew/share/lua/5.4/busted/init.lua                          23   56     29.11%
/opt/homebrew/share/lua/5.4/busted/languages/en.lua                  38   0      100.00%
/opt/homebrew/share/lua/5.4/busted/luajit.lua                        3    25     10.71%
/opt/homebrew/share/lua/5.4/busted/modules/files/lua.lua             10   1      90.91%
/opt/homebrew/share/lua/5.4/busted/modules/files/moonscript.lua      6    46     11.54%
/opt/homebrew/share/lua/5.4/busted/modules/filter_loader.lua         35   48     42.17%
/opt/homebrew/share/lua/5.4/busted/modules/helper_loader.lua         10   9      52.63%
/opt/homebrew/share/lua/5.4/busted/modules/output_handler_loader.lua 9    10     47.37%
/opt/homebrew/share/lua/5.4/busted/modules/test_file_loader.lua      47   7      87.04%
/opt/homebrew/share/lua/5.4/busted/outputHandlers/base.lua           82   21     79.61%
/opt/homebrew/share/lua/5.4/busted/outputHandlers/plainTerminal.lua  87   28     75.65%
/opt/homebrew/share/lua/5.4/busted/runner.lua                        70   68     50.72%
/opt/homebrew/share/lua/5.4/busted/status.lua                        21   2      91.30%
/opt/homebrew/share/lua/5.4/busted/utils.lua                         13   8      61.90%
/opt/homebrew/share/lua/5.4/luarocks/core/dir.lua                    31   17     64.58%
/opt/homebrew/share/lua/5.4/luarocks/core/manif.lua                  13   43     23.21%
/opt/homebrew/share/lua/5.4/luarocks/core/path.lua                   32   43     42.67%
/opt/homebrew/share/lua/5.4/luarocks/loader.lua                      39   64     37.86%
/opt/homebrew/share/lua/5.4/luassert/assert.lua                      37   44     45.68%
/opt/homebrew/share/lua/5.4/luassert/assertions.lua                  25   195    11.36%
/opt/homebrew/share/lua/5.4/luassert/formatters/init.lua             20   114    14.93%
/opt/homebrew/share/lua/5.4/luassert/match.lua                       1    31     3.12%
/opt/homebrew/share/lua/5.4/luassert/modifiers.lua                   3    8      27.27%
/opt/homebrew/share/lua/5.4/luassert/state.lua                       4    47     7.84%
/opt/homebrew/share/lua/5.4/luassert/util.lua                        51   127    28.65%
/opt/homebrew/share/lua/5.4/mediator.lua                             41   26     61.19%
/opt/homebrew/share/lua/5.4/pl/List.lua                              62   156    28.44%
/opt/homebrew/share/lua/5.4/pl/class.lua                             20   82     19.61%
/opt/homebrew/share/lua/5.4/pl/dir.lua                               67   186    26.48%
/opt/homebrew/share/lua/5.4/pl/path.lua                              49   209    18.99%
/opt/homebrew/share/lua/5.4/pl/tablex.lua                            27   375    6.72%
/opt/homebrew/share/lua/5.4/pl/types.lua                             5    63     7.35%
/opt/homebrew/share/lua/5.4/pl/utils.lua                             9    292    2.99%
/opt/homebrew/share/lua/5.4/say/init.lua                             13   15     46.43%
lua/go-unfucked/error-dim.lua                                        96   78     55.17%
lua/go-unfucked/import-hints.lua                                     41   55     42.71%
lua/go-unfucked/init.lua                                             8    0      100.00%
lua/go-unfucked/receiver-highlight.lua                               34   25     57.63%
lua/go-unfucked/shortnames.lua                                       75   29     72.12%
tests/deps/nvim-test-core/lua/nvim-test-core/init.lua                26   165    13.61%
tests/deps/nvim-test-core/lua/nvim-test-core/vim_mock.lua            248  408    37.80%
tests/deps/nvim-test-core/tests/vim_mock_spec.lua                    169  0      100.00%
tests/go-unfucked_spec.lua                                           988  1      99.90%
tests/minimal_init.lua                                               6    0      100.00%
-----------------------------------------------------------------------------------------
Total                                                                2965 3426   46.39%
